select('x')as"x"from(dual"d");
select q'|x|'as"x"from(dual"d");
select(1)"x"from(dual);
select('x')"x"from(dual);
select '--' "/*x"from(dual);
select '/*' "--x"from(dual);
select 'x' "x"from(dual);
select('x')from(dual);
select('x')as"x"from(dual)d;
select('x')as"x"from(dual d);
select('x')as"x"from(dual"d");
select 'x' "x"from(dual);
select/**/1/**/from/**/dual;
select--
1--
from--
dual;
select 'some
--
/*
*/
thin'
from dual;

SELECT
    ROWNUM,
    CASE WHEN ROW_COUNT > 2 THEN NVL(TO_CHAR(SID), 'Total') ELSE TO_CHAR(SID) END SID,
    PARALLEL_SERVERS,
    CPU_SECONDS,
    FETCHES,
    BUFFER_GETS,
    PHYSICAL_READ_REQUESTS,
    PHYSICAL_READS,
    PHYSICAL_READ_MB,
    PHYSICAL_WRITE_REQUESTS,
    DIRECT_WRITES,
    PHYSICAL_WRITE_MB,
    USER_IO_WAIT,
    USER_IO_WAIT_PCT,
    CONCURRENCY_WAIT,
    CONCURRENCY_WAIT_PCT,
    PLSQL_EXEC_TIME,
    PLSQL_EXEC_TIME_PCT
FROM
    (SELECT
        SID,
        PARALLEL_SERVERS,
        COALESCE(CPU_SECONDS, SUM(CPU_SECONDS)) CPU_SECONDS,
        COALESCE(FETCHES, SUM(FETCHES)) FETCHES,
        COALESCE(BUFFER_GETS, SUM(BUFFER_GETS)) BUFFER_GETS,
        COALESCE(PHYSICAL_READ_REQUESTS, SUM(PHYSICAL_READ_REQUESTS)) PHYSICAL_READ_REQUESTS,
        COALESCE(PHYSICAL_READS, SUM(PHYSICAL_READS)) PHYSICAL_READS,
        COALESCE(PHYSICAL_READ_MB, SUM(PHYSICAL_READ_MB)) PHYSICAL_READ_MB,
        COALESCE(PHYSICAL_WRITE_REQUESTS, SUM(PHYSICAL_WRITE_REQUESTS)) PHYSICAL_WRITE_REQUESTS,
        COALESCE(DIRECT_WRITES, SUM(DIRECT_WRITES)) DIRECT_WRITES,
        COALESCE(PHYSICAL_WRITE_MB, SUM(PHYSICAL_WRITE_MB)) PHYSICAL_WRITE_MB,
        COALESCE(USER_IO_WAIT, SUM(USER_IO_WAIT)) USER_IO_WAIT,
        ROUND(USER_IO_WAIT / TOTAL_TIME_PERCENT_BASE, 1) USER_IO_WAIT_PCT,
        COALESCE(CONCURRENCY_WAIT, SUM(CONCURRENCY_WAIT)) CONCURRENCY_WAIT,
        ROUND(CONCURRENCY_WAIT / TOTAL_TIME_PERCENT_BASE, 1) CONCURRENCY_WAIT_PCT,
        COALESCE(PLSQL_EXEC_TIME, SUM(PLSQL_EXEC_TIME)) PLSQL_EXEC_TIME,
        ROUND(PLSQL_EXEC_TIME / TOTAL_TIME_PERCENT_BASE, 1) PLSQL_EXEC_TIME_PCT,
        COUNT(*) OVER () ROW_COUNT
    FROM
        (SELECT
            V$SESSION.SID,
            CPU_TIME / 1000000 CPU_SECONDS,
            FETCHES,
            BUFFER_GETS,
            PHYSICAL_READ_REQUESTS,
            DISK_READS PHYSICAL_READS,
            ROUND(PHYSICAL_READ_BYTES / 1048576) PHYSICAL_READ_MB,
            PHYSICAL_WRITE_REQUESTS,
            DIRECT_WRITES,
            ROUND(PHYSICAL_WRITE_BYTES / 1048576) PHYSICAL_WRITE_MB,
            USER_IO_WAIT_TIME / 1000000 USER_IO_WAIT,
            CONCURRENCY_WAIT_TIME / 1000000 CONCURRENCY_WAIT,
            PLSQL_EXEC_TIME / 1000000 PLSQL_EXEC_TIME,
            NULLIF(SUM(USER_IO_WAIT_TIME + CONCURRENCY_WAIT_TIME + PLSQL_EXEC_TIME) OVER () / 100000000, 0) TOTAL_TIME_PERCENT_BASE,
            CASE
                WHEN PX_SERVERS_REQUESTED IS NOT NULL THEN 'QC ' || PX_SERVERS_ALLOCATED || '/' || PX_SERVERS_REQUESTED
                WHEN PX_SERVER# IS NOT NULL THEN 'Slave ' || PX_SERVER#
                ELSE 'Serial'
            END PARALLEL_SERVERS,
            CASE
                WHEN PX_SERVERS_REQUESTED IS NOT NULL THEN 0
                WHEN PX_SERVER# IS NOT NULL THEN PX_SERVER#
            END SORTORDER
        FROM
            V$SESSION
            JOIN V$SQL_MONITOR
                ON V$SESSION.SID = V$SQL_MONITOR.SID AND V$SESSION.SQL_EXEC_ID = V$SQL_MONITOR.SQL_EXEC_ID AND V$SESSION.SQL_ID = V$SQL_MONITOR.SQL_ID AND V$SQL_MONITOR.STATUS = 'EXECUTING'
            /*LEFT JOIN
            (SELECT SESSION_ID, SQL_EXEC_ID, MAX(EVENT) KEEP (DENSE_RANK FIRST ORDER BY COUNT(*) OVER (PARTITION BY EVENT)) FROM V$ACTIVE_SESSION_HISTORY) ASH
                ON V$SESSION.SID = ASH.SESSION_ID AND V$SQL_MONITOR.SQL_EXEC_ID = ASH.SQL_EXEC_ID*/
        WHERE
            V$SESSION.SID = 184 OR BITAND(V$SESSION.OWNERID, 65535) = 184)
    GROUP BY
        ROLLUP((SID, CPU_SECONDS, FETCHES, BUFFER_GETS, PHYSICAL_READ_REQUESTS, PHYSICAL_READS, PHYSICAL_READ_MB, PHYSICAL_WRITE_REQUESTS, DIRECT_WRITES, PHYSICAL_WRITE_MB, USER_IO_WAIT, ROUND(USER_IO_WAIT / TOTAL_TIME_PERCENT_BASE, 1), CONCURRENCY_WAIT, ROUND(CONCURRENCY_WAIT / TOTAL_TIME_PERCENT_BASE, 1), PLSQL_EXEC_TIME, ROUND(PLSQL_EXEC_TIME / TOTAL_TIME_PERCENT_BASE, 1), PARALLEL_SERVERS, SORTORDER))
    ORDER BY
        SORTORDER) MONITOR_DATA
WHERE
    ROW_COUNT > 2 OR ROWNUM = 1;
