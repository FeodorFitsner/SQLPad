select('x')as"x"from(dual"d");
select q'|x|'as"x"from(dual"d");
select(1)"x"from(dual);
select('x')"x"from(dual);
select '--' "/*x"from(dual);
select '/*' "--x"from(dual);
select 'x' "x"from(dual);
select('x')from(dual);
select('x')as"x"from(dual)d;
select('x')as"x"from(dual d);
select('x')as"x"from(dual"d");
select 'x' "x"from(dual);
select/**/1/**/from/**/dual;
select--
1--
from--
dual;
select 'some
--
/*
*/
thin'
from dual;

SELECT
    ROWNUM,
    CASE WHEN ROW_COUNT > 2 THEN NVL(TO_CHAR(SID), 'Total') ELSE TO_CHAR(SID) END SID,
    PARALLEL_SERVERS,
    CPU_SECONDS,
    FETCHES,
    BUFFER_GETS,
    PHYSICAL_READ_REQUESTS,
    PHYSICAL_READS,
    PHYSICAL_READ_MB,
    PHYSICAL_WRITE_REQUESTS,
    DIRECT_WRITES,
    PHYSICAL_WRITE_MB,
    USER_IO_WAIT,
    USER_IO_WAIT_PCT,
    CONCURRENCY_WAIT,
    CONCURRENCY_WAIT_PCT,
    PLSQL_EXEC_TIME,
    PLSQL_EXEC_TIME_PCT
FROM
    (SELECT
        SID,
        PARALLEL_SERVERS,
        COALESCE(CPU_SECONDS, SUM(CPU_SECONDS)) CPU_SECONDS,
        COALESCE(FETCHES, SUM(FETCHES)) FETCHES,
        COALESCE(BUFFER_GETS, SUM(BUFFER_GETS)) BUFFER_GETS,
        COALESCE(PHYSICAL_READ_REQUESTS, SUM(PHYSICAL_READ_REQUESTS)) PHYSICAL_READ_REQUESTS,
        COALESCE(PHYSICAL_READS, SUM(PHYSICAL_READS)) PHYSICAL_READS,
        COALESCE(PHYSICAL_READ_MB, SUM(PHYSICAL_READ_MB)) PHYSICAL_READ_MB,
        COALESCE(PHYSICAL_WRITE_REQUESTS, SUM(PHYSICAL_WRITE_REQUESTS)) PHYSICAL_WRITE_REQUESTS,
        COALESCE(DIRECT_WRITES, SUM(DIRECT_WRITES)) DIRECT_WRITES,
        COALESCE(PHYSICAL_WRITE_MB, SUM(PHYSICAL_WRITE_MB)) PHYSICAL_WRITE_MB,
        COALESCE(USER_IO_WAIT, SUM(USER_IO_WAIT)) USER_IO_WAIT,
        ROUND(USER_IO_WAIT / TOTAL_TIME_PERCENT_BASE, 1) USER_IO_WAIT_PCT,
        COALESCE(CONCURRENCY_WAIT, SUM(CONCURRENCY_WAIT)) CONCURRENCY_WAIT,
        ROUND(CONCURRENCY_WAIT / TOTAL_TIME_PERCENT_BASE, 1) CONCURRENCY_WAIT_PCT,
        COALESCE(PLSQL_EXEC_TIME, SUM(PLSQL_EXEC_TIME)) PLSQL_EXEC_TIME,
        ROUND(PLSQL_EXEC_TIME / TOTAL_TIME_PERCENT_BASE, 1) PLSQL_EXEC_TIME_PCT,
        COUNT(*) OVER () ROW_COUNT
    FROM
        (SELECT
            V$SESSION.SID,
            CPU_TIME / 1000000 CPU_SECONDS,
            FETCHES,
            BUFFER_GETS,
            PHYSICAL_READ_REQUESTS,
            DISK_READS PHYSICAL_READS,
            ROUND(PHYSICAL_READ_BYTES / 1048576) PHYSICAL_READ_MB,
            PHYSICAL_WRITE_REQUESTS,
            DIRECT_WRITES,
            ROUND(PHYSICAL_WRITE_BYTES / 1048576) PHYSICAL_WRITE_MB,
            USER_IO_WAIT_TIME / 1000000 USER_IO_WAIT,
            CONCURRENCY_WAIT_TIME / 1000000 CONCURRENCY_WAIT,
            PLSQL_EXEC_TIME / 1000000 PLSQL_EXEC_TIME,
            NULLIF(SUM(USER_IO_WAIT_TIME + CONCURRENCY_WAIT_TIME + PLSQL_EXEC_TIME) OVER () / 100000000, 0) TOTAL_TIME_PERCENT_BASE,
            CASE
                WHEN PX_SERVERS_REQUESTED IS NOT NULL THEN 'QC ' || PX_SERVERS_ALLOCATED || '/' || PX_SERVERS_REQUESTED
                WHEN PX_SERVER# IS NOT NULL THEN 'Slave ' || PX_SERVER#
                ELSE 'Serial'
            END PARALLEL_SERVERS,
            CASE
                WHEN PX_SERVERS_REQUESTED IS NOT NULL THEN 0
                WHEN PX_SERVER# IS NOT NULL THEN PX_SERVER#
            END SORTORDER
        FROM
            V$SESSION
            JOIN V$SQL_MONITOR
                ON V$SESSION.SID = V$SQL_MONITOR.SID AND V$SESSION.SQL_EXEC_ID = V$SQL_MONITOR.SQL_EXEC_ID AND V$SESSION.SQL_ID = V$SQL_MONITOR.SQL_ID AND V$SQL_MONITOR.STATUS = 'EXECUTING'
            /*LEFT JOIN
            (SELECT SESSION_ID, SQL_EXEC_ID, MAX(EVENT) KEEP (DENSE_RANK FIRST ORDER BY COUNT(*) OVER (PARTITION BY EVENT)) FROM V$ACTIVE_SESSION_HISTORY) ASH
                ON V$SESSION.SID = ASH.SESSION_ID AND V$SQL_MONITOR.SQL_EXEC_ID = ASH.SQL_EXEC_ID*/
        WHERE
            V$SESSION.SID = 184 OR BITAND(V$SESSION.OWNERID, 65535) = 184)
    GROUP BY
        ROLLUP((SID, CPU_SECONDS, FETCHES, BUFFER_GETS, PHYSICAL_READ_REQUESTS, PHYSICAL_READS, PHYSICAL_READ_MB, PHYSICAL_WRITE_REQUESTS, DIRECT_WRITES, PHYSICAL_WRITE_MB, USER_IO_WAIT, ROUND(USER_IO_WAIT / TOTAL_TIME_PERCENT_BASE, 1), CONCURRENCY_WAIT, ROUND(CONCURRENCY_WAIT / TOTAL_TIME_PERCENT_BASE, 1), PLSQL_EXEC_TIME, ROUND(PLSQL_EXEC_TIME / TOTAL_TIME_PERCENT_BASE, 1), PARALLEL_SERVERS, SORTORDER))
    ORDER BY
        SORTORDER) MONITOR_DATA
WHERE
    ROW_COUNT > 2 OR ROWNUM = 1;

WITH MONITOR_DATA AS
  (SELECT INST_ID,
    KEY,
    NVL2(PX_QCSID, NULL, STATUS) STATUS,
    FIRST_REFRESH_TIME,
    LAST_REFRESH_TIME,
    REFRESH_COUNT,
    PROCESS_NAME,
    SID,
    SQL_ID,
    SQL_EXEC_START,
    SQL_EXEC_ID,
    DBOP_NAME,
    DBOP_EXEC_ID,
    SQL_PLAN_HASH_VALUE,
    SESSION_SERIAL#,
    SQL_TEXT,
    IS_FULL_SQLTEXT,
    PX_SERVER#,
    PX_SERVER_GROUP,
    PX_SERVER_SET,
    PX_QCINST_ID,
    PX_QCSID,
    CASE
      WHEN ELAPSED_TIME < (CPU_TIME+ APPLICATION_WAIT_TIME+ CONCURRENCY_WAIT_TIME+ CLUSTER_WAIT_TIME+ USER_IO_WAIT_TIME+ QUEUING_TIME)
      THEN (CPU_TIME               + APPLICATION_WAIT_TIME+ CONCURRENCY_WAIT_TIME+ CLUSTER_WAIT_TIME+ USER_IO_WAIT_TIME+ QUEUING_TIME)
      ELSE ELAPSED_TIME
    END ELAPSED_TIME,
    QUEUING_TIME,
    CPU_TIME,
    APPLICATION_WAIT_TIME,
    CONCURRENCY_WAIT_TIME,
    CLUSTER_WAIT_TIME,
    USER_IO_WAIT_TIME,
    CASE
      WHEN ELAPSED_TIME < (CPU_TIME+ APPLICATION_WAIT_TIME+ CONCURRENCY_WAIT_TIME+ CLUSTER_WAIT_TIME+ USER_IO_WAIT_TIME+ QUEUING_TIME)
      THEN 0
      ELSE ELAPSED_TIME - (CPU_TIME+ APPLICATION_WAIT_TIME+ CONCURRENCY_WAIT_TIME+ CLUSTER_WAIT_TIME+ USER_IO_WAIT_TIME+ QUEUING_TIME)
    END OTHER_WAIT_TIME,
    PLSQL_EXEC_TIME,
    JAVA_EXEC_TIME,
    FETCHES,
    BUFFER_GETS,
    IO_INTERCONNECT_BYTES IO_INTER_BYTES,
    PHYSICAL_READ_REQUESTS READ_REQS,
    PHYSICAL_READ_BYTES READ_BYTES,
    PHYSICAL_WRITE_REQUESTS WRITE_REQS,
    PHYSICAL_WRITE_BYTES WRITE_BYTES,
    NVL(PHYSICAL_READ_BYTES, 0)    + NVL(PHYSICAL_WRITE_BYTES, 0) IO_BYTES,
    NVL(PHYSICAL_READ_REQUESTS, 0) + NVL(PHYSICAL_WRITE_REQUESTS, 0) IO_REQS,
    USER# USERID,
    USERNAME,
    MODULE,
    ACTION,
    SERVICE_NAME,
    CLIENT_IDENTIFIER,
    CLIENT_INFO,
    PROGRAM,
    PLSQL_OBJECT_ID PL_OID,
    PLSQL_SUBPROGRAM_ID PL_PROGID,
    PLSQL_ENTRY_OBJECT_ID PL_ENTRY_OID,
    PLSQL_ENTRY_SUBPROGRAM_ID PL_ENTRY_PROGID,
    PX_MAXDOP MAX_DOP,
    PX_IS_CROSS_INSTANCE,
    PX_MAXDOP_INSTANCES MAX_DOP_INSTANCES,
    PX_SERVERS_REQUESTED SERVERS_REQUESTED,
    PX_SERVERS_ALLOCATED SERVERS_ALLOCATED,
    ERROR_NUMBER,
    ERROR_FACILITY,
    ERROR_MESSAGE,
    NVL2(OTHER_XML, 'Y', NULL) HAS_OTHER_XML,
    NVL2(BINDS_XML, 'Y', NULL) HAS_BINDS_XML,
    NVL2(RM_CONSUMER_GROUP, NVL2(RM_LAST_ACTION_TIME, TO_CHAR(RM_LAST_ACTION_TIME, :B12 ), '00/00/0000 00:00:01')
    || XMLELEMENT( "rminfo", XMLATTRIBUTES( RM_LAST_ACTION AS "rmlastact", RM_LAST_ACTION_REASON AS "rmlastreason", TO_CHAR(RM_LAST_ACTION_TIME, :B12 ) AS "rmlasttime", RM_CONSUMER_GROUP AS "rmcg")).GETSTRINGVAL(), '00/00/0000 00:00:00') RM_INFO,
    CON_NAME,
    CON_ID
  FROM GV$SQL_MONITOR MO1
  WHERE MO1.INST_ID BETWEEN :B11 AND :B10
  AND MO1.SQL_ID          = NVL(:B9 , MO1.SQL_ID)
  AND MO1.SQL_EXEC_START  = NVL(:B8 , MO1.SQL_EXEC_START)
  AND MO1.SQL_EXEC_ID     = NVL(:B7 , MO1.SQL_EXEC_ID)
  OR (MO1.DBOP_NAME       = NVL(:B6 , MO1.DBOP_NAME)
  AND MO1.DBOP_EXEC_ID    = NVL(:B5 , MO1.DBOP_EXEC_ID))
  AND ((:B4               = 1
  AND MO1.PX_QCSID       IS NULL)
  OR (MO1.PX_SERVER_GROUP = NVL(:B3 , MO1.PX_SERVER_GROUP)
  AND MO1.PX_SERVER_SET   = NVL(:B2 , MO1.PX_SERVER_SET)
  AND MO1.PX_SERVER#      = NVL(:B1 , MO1.PX_SERVER#)))
  ),
  MONITOR_AGG AS
  (SELECT MAX_PX_QCSID,
    MAX_KEY,
    MAX_INST_ID,
    MAX_SESSION_ID,
    MAX_SESSION_SERIAL,
    MAX_PX_DOP,
    MAX_PX_DOP_INSTANCES,
    MAX_PX_IS_CROSS_INSTANCE,
    SUM_SERVERS_REQUESTED,
    SUM_SERVERS_ALLOCATED,
    DIST_INST_COUNT,
    DIST_PX_GROUP_COUNT,
    DIST_PX_SET_COUNT,
    MAX_PLAN_HASH_VALUE,
    MAX_USERID,
    MAX_PROGRAM,
    MAX_USERNAME,
    MAX_MODULE,
    MAX_ACTION,
    MAX_SERVICE_NAME,
    MAX_CLIENT_ID,
    MAX_CLIENT_INFO,
    MAX_ERROR_NUMBER,
    MAX_ERROR_FACILITY,
    MAX_ERROR_MESSAGE,
    QC_HAS_OTHER_XML,
    QC_HAS_BINDS_XML,
    MAX_PL_OID,
    MAX_PL_PROGID,
    MAX_PL_ENTRY_OID,
    MAX_PL_ENTRY_PROGID,
    MAX_SQL_ID,
    MAX_SQL_EXEC_START,
    MAX_SQL_EXEC_ID,
    MAX_LAST_REFRESH_TIME,
    MAX_DBOP_NAME,
    MAX_DBOP_EXEC_ID,
    CASE
      WHEN MAX_PL_OID IS NOT NULL
      THEN NVL(
        (SELECT P.OWNER
          || '.'
          || P.OBJECT_NAME
          || DECODE(P.PROCEDURE_NAME, NULL, '', '.'
          || P.PROCEDURE_NAME)
        FROM DBA_PROCEDURES P
        WHERE P.OBJECT_ID   = MAX_PL_OID
        AND P.SUBPROGRAM_ID = MAX_PL_PROGID
        ), 'Unavailable')
    END MAX_PL_NAME,
    CASE
      WHEN MAX_PL_ENTRY_OID IS NOT NULL
      THEN NVL(
        (SELECT P.OWNER
          || '.'
          || P.OBJECT_NAME
          || DECODE(P.PROCEDURE_NAME, NULL, '', '.'
          || P.PROCEDURE_NAME)
        FROM DBA_PROCEDURES P
        WHERE P.OBJECT_ID   = MAX_PL_ENTRY_OID
        AND P.SUBPROGRAM_ID = MAX_PL_ENTRY_PROGID
        ), 'Unavailable')
    END MAX_PL_ENTRY_NAME,
    MAX_STATUS,
    SUM_REFRESH_COUNT,
    MIN_FIRST_REFRESH_TIME,
    IS_FULL_TEXT,
    SQLMON_TEXT,
    SUM_ELAPSED_TIME,
    MAX_ELAPSED_TIME,
    MAX_QUEUING_TIME,
    SUM_CPU_TIME,
    SUM_USER_IO_WAIT_TIME,
    SUM_APPLICATION_WAIT_TIME,
    SUM_CONCURRENCY_WAIT_TIME,
    SUM_CLUSTER_WAIT_TIME,
    SUM_PLSQL_EXEC_TIME,
    SUM_JAVA_EXEC_TIME,
    SUM_OTHER_WAIT_TIME,
    SUM_FETCHES,
    SUM_BUFFER_GETS,
    SUM_READ_REQS,
    SUM_READ_BYTES,
    SUM_WRITE_REQS,
    SUM_WRITE_BYTES,
    SUM_IO_BYTES,
    SUM_IO_INTER_BYTES,
    DECODE(:B14 , 1, 'db_name', DB.DB_UNIQUE_NAME) DB_UNIQUE_NAME,
    DECODE(:B14 , 1, 'platform_name', DB.PLATFORM_NAME) PLATFORM_NAME,
    DECODE(:B14 , 1, 'host_name', INST.HOST_NAME) HOST_NAME,
    AGG_RM_INFO MAX_RM_INFO,
    MAX_CON_NAME,
    DECODE(MAX_CON_ID, 0, NULL, MAX_CON_ID) MAX_CON_ID
  FROM
    (SELECT MAX(PX_QCSID) MAX_PX_QCSID,
      MAX(
      CASE
        WHEN PX_QCSID IS NULL
        THEN KEY
        ELSE NULL
      END) MAX_KEY,
      MAX(
      CASE
        WHEN PX_QCSID IS NULL
        THEN INST_ID
        ELSE NULL
      END) MAX_INST_ID,
      MAX(
      CASE
        WHEN PX_QCSID IS NULL
        THEN SID
        ELSE NULL
      END) MAX_SESSION_ID,
      MAX(
      CASE
        WHEN PX_QCSID IS NULL
        THEN SESSION_SERIAL#
        ELSE NULL
      END) MAX_SESSION_SERIAL,
      MAX(MAX_DOP) MAX_PX_DOP,
      MAX(MAX_DOP_INSTANCES) MAX_PX_DOP_INSTANCES,
      MAX(PX_IS_CROSS_INSTANCE) MAX_PX_IS_CROSS_INSTANCE,
      SUM(SERVERS_REQUESTED) SUM_SERVERS_REQUESTED,
      SUM(SERVERS_ALLOCATED) SUM_SERVERS_ALLOCATED,
      COUNT(DISTINCT INST_ID) DIST_INST_COUNT,
      COUNT(DISTINCT PX_SERVER_GROUP) DIST_PX_GROUP_COUNT,
      COUNT(DISTINCT PX_SERVER_SET) DIST_PX_SET_COUNT,
      MAX(SQL_PLAN_HASH_VALUE) MAX_PLAN_HASH_VALUE,
      MAX(USERID) MAX_USERID,
      MAX(PROGRAM) MAX_PROGRAM,
      MAX(USERNAME) MAX_USERNAME,
      MAX(MODULE) MAX_MODULE,
      MAX(ACTION) MAX_ACTION,
      MAX(SERVICE_NAME) MAX_SERVICE_NAME,
      MAX(CLIENT_IDENTIFIER) MAX_CLIENT_ID,
      MAX(CLIENT_INFO) MAX_CLIENT_INFO,
      MAX(ERROR_NUMBER) MAX_ERROR_NUMBER,
      MAX(ERROR_FACILITY) MAX_ERROR_FACILITY,
      MAX(ERROR_MESSAGE) MAX_ERROR_MESSAGE,
      MAX(NVL2(PX_QCSID, HAS_OTHER_XML, NULL)) QC_HAS_OTHER_XML,
      MAX(HAS_BINDS_XML) QC_HAS_BINDS_XML,
      MAX(PL_OID) MAX_PL_OID,
      MAX(PL_PROGID) MAX_PL_PROGID,
      MAX(PL_ENTRY_OID) MAX_PL_ENTRY_OID,
      MAX(PL_ENTRY_PROGID) MAX_PL_ENTRY_PROGID,
      MAX(SQL_ID) MAX_SQL_ID,
      MAX(SQL_EXEC_START) MAX_SQL_EXEC_START,
      MAX(SQL_EXEC_ID) MAX_SQL_EXEC_ID,
      MAX(LAST_REFRESH_TIME) MAX_LAST_REFRESH_TIME,
      MAX(STATUS) MAX_STATUS,
      SUM(REFRESH_COUNT) SUM_REFRESH_COUNT,
      MIN(FIRST_REFRESH_TIME) MIN_FIRST_REFRESH_TIME,
      MAX(DBOP_NAME) MAX_DBOP_NAME,
      MAX(DBOP_EXEC_ID) MAX_DBOP_EXEC_ID,
      CASE
        WHEN :B13 = 0
        THEN NULL
        ELSE MAX(SQL_TEXT)
      END SQLMON_TEXT,
      MAX(IS_FULL_SQLTEXT) IS_FULL_TEXT,
      SUM(ELAPSED_TIME) SUM_ELAPSED_TIME,
      MAX(ELAPSED_TIME) MAX_ELAPSED_TIME,
      MAX(QUEUING_TIME) MAX_QUEUING_TIME,
      SUM(CPU_TIME) SUM_CPU_TIME,
      SUM(USER_IO_WAIT_TIME) SUM_USER_IO_WAIT_TIME,
      SUM(APPLICATION_WAIT_TIME) SUM_APPLICATION_WAIT_TIME,
      SUM(CONCURRENCY_WAIT_TIME) SUM_CONCURRENCY_WAIT_TIME,
      SUM(CLUSTER_WAIT_TIME) SUM_CLUSTER_WAIT_TIME,
      SUM(PLSQL_EXEC_TIME) SUM_PLSQL_EXEC_TIME,
      SUM(JAVA_EXEC_TIME) SUM_JAVA_EXEC_TIME,
      SUM(OTHER_WAIT_TIME) SUM_OTHER_WAIT_TIME,
      SUM(FETCHES) SUM_FETCHES,
      SUM(BUFFER_GETS) SUM_BUFFER_GETS,
      SUM(READ_REQS) SUM_READ_REQS,
      SUM(READ_BYTES) SUM_READ_BYTES,
      SUM(WRITE_REQS) SUM_WRITE_REQS,
      SUM(WRITE_BYTES) SUM_WRITE_BYTES,
      NVL(SUM(READ_BYTES), 0) + NVL(SUM(WRITE_BYTES), 0) SUM_IO_BYTES,
      SUM(IO_INTER_BYTES) SUM_IO_INTER_BYTES,
      MAX(RM_INFO) AGG_RM_INFO,
      MAX(CON_NAME) MAX_CON_NAME,
      MAX(CON_ID) MAX_CON_ID
    FROM MONITOR_DATA
    ) MD,
    (SELECT HOST_NAME FROM V$INSTANCE
    ) INST,
    (SELECT DB_UNIQUE_NAME, PLATFORM_NAME FROM V$DATABASE
    ) DB
  ),
  ASH_DATA AS
  (SELECT AD0.INST_ID,
    AD0.SESSION_ID,
    AD0.PLAN_LINE_ID,
    AD0.PLSQL_OBJECT_ID,
    AD0.PLSQL_SUBPROGRAM_ID,
    AD0.ACTIVITY_BUCKET_NUM,
    AD0.PLAN_ACTIVITY_BUCKET_NUM,
    AD0.SQL,
    AD0.TOP_LEVEL_SQL_ID,
    AD0.DBOP_NAME,
    AD0.IS_MONITORED_SQL,
    AD0.IS_PX_SLAVE,
    AD0.BUCKET_ACTIVITY_START,
    AD0.ACTIVITY_START,
    AD0.BUCKET_ACTIVITY_END,
    AD0.ACTIVITY_END,
    AD0.ACTIVITY_COUNT,
    AD0.ACTIVITY_TYPE,
    AD0.OTHER_SQL_ACTIVITY_TYPE,
    AD0.EVENT_NAME,
    AD0.WAIT_COUNT,
    AD0.CPU_COUNT,
    AD0.OTHER_SQL_COUNT,
    AD0.PX_SERVER_SET,
    AD0.PX_DFO_ACTIVITY_COUNT,
    AD0.DFO_MOST_ACTIVE_IID,
    AD0.DFO_MOST_ACTIVE_SID,
    (
    CASE
      WHEN AD0.DFO_MOST_ACTIVE_IID                                   = AD0.INST_ID
      AND AD0.DFO_MOST_ACTIVE_SID                                    = AD0.SESSION_ID
      AND (((AD0.PX_DFO_ACTIVITY_COUNT / AD0.DFO_MOST_ACTIVE_COUNT) >= AD0.PX_DOP * 1.05)
      OR ((AD0.PX_DFO_ACTIVITY_COUNT   / AD0.DFO_MOST_ACTIVE_COUNT) <= AD0.PX_DOP *0.95))
      AND (AD0.DFO_DURATION            * 100)                        > :B32
      THEN AD0.ACTIVITY_COUNT
      ELSE NULL
    END) DFO_MOST_ACTIVE_COUNT,
    AD0.BUCKET_DISTINCT_SAMPLES,
    AD0.SQL_BUCKET_DISTINCT_SAMPLES,
    CASE
      WHEN AD0.PX_SERVER_GROUP IS NULL
      AND AD0.IS_PX_SLAVE       = 1
      THEN 1
      ELSE AD0.PX_SERVER_GROUP
    END PX_SERVER_GROUP,
    AD0.PX_STEP_ID,
    AD0.PX_DFO_PAIR_TYPE,
    AD0.PX_DFO_PAIR_ID,
    AD0.PX_STEP_ARG,
    AD0.PX_DOP,
    CASE
      WHEN AD0.PX_DOP    IS NOT NULL
      AND AD0.PX_DOP     <> AD0.PX_MIN_DOP
      AND AD0.PX_MIN_DOP != 0
      THEN PX_MIN_DOP
      ELSE NULL
    END PX_MIN_DOP
  FROM
    (SELECT
      /*+ use_hash(ash) leading(mo) */
      ASH.INST_ID,
      ASH.IS_PX_SLAVE,
      ASH.SESSION_ID,
      ASH.PLAN_LINE_ID,
      ASH.PLSQL_OBJECT_ID,
      ASH.PLSQL_SUBPROGRAM_ID,
      ASH.ACTIVITY_BUCKET_NUM,
      ASH.PLAN_ACTIVITY_BUCKET_NUM,
      ASH.SQL,
      ASH.TOP_LEVEL_SQL_ID,
      ASH.DBOP_NAME,
      ASH.IS_MONITORED_SQL,
      ASH.BUCKET_ACTIVITY_START,
      ASH.ACTIVITY_START,
      ASH.BUCKET_ACTIVITY_END,
      ASH.ACTIVITY_END,
      ASH.ACTIVITY_COUNT,
      ASH.ACTIVITY_TYPE,
      ASH.OTHER_SQL_ACTIVITY_TYPE,
      ASH.EVENT_NAME,
      ASH.WAIT_COUNT,
      ASH.CPU_COUNT,
      ASH.OTHER_SQL_COUNT,
      MO.PX_SERVER_SET,
      ASH.PX_DFO_ACTIVITY_COUNT,
      TRUNC(ASH.MOST_ACTIVE_IN_DFO     / 10000000000) DFO_MOST_ACTIVE_COUNT,
      MOD(TRUNC(ASH.MOST_ACTIVE_IN_DFO / 1000000), 10000) DFO_MOST_ACTIVE_IID,
      MOD(ASH.MOST_ACTIVE_IN_DFO, 1000000) DFO_MOST_ACTIVE_SID,
      ASH.DFO_DURATION,
      ASH.BUCKET_DISTINCT_SAMPLES,
      ASH.SQL_BUCKET_DISTINCT_SAMPLES,
      MO.PX_SERVER_GROUP,
      ASH.PX_STEP_ID,
      ASH.PX_DFO_PAIR_TYPE,
      ASH.PX_DFO_PAIR_ID,
      ASH.PX_STEP_ARG,
      ASH.PX_DOP,
      ASH.PX_MIN_DOP
    FROM
      (SELECT
        /*+ no_merge */
        MD.INST_ID,
        MD.SID,
        MD.SESSION_SERIAL#,
        MD.PX_SERVER_SET,
        MD.PX_SERVER_GROUP
      FROM MONITOR_DATA MD
      WHERE MD.SID IS NOT NULL
      OR :B31       = 1
      ) MO,
      (SELECT
        /*+ no_merge */
        GVTF.INST_ID,
        GVTF.GLOBAL_SAMPLE_ID,
        GVTF.IS_PX_SLAVE,
        GVTF.SESSION_ID,
        GVTF.PLAN_LINE_ID,
        GVTF.PLSQL_OBJECT_ID,
        GVTF.PLSQL_SUBPROGRAM_ID,
        GVTF.ACTIVITY_BUCKET_NUM,
        GVTF.PLAN_ACTIVITY_BUCKET_NUM,
        GVTF.SQL,
        GVTF.TOP_LEVEL_SQL_ID,
        GVTF.DBOP_NAME,
        GVTF.IS_MONITORED_SQL,
        GVTF.BUCKET_ACTIVITY_START,
        GVTF.ACTIVITY_START,
        GVTF.BUCKET_ACTIVITY_END,
        GVTF.ACTIVITY_END,
        GVTF.ACTIVITY_COUNT,
        GVTF.ACTIVITY_TYPE,
        GVTF.OTHER_SQL_ACTIVITY_TYPE,
        GVTF.EVENT_NAME,
        GVTF.WAIT_COUNT,
        GVTF.CPU_COUNT,
        GVTF.OTHER_SQL_COUNT,
        MAX(GVTF.PER_SERVER_DFO_COUNT * 10000000000 + GVTF.INST_ID * 1000000 + GVTF.SESSION_ID) OVER(PARTITION BY GVTF.PX_DFO_PAIR_TYPE, GVTF.PX_DFO_PAIR_ID) MOST_ACTIVE_IN_DFO,
        SUM(GVTF.ACTIVITY_COUNT) OVER(PARTITION BY GVTF.PX_DFO_PAIR_TYPE, GVTF.PX_DFO_PAIR_ID) PX_DFO_ACTIVITY_COUNT,
        GVTF.DFO_DURATION,
        GVTF.PX_STEP_ID,
        GVTF.PX_DFO_PAIR_TYPE,
        GVTF.PX_DFO_PAIR_ID,
        GVTF.PX_STEP_ARG,
        GVTF.PX_DOP,
        GVTF.PX_MIN_DOP,
        COUNT(DISTINCT GVTF.GLOBAL_SAMPLE_ID) OVER(PARTITION BY GVTF.ACTIVITY_BUCKET_NUM) BUCKET_DISTINCT_SAMPLES,
        COUNT(DISTINCT GVTF.GLOBAL_SAMPLE_ID) OVER(PARTITION BY GVTF.SQL, GVTF.ACTIVITY_BUCKET_NUM) SQL_BUCKET_DISTINCT_SAMPLES
      FROM TABLE(GV$(CURSOR(
        (SELECT USERENV('INSTANCE') INST_ID,
          ASH2.GLOBAL_SAMPLE_ID,
          CASE
            WHEN :B30 = 1
            AND :B27  > 1
            THEN BUCKET_NUM
            ELSE NULL
          END ACTIVITY_BUCKET_NUM,
          CASE
            WHEN :B29 = 1
            AND :B27  > 1
            THEN BUCKET_NUM
            ELSE NULL
          END PLAN_ACTIVITY_BUCKET_NUM,
          ASH2.SQL,
          ASH2.TOP_LEVEL_SQL_ID,
          ASH2.DBOP_NAME,
          ASH2.IS_MONITORED_SQL,
          ASH2.PLAN_LINE_ID,
          ASH2.PLSQL_OBJECT_ID,
          ASH2.PLSQL_SUBPROGRAM_ID,
          ASH2.ACTIVITY_TYPE,
          ASH2.OTHER_SQL_ACTIVITY_TYPE,
          ASH2.EVENT_NAME,
          ASH2.IS_PX_SLAVE,
          ASH2.SESSION_ID,
          ASH2.PX_STEP_ID,
          ASH2.PX_DFO_PAIR_TYPE,
          ASH2.PX_DFO_PAIR_ID,
          ASH2.PX_STEP_ARG,
          CASE
            WHEN ASH2.PX_DFO_PAIR_ID IS NOT NULL
            THEN DECODE(ASH2.PX_DOP, 0, :B28 , ASH2.PX_DOP)
            ELSE NULL
          END PX_DOP,
          ASH2.PX_MIN_DOP,
          :B20 + NUMTODSINTERVAL(:B26 * (ASH2.BUCKET_NUM-1), 'SECOND') BUCKET_ACTIVITY_START,
          :B20 + NUMTODSINTERVAL( :B26 * ASH2.BUCKET_NUM - 1, 'SECOND') BUCKET_ACTIVITY_END,
          ASH2.ACTIVITY_START,
          ASH2.ACTIVITY_END,
          ASH2.ACTIVITY_COUNT,
          ASH2.WAIT_COUNT,
          ASH2.CPU_COUNT,
          ASH2.OTHER_SQL_COUNT,
          SUM(ASH2.ACTIVITY_COUNT) OVER(PARTITION BY ASH2.PX_DFO_PAIR_ID, ASH2.PX_DFO_PAIR_TYPE, DECODE(ASH2.PX_DFO_PAIR_ID, NULL, NULL, ASH2.SESSION_ID)) PER_SERVER_DFO_COUNT,
          CEIL((MAX(ASH2.MAX_SAMPLE_DATE) OVER(PARTITION BY ASH2.PX_DFO_PAIR_ID, ASH2.PX_DFO_PAIR_TYPE) - MIN(ASH2.MIN_SAMPLE_DATE) OVER(PARTITION BY ASH2.PX_DFO_PAIR_ID, ASH2.PX_DFO_PAIR_TYPE)) * 3600 * 24) DFO_DURATION
        FROM
          (SELECT ASH1.BUCKET_NUM,
            ASH1.GLOBAL_SAMPLE_ID,
            ASH1.PLAN_LINE_ID,
            ASH1.PLSQL_OBJECT_ID,
            ASH1.PLSQL_SUBPROGRAM_ID,
            ASH1.ACTIVITY_TYPE,
            ASH1.OTHER_SQL_ACTIVITY_TYPE,
            ASH1.EVENT_NAME,
            ASH1.SESSION_ID,
            ASH1.PX_STEP_ID,
            ASH1.PX_STEP_ARG,
            MAX(ASH1.SQL) SQL,
            MAX(ASH1.IS_MONITORED_SQL) IS_MONITORED_SQL,
            MAX(ASH1.PX_DFO_PAIR_TYPE) PX_DFO_PAIR_TYPE,
            MAX(ASH1.PX_DFO_PAIR_ID) PX_DFO_PAIR_ID,
            MIN(SAMPLE_DATE) MIN_SAMPLE_DATE,
            MAX(SAMPLE_DATE) MAX_SAMPLE_DATE,
            MAX(ASH1.IS_PX_SLAVE) IS_PX_SLAVE,
            MAX(ASH1.PX_DOP) PX_DOP,
            MIN(ASH1.PX_DOP) PX_MIN_DOP,
            MIN(ASH1.SAMPLE_DATE) ACTIVITY_START,
            MAX(ASH1.SAMPLE_DATE) ACTIVITY_END,
            COUNT(ASH1.SQL) ACTIVITY_COUNT,
            COUNT(
            CASE
              WHEN ASH1.ACTIVITY_TYPE != 'Other SQL Execution'
              AND ASH1.ACTIVITY_TYPE  != 'Non SQL'
              AND ASH1.ACTIVITY_TYPE  != 'Cpu'
              THEN 1
              ELSE NULL
            END) WAIT_COUNT,
            COUNT(
            CASE
              WHEN ASH1.ACTIVITY_TYPE = 'Cpu'
              THEN 1
              ELSE NULL
            END) CPU_COUNT,
            COUNT(
            CASE
              WHEN ASH1.ACTIVITY_TYPE = 'Other SQL Execution'
              AND ASH1.ACTIVITY_TYPE != 'Non SQL'
              THEN 1
              ELSE NULL
            END) OTHER_SQL_COUNT,
            MAX(ASH1.TOP_LEVEL_SQL_ID) TOP_LEVEL_SQL_ID,
            MAX(ASH1.DBOP_NAME) DBOP_NAME
          FROM
            (SELECT (
              CASE
                WHEN :B27 > 1
                THEN (TRUNC(DELTA_TIME_SECONDS/ :B26 ) + 1)
                ELSE 1
              END) BUCKET_NUM,
              ASH00.SQL,
              ASH00.SAMPLE_DATE,
              NVL2(DUP.C2, TRUNC(DELTA_TIME_SECONDS/ (:B25 )) + 1, NULL) GLOBAL_SAMPLE_ID,
              NVL2(DUP.C2, NULL, ASH00.IS_MONITORED_SQL) IS_MONITORED_SQL,
              NVL2(DUP.C2, NULL, ASH00.WAIT_CLASS) WAIT_CLASS,
              NVL2(DUP.C2, NULL, ASH00.ACTIVITY_TYPE) ACTIVITY_TYPE,
              NVL2(DUP.C2, NULL, ASH00.OTHER_SQL_ACTIVITY_TYPE) OTHER_SQL_ACTIVITY_TYPE,
              NVL2(DUP.C2, NULL, ASH00.EVENT_NAME) EVENT_NAME,
              NVL2(DUP.C2, NULL, ASH00.TOP_LEVEL_SQL_ID) TOP_LEVEL_SQL_ID,
              NVL2(DUP.C2, NULL, ASH00.DBOP_NAME) DBOP_NAME,
              NVL2(DUP.C2, NULL, ASH00.IS_PX_SLAVE) IS_PX_SLAVE,
              NVL2(DUP.C2, NULL, ASH00.SESSION_ID) SESSION_ID,
              NVL2(DUP.C2, NULL, ASH00.PLSQL_OBJECT_ID) PLSQL_OBJECT_ID,
              NVL2(DUP.C2, NULL, ASH00.PLSQL_SUBPROGRAM_ID) PLSQL_SUBPROGRAM_ID,
              NVL2(DUP.C2, NULL, ASH00.PLAN_LINE_ID) PLAN_LINE_ID,
              NVL2(DUP.C2, NULL, ASH00.PX_STEP_ID) PX_STEP_ID,
              NVL2(DUP.C2, NULL, ASH00.PX_STEP_ARG) PX_STEP_ARG,
              NVL2(DUP.C2, NULL, ASH00.PX_DFO_PAIR_ID) PX_DFO_PAIR_ID,
              NVL2(DUP.C2, NULL, ASH00.PX_DFO_PAIR_TYPE) PX_DFO_PAIR_TYPE,
              NVL2(DUP.C2, NULL, ASH00.PX_DOP) PX_DOP
            FROM
              (SELECT 1 C1, NULL C2 FROM V$TIMER
              UNION ALL
              SELECT 1 C1, 1 C2 FROM V$TIMER
              ) DUP,
              (SELECT
                /*+ no_merge */
                1 C1,
                ASH000.SAMPLE_DATE,
                ASH000.IS_MONITORED_SQL,
                ((EXTRACT(SECOND FROM(DELTA_TIME)) + EXTRACT(MINUTE FROM(DELTA_TIME)) * 60 + EXTRACT(HOUR FROM(DELTA_TIME)) * 3600 + EXTRACT(DAY FROM(DELTA_TIME)) * 86400)) DELTA_TIME_SECONDS,
                ASH000.WAIT_CLASS,
                DECODE(ASH000.IS_MONITORED_SQL, 1, NVL(ASH000.WAIT_CLASS, 'Cpu'), DECODE(SQL_ID, NULL, 'Non SQL', 'Other SQL Execution')) ACTIVITY_TYPE,
                NVL(ASH000.WAIT_CLASS, 'Cpu') OTHER_SQL_ACTIVITY_TYPE,
                DECODE(:B24 , 1,
                CASE
                  WHEN ASH000.IS_MONITORED_SQL = 1
                  THEN ASH000.EVENT
                  WHEN ASH000.SQL_ID IS NOT NULL
                  THEN 'sql_id: '
                    || ASH000.SQL_ID
                  WHEN ASH000.CALL_NAME IS NOT NULL
                  THEN 'call: '
                    || ASH000.CALL_NAME
                  ELSE 'anonymous: '
                    || ASH000.EVENT
                END, NULL) EVENT_NAME,
                CASE
                  WHEN ASH000.IS_MONITORED_SQL   = 1
                  AND (NVL(ASH000.SQL_ID, :B9 )  = :B9
                  OR NVL(ASH000.DBOP_NAME, :B6 ) = :B6 )
                  THEN 'this'
                  WHEN ASH000.IS_PX_SLAVE      = 1
                  AND ASH000.SQL_ID           IS NOT NULL
                  AND ASH000.TOP_LEVEL_SQL_ID != ASH000.SQL_ID
                  THEN ASH000.TOP_LEVEL_SQL_ID
                  WHEN ASH000.SQL_ID IS NOT NULL
                  THEN ASH000.SQL_ID
                  ELSE NVL(CALL_NAME, 'anonymous')
                END SQL,
                CASE
                  WHEN ASH000.IS_PX_SLAVE     = 0
                  AND (ASH000.SQL_ID         IS NULL
                  OR ASH000.TOP_LEVEL_SQL_ID != ASH000.SQL_ID)
                  THEN ASH000.TOP_LEVEL_SQL_ID
                END TOP_LEVEL_SQL_ID,
                ASH000.DBOP_NAME,
                ASH000.IS_PX_SLAVE,
                CASE
                  WHEN ASH000.IS_PX_SLAVE      = 1
                  AND ASH000.IS_MONITORED_SQL != 1
                  THEN 65536
                  ELSE ASH000.SESSION_ID
                END SESSION_ID,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PLSQL_OBJECT_ID, NULL) PLSQL_OBJECT_ID,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PLSQL_SUBPROGRAM_ID, NULL) PLSQL_SUBPROGRAM_ID,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.SQL_PLAN_LINE_ID, NULL) PLAN_LINE_ID,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PX_STEP_ID, NULL) PX_STEP_ID,
                CASE
                  WHEN ASH000.IS_PX_SLAVE     = 1
                  AND ASH000.IS_MONITORED_SQL = 1
                  AND ASH000.PX_STEP_ID      IN (1, 2, 3)
                  THEN ASH000.PX_STEP_ARG
                  ELSE NULL
                END PX_DFO_PAIR_ID,
                CASE
                  WHEN ASH000.IS_PX_SLAVE     = 0
                  OR ASH000.IS_MONITORED_SQL != 1
                  THEN NULL
                  WHEN ASH000.PX_STEP_ID = 1
                  THEN 1
                  WHEN ASH000.PX_STEP_ID IN (2, 3)
                  THEN 0
                  ELSE NULL
                END PX_DFO_PAIR_TYPE,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PX_STEP_ARG, NULL) PX_STEP_ARG,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PX_DOP, NULL) PX_DOP
              FROM
                (SELECT ASH0.*,
                  CASE
                    WHEN ASH0.IS_TARGET_SQL                        = 1
                    OR (ASH0.IS_PX_SLAVE                           = 1
                    AND ((NVL(ASH0.TOP_LEVEL_SQL_ID, ASH0.SQL_ID) IS NOT NULL
                    AND NVL(ASH0.TOP_LEVEL_SQL_ID, ASH0.SQL_ID)    = :B9 )
                    OR (SQL_ID                                    IS NULL
                    AND :B23                                       = 'Y')))
                    THEN 1
                    ELSE 0
                  END IS_MONITORED_SQL
                FROM
                  (SELECT (
                    CASE
                      WHEN (ASH.SQL_ID       = :B9
                      AND ASH.SQL_EXEC_ID    = :B7
                      AND ASH.SQL_EXEC_START = :B8 )
                      THEN 1
                      ELSE 0
                    END) IS_TARGET_SQL,
                    ASH.SQL_ID,
                    ASH.SQL_PLAN_LINE_ID,
                    ASH.PLSQL_OBJECT_ID,
                    ASH.PLSQL_SUBPROGRAM_ID,
                    ASH.TOP_LEVEL_SQL_ID,
                    DECODE(ASH.SQL_ID, NULL, ASH.TOP_LEVEL_CALL_NAME, NULL) CALL_NAME,
                    ASH.EVENT,
                    ASH.WAIT_CLASS,
                    ASH.SQL_EXEC_ID,
                    ASH.SQL_EXEC_START,
                    ASH.DBOP_NAME,
                    ASH.DBOP_EXEC_ID,
                    ASH.SESSION_ID,
                    ASH.SESSION_SERIAL#,
                    CASE
                      WHEN QC_INSTANCE_ID    IS NOT NULL
                      AND (ASH.SESSION_ID    != ASH.QC_SESSION_ID
                      OR ASH.SESSION_SERIAL# != ASH.QC_SESSION_SERIAL#
                      OR USERENV('instance') != ASH.QC_INSTANCE_ID)
                      THEN 1
                      ELSE 0
                    END IS_PX_SLAVE,
                    SAMPLE_TIME - CAST(:B20 AS                   TIMESTAMP) DELTA_TIME,
                    CAST(FROM_TZ(ASH.SAMPLE_TIME, DBTIMEZONE) AS DATE) SAMPLE_DATE,
                    TRUNC(MOD(PX_FLAGS/65536, 32)) PX_STEP_ID,
                    MOD(PX_FLAGS, 65536) PX_STEP_ARG,
                    TRUNC(PX_FLAGS/2097152) PX_DOP
                  FROM V$ACTIVE_SESSION_HISTORY ASH
                  WHERE ((ASH.SESSION_ID     = :B19
                  AND ASH.SESSION_SERIAL#    = :B18
                  AND USERENV('INSTANCE')    = :B17 )
                  OR (ASH.QC_SESSION_ID     IS NOT NULL
                  AND ASH.QC_SESSION_ID      = :B19
                  AND ASH.QC_SESSION_SERIAL# = :B18
                  AND ASH.QC_INSTANCE_ID     = :B17 ))
                  AND SAMPLE_TIME BETWEEN :B16 AND :B15
                  ) ASH0
                WHERE (ASH0.SAMPLE_DATE BETWEEN :B20 + 1/24/3600 AND :B22 - 1/24/3600
                OR (ASH0.SQL_ID          = :B9
                AND ASH0.SQL_EXEC_START  = :B8
                AND ASH0.SQL_EXEC_ID     = :B7 )
                OR (ASH0.DBOP_NAME       = :B6
                AND ASH0.DBOP_EXEC_ID    = :B5 ))
                AND (:B21               IS NULL
                OR ASH0.SQL_PLAN_LINE_ID = :B21 )
                AND (ASH0.IS_PX_SLAVE    = 0
                OR ASH0.SQL_ID          IS NOT NULL)
                ) ASH000
              ) ASH00
            WHERE ASH00.C1 = DUP.C1
            ) ASH1
          WHERE ASH1.BUCKET_NUM > 0
          AND ASH1.BUCKET_NUM  <= :B27
          GROUP BY USERENV('INSTANCE'),
            ASH1.GLOBAL_SAMPLE_ID,
            ASH1.BUCKET_NUM,
            ASH1.SESSION_ID,
            ASH1.PLAN_LINE_ID,
            ASH1.PLSQL_OBJECT_ID,
            ASH1.PLSQL_SUBPROGRAM_ID,
            ASH1.ACTIVITY_TYPE,
            ASH1.EVENT_NAME,
            ASH1.OTHER_SQL_ACTIVITY_TYPE,
            ASH1.PX_STEP_ID,
            ASH1.PX_STEP_ARG
          ) ASH2
        )))) GVTF
      WHERE GVTF.INST_ID BETWEEN :B11 AND :B10
      ) ASH
    WHERE ASH.GLOBAL_SAMPLE_ID IS NULL
    AND ASH.SESSION_ID          = MO.SID(+)
    AND ASH.INST_ID             = MO.INST_ID(+)
    ) AD0
  ),
  RESPONSE_TIME_DATA AS
  (SELECT ADH.BUCKET_NUM,
    ADH.SQL_ROWNUM,
    ADH.SQL,
    ADH.TOP_LEVEL_SQL_ID,
    ADH.DBOP_NAME,
    ADH.PX_ID,
    DECODE( ADH.PX_STEP_ID, NULL, NULL, 0, NULL, 1, 'PX Server(s) - Executing Parent DFO', 2, 'PX Server(s) - Executing Child DFO', 3, 'PX Server(s) - Sampling Child DFO', 4, 'PX Server(s) - Joining Group', 5, 'QC - Scheduling Child DFO', 6, 'QC - Scheduling Parent DFO', 7, 'QC - Initializing Objects', 8, 'QC - Flushing Objects', 9, 'QC - Allocating Slaves', 10, 'QC - Initializing Granules', 11, 'PX Server(s) - Parsing Cursor', 12, 'PX Server(s) - Executing Cursor', 13, 'PX Server(s) - Preparing Transaction', 14, 'PX Server(s) - Joining Transaction', 15, 'PX Server(s) - Load Commit', 16, 'PX Server(s) - Aborting Transaction', 17, 'QC - Executing Child DFO', 18, 'QC - Executing Parent DFO', 'PX Step - '
    || PX_STEP_ID) PX_STEP_ID,
    ADH.PX_STEP_ARG,
    ADH.PX_DFO_PAIR_ID,
    ADH.PX_DOP,
    ADH.PX_MIN_DOP,
    ADH.DFO_MOST_ACTIVE_IID,
    ADH.DFO_MOST_ACTIVE_SID,
    ADH.DFO_MOST_ACTIVE_COUNT,
    ADH.ACTIVITY_START,
    ADH.ACTIVITY_END,
    ADH.ACTIVITY_TYPE,
    ADH.OTHER_SQL_ACTIVITY_TYPE,
    ADH.EVENT_NAME,
    ADH.PLAN_LINE_ID,
    ADH.PLSQL_OBJECT_ID,
    ADH.PLSQL_SUBPROGRAM_ID,
    CASE
      WHEN PLSQL_ROWNUM        = 1
      AND ADH.PLSQL_OBJECT_ID IS NOT NULL
      THEN NVL(
        (SELECT P.OWNER
          || '.'
          || P.OBJECT_NAME
          || DECODE(P.PROCEDURE_NAME, NULL, '', '.'
          || P.PROCEDURE_NAME)
        FROM DBA_PROCEDURES P
        WHERE P.OBJECT_ID   = ADH.PLSQL_OBJECT_ID
        AND P.SUBPROGRAM_ID = ADH.PLSQL_SUBPROGRAM_ID
        ), 'Unavailable')
      ELSE NULL
    END PLSQL_NAME,
    ADH.ACTIVITY_COUNT,
    ADH.BUCKET_ACTIVE_SECONDS,
    ADH.BUCKET_IDLE_SECONDS,
    (
    CASE
      WHEN ADH.IS_MONITORED_SQL = 0
      THEN ADH.ACTIVE_SECONDS
      WHEN ADH.PX_DFO_PAIR_ID     IS NOT NULL
      AND ADH.DFO_PAIR_CPU_HEIGHT >= :B34
      THEN DECODE(ADH.ACTIVITY_TYPE, 'Cpu', (ADH.DFO_PAIR_ACTIVITY_HEIGHT / ADH.DFO_PAIR_CPU_HEIGHT) * ADH.DFO_PAIR_TOTAL_SECONDS, 0)
      WHEN ADH.PX_DFO_PAIR_ID IS NOT NULL
      AND ADH.PX_DOP           > :B34
      THEN (ADH.DFO_PAIR_TOTAL_SECONDS * DECODE(ADH.ACTIVITY_TYPE, 'Cpu', ADH.DFO_PAIR_ACTIVITY_HEIGHT, (ADH.DFO_PAIR_ACTIVITY_HEIGHT * (:B34 - ADH.DFO_PAIR_CPU_HEIGHT)) / (ADH.DFO_PAIR_TOTAL_HEIGHT_ADJ - ADH.DFO_PAIR_CPU_HEIGHT))) / :B34
      WHEN ADH.PX_DFO_PAIR_ID IS NOT NULL
      THEN (ADH.DFO_PAIR_TOTAL_SECONDS * ADH.DFO_PAIR_ACTIVITY_HEIGHT) / ADH.PX_DOP
      ELSE ADH.ACTIVE_SECONDS
    END) RESP_TIME,
    (
    CASE
      WHEN ADH.PX_DFO_PAIR_ID     IS NOT NULL
      AND ADH.DFO_PAIR_IDLE_HEIGHT > 0
      AND ADH.PX_DOP               > :B34
      THEN (ADH.DFO_PAIR_TOTAL_SECONDS * (ADH.DFO_PAIR_IDLE_HEIGHT * (:B34 - ADH.DFO_PAIR_CPU_HEIGHT)) / (ADH.DFO_PAIR_TOTAL_HEIGHT_ADJ - ADH.DFO_PAIR_CPU_HEIGHT)) / :B34
      WHEN ADH.PX_DFO_PAIR_ID     IS NOT NULL
      AND ADH.DFO_PAIR_IDLE_HEIGHT > 0
      THEN (ADH.DFO_PAIR_TOTAL_SECONDS * ADH.DFO_PAIR_IDLE_HEIGHT) / ADH.PX_DOP
      ELSE 0
    END) DFO_PAIR_IDLE_RESP_TIME,
    ADH.DFO_PAIR_ACTIVITY_HEIGHT,
    ADH.DFO_PAIR_CPU_HEIGHT,
    ADH.DFO_PAIR_IDLE_HEIGHT,
    ADH.DFO_PAIR_TOTAL_HEIGHT,
    ADH.DFO_PAIR_CPU_ACTIVITY,
    ADH.DFO_PAIR_TOTAL_SECONDS
  FROM
    (SELECT ADH_1.*,
      (ROW_NUMBER() OVER(PARTITION BY ADH_1.PLSQL_OBJECT_ID, ADH_1.PLSQL_SUBPROGRAM_ID ORDER BY ADH_1.BUCKET_NUM, ADH_1.ACTIVITY_TYPE, ADH_1.EVENT_NAME)) PLSQL_ROWNUM,
      (ROW_NUMBER() OVER(PARTITION BY ADH_1.SQL ORDER BY ADH_1.BUCKET_NUM, ADH_1.ACTIVITY_TYPE, ADH_1.EVENT_NAME)) SQL_ROWNUM,
      (
      CASE
        WHEN ADH_1.PX_DFO_PAIR_ID       IS NOT NULL
        AND (ADH_1.DFO_PAIR_TOTAL_HEIGHT < ADH_1.PX_DOP)
        AND (ADH_1.DFO_PAIR_CPU_HEIGHT   < :B34 )
        THEN ADH_1.PX_DOP - ADH_1.DFO_PAIR_TOTAL_HEIGHT
        ELSE 0
      END) DFO_PAIR_IDLE_HEIGHT,
      (
      CASE
        WHEN ADH_1.PX_DFO_PAIR_ID       IS NOT NULL
        AND (ADH_1.DFO_PAIR_TOTAL_HEIGHT < ADH_1.PX_DOP)
        AND (ADH_1.DFO_PAIR_CPU_HEIGHT   < :B34 )
        THEN ADH_1.PX_DOP
        ELSE ADH_1.DFO_PAIR_TOTAL_HEIGHT
      END) DFO_PAIR_TOTAL_HEIGHT_ADJ
    FROM
      (SELECT ADH_0.*,
        (
        CASE
          WHEN ADH_0.DFO_PAIR_TOTAL_SECONDS > 0
          THEN (ADH_0.DFO_PAIR_TOTAL_ACTIVITY * :B25 ) / ADH_0.DFO_PAIR_TOTAL_SECONDS
          ELSE 0
        END) DFO_PAIR_TOTAL_HEIGHT,
        (
        CASE
          WHEN ADH_0.DFO_PAIR_TOTAL_SECONDS > 0
          THEN (ADH_0.DFO_PAIR_CPU_ACTIVITY * :B25 ) / ADH_0.DFO_PAIR_TOTAL_SECONDS
          ELSE 0
        END) DFO_PAIR_CPU_HEIGHT,
        (
        CASE
          WHEN ADH_0.PX_DFO_PAIR_ID       IS NOT NULL
          AND ADH_0.DFO_PAIR_TOTAL_SECONDS > 0
          THEN (ADH_0.ACTIVITY_COUNT * :B25 ) / ADH_0.DFO_PAIR_TOTAL_SECONDS
          ELSE 0
        END) DFO_PAIR_ACTIVITY_HEIGHT
      FROM
        (SELECT AD3.*,
          (SUM(DECODE(AD3.PX_DFO_PAIR_ID, NULL, 0, AD3.ACTIVE_SECONDS)) OVER(PARTITION BY DECODE(AD3.PX_DFO_PAIR_ID, NULL, NULL, AD3.BUCKET_NUM), DECODE(AD3.PX_DFO_PAIR_ID, NULL, NULL, AD3.PX_STEP_ARG))) DFO_PAIR_TOTAL_SECONDS
        FROM
          (SELECT AD2.*,
            CASE
              WHEN AD2.IS_MONITORED_SQL = 0
              THEN SQL_BUCKET_DISTINCT_SAMPLES * :B25
              WHEN AD2.PX_ID IS NULL
              THEN AD2.ACTIVITY_COUNT * :B25
              WHEN AD2.BUCKET_PARALLEL_MON_ACTIVITY > 0
              THEN (AD2.ACTIVITY_COUNT * AD2.BUCKET_PARALLEL_MON_SECONDS) / AD2.BUCKET_PARALLEL_MON_ACTIVITY
              ELSE 0
            END ACTIVE_SECONDS,
            CASE
              WHEN AD2.BUCKET_INTERVAL > BUCKET_ACTIVE_SECONDS
              THEN AD2.BUCKET_INTERVAL - BUCKET_ACTIVE_SECONDS
              ELSE 0
            END BUCKET_IDLE_SECONDS
          FROM
            (SELECT AD1.*,
              (AD1.BUCKET_SERIAL_MON_ACTIVITY * :B25 ) BUCKET_SERIAL_MON_SECONDS,
              (AD1.BUCKET_TOTAL_MON_ACTIVITY  - AD1.BUCKET_SERIAL_MON_ACTIVITY) BUCKET_PARALLEL_MON_ACTIVITY,
              (AD1.BUCKET_ACTIVE_SECONDS      - (AD1.BUCKET_OTHER_ACTIVITY + AD1.BUCKET_SERIAL_MON_ACTIVITY) * :B25 ) BUCKET_PARALLEL_MON_SECONDS,
              (AD1.BUCKET_OTHER_ACTIVITY      * :B25 ) BUCKET_OTHER_SECONDS,
              DECODE(AD1.PX_DFO_PAIR_ID, NULL, NULL, SUM(AD1.ACTIVITY_COUNT) OVER(PARTITION BY DECODE(AD1.PX_DFO_PAIR_ID, NULL, NULL, AD1.BUCKET_NUM), AD1.PX_DFO_PAIR_ID)) DFO_PAIR_TOTAL_ACTIVITY,
              DECODE(AD1.PX_DFO_PAIR_ID, NULL, NULL, SUM(DECODE(AD1.ACTIVITY_TYPE, 'Cpu', AD1.ACTIVITY_COUNT, 0)) OVER(PARTITION BY DECODE(AD1.PX_DFO_PAIR_ID, NULL, NULL, AD1.BUCKET_NUM), AD1.PX_DFO_PAIR_ID)) DFO_PAIR_CPU_ACTIVITY
            FROM
              (SELECT AD01.*,
                NVL((SUM(DECODE(AD01.IS_MONITORED_SQL, 1, AD01.ACTIVITY_COUNT, NULL)) OVER(PARTITION BY AD01.BUCKET_NUM)), 0) BUCKET_TOTAL_MON_ACTIVITY,
                (NVL(SUM(
                CASE
                  WHEN AD01.IS_MONITORED_SQL = 1
                  AND AD01.PX_ID            IS NULL
                  THEN AD01.ACTIVITY_COUNT
                  ELSE NULL
                END) OVER(PARTITION BY AD01.BUCKET_NUM), 0)) BUCKET_SERIAL_MON_ACTIVITY,
                (NVL((SUM(DECODE(AD01.IS_MONITORED_SQL, 0, AD01.SQL_BUCKET_DISTINCT_SAMPLES, NULL)) OVER(PARTITION BY AD01.BUCKET_NUM)), 0)) BUCKET_OTHER_ACTIVITY,
                (NVL(AD01.BUCKET_DISTINCT_SAMPLES, 0) * :B25 ) BUCKET_ACTIVE_SECONDS,
                DECODE(AD01.BUCKET_NUM, :B27 , MOD(:B32 , :B26 ), :B26 ) BUCKET_INTERVAL
              FROM
                (SELECT AD0.ACTIVITY_BUCKET_NUM BUCKET_NUM,
                  AD0.PX_ID,
                  AD0.ACTIVITY_TYPE,
                  AD0.OTHER_SQL_ACTIVITY_TYPE,
                  AD0.EVENT_NAME,
                  AD0.PLAN_LINE_ID,
                  AD0.PX_STEP_ID,
                  AD0.PX_STEP_ARG,
                  AD0.PLSQL_OBJECT_ID,
                  AD0.PLSQL_SUBPROGRAM_ID,
                  SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT,
                  MIN(AD0.ACTIVITY_START) ACTIVITY_START,
                  MAX(AD0.ACTIVITY_END) ACTIVITY_END,
                  MAX(AD0.IS_MONITORED_SQL) IS_MONITORED_SQL,
                  MAX(AD0.SQL) SQL,
                  MAX(AD0.TOP_LEVEL_SQL_ID) TOP_LEVEL_SQL_ID,
                  MAX(AD0.DBOP_NAME) DBOP_NAME,
                  MAX(DECODE(AD0.DFO_MOST_ACTIVE_COUNT, NULL, NULL, AD0.DFO_MOST_ACTIVE_IID)) DFO_MOST_ACTIVE_IID,
                  MAX(DECODE(AD0.DFO_MOST_ACTIVE_COUNT, NULL, NULL, AD0.DFO_MOST_ACTIVE_SID)) DFO_MOST_ACTIVE_SID,
                  SUM(AD0.DFO_MOST_ACTIVE_COUNT) DFO_MOST_ACTIVE_COUNT,
                  MAX(PX_DFO_PAIR_TYPE) PX_DFO_PAIR_TYPE,
                  MAX(PX_DFO_PAIR_ID) PX_DFO_PAIR_ID,
                  MAX(AD0.PX_DOP) PX_DOP,
                  MIN(AD0.PX_MIN_DOP) PX_MIN_DOP,
                  MAX(AD0.BUCKET_DISTINCT_SAMPLES) BUCKET_DISTINCT_SAMPLES,
                  MAX(AD0.SQL_BUCKET_DISTINCT_SAMPLES) SQL_BUCKET_DISTINCT_SAMPLES
                FROM
                  (SELECT AD00.*,
                    (
                    CASE
                      WHEN AD00.IS_MONITORED_SQL = 1
                      AND (AD00.SESSION_ID      != :B19
                      OR AD00.INST_ID           != :B17 )
                      THEN AD00.PX_SERVER_GROUP
                    END) PX_ID
                  FROM ASH_DATA AD00
                  WHERE :B33 = 1
                  ) AD0
                GROUP BY AD0.ACTIVITY_BUCKET_NUM,
                  AD0.PX_ID,
                  AD0.ACTIVITY_TYPE,
                  AD0.EVENT_NAME,
                  AD0.OTHER_SQL_ACTIVITY_TYPE,
                  AD0.PLAN_LINE_ID,
                  AD0.PLSQL_OBJECT_ID,
                  AD0.PLSQL_SUBPROGRAM_ID,
                  AD0.PX_STEP_ID,
                  AD0.PX_STEP_ARG
                ) AD01
              ) AD1
            ) AD2
          ) AD3
        ) ADH_0
      ) ADH_1
    ) ADH
  )
SELECT
  /*+ no_monitor no_xml_query_rewrite */
  XMLELEMENT( "sql_monitor_report", XMLATTRIBUTES(:B59 AS "version", TO_CHAR(:B58 , :B12 ) AS "sysdate"), XMLELEMENT( "report_parameters", NULL,
  CASE
    WHEN :B57 IS NOT NULL
    THEN XMLFOREST( :B57 AS "dbop_name", :B56 AS "dbop_exec_id")
    ELSE XMLFOREST( :B55 AS "sql_id", :B54 AS "sql_exec_id")
  END, XMLFOREST( :B53   AS "session_id", :B52 AS "session_serial", TO_CHAR(:B51 , :B12 ) AS "sql_exec_start", :B27 AS "bucket_count", TO_CHAR(:B50 , :B12 ) AS "interval_start", TO_CHAR(:B22 , :B12 ) AS "interval_end", DECODE(:B49 , 'Y', :B48 , NULL) AS "auto_refresh", :B47 AS "base_path"),
  CASE
    WHEN :B23    = 'Y'
    AND :B46    IS NOT NULL
    AND NOT (:B4 = 1
    AND :B3     IS NULL
    AND :B2     IS NULL
    AND :B1     IS NULL)
    THEN XMLELEMENT( "parallel_filter", NULL, XMLFOREST( DECODE(:B4 , 1, 'yes', 'no') AS "qc", :B3 AS "server_group", :B2 AS "server_set", :B1 AS "server_number"))
    ELSE NULL
  END),
  CASE
    WHEN :B14 = 1
    THEN XMLELEMENT( "derived_parameters_testing", NULL, XMLFOREST(:B11 AS "instance_id_low", :B10 AS "instance_id_high", :B26 AS "bucket_interval_sec", :B32 AS "interval_second", :B27 AS "bucket_calc_count", :B45 AS "bucket_calc_max_count", :B13 AS "sel_sqltext"))
    ELSE NULL
  END,
  (SELECT XMLCONCAT(
    CASE
      WHEN :B46 IS NULL
      AND :B60  IS NULL
      THEN XMLELEMENT( "target", XMLATTRIBUTES(:B17 AS "instance_id", :B19 AS "session_id", :B18 AS "session_serial", NVL2(:B6 , NULL, :B9 ) AS "sql_id", NVL2(:B6 , NULL, TO_CHAR(:B8 , :B12 )) AS "sql_exec_start", NVL2(:B6 , NULL, :B7 ) AS "sql_exec_id", NVL2(:B6 , :B6 , NULL) AS "dbop_name", NVL2(:B6 , :B5 , NULL) AS "dbop_exec_id", NVL2(:B6 , TO_CHAR(:B8 , :B12 ), NULL) AS "dbop_exec_start", NVL2(:B6 , NULL, MAX_PLAN_HASH_VALUE) AS "sql_plan_hash", MAGG.DB_UNIQUE_NAME AS "db_unique_name", MAGG.PLATFORM_NAME AS "db_platform_name", MAGG.HOST_NAME AS "report_host_name"), NVL2(SUM_SERVERS_REQUESTED, XMLELEMENT( "servers_requested", NULL, SUM_SERVERS_REQUESTED), NULL), NVL2(SUM_SERVERS_ALLOCATED, XMLELEMENT( "servers_allocated", NULL, SUM_SERVERS_ALLOCATED), NULL), NVL2(MAX_USERID, XMLELEMENT( "user_id", NULL, MAX_USERID), NULL), NVL2(MAX_USERNAME, XMLELEMENT( "user", NULL, MAX_USERNAME), NULL), NVL2(MAX_CON_ID, XMLELEMENT( "con_id", NULL, MAX_CON_ID), NULL), NVL2(MAX_CON_NAME,
        XMLELEMENT( "con_name", NULL, MAX_CON_NAME), NULL), NVL2(MAX_PROGRAM, XMLELEMENT( "program", NULL, MAX_PROGRAM), NULL), NVL2(MAX_MODULE, XMLELEMENT( "module", NULL, MAX_MODULE), NULL), NVL2(MAX_ACTION, XMLELEMENT( "action", NULL, MAX_ACTION), NULL), NVL2(MAX_SERVICE_NAME, XMLELEMENT( "service", NULL, MAX_SERVICE_NAME), NULL), NVL2(MAX_CLIENT_ID, XMLELEMENT( "client_id", NULL, MAX_CLIENT_ID), NULL), NVL2(MAX_CLIENT_INFO, XMLELEMENT( "client_info", NULL, MAX_CLIENT_INFO), NULL), NVL2(MAX_PL_ENTRY_OID, XMLELEMENT( "plsql_entry_object_id", NULL, MAX_PL_ENTRY_OID), NULL), NVL2(MAX_PL_ENTRY_PROGID, XMLELEMENT( "plsql_entry_subprogram_id", NULL, MAX_PL_ENTRY_PROGID), NULL), NVL2(MAX_PL_ENTRY_NAME, XMLELEMENT( "plsql_entry_name", NULL, MAX_PL_ENTRY_NAME), NULL), NVL2(MAX_PL_OID, XMLELEMENT( "plsql_object_id", NULL, MAX_PL_OID), NULL), NVL2(MAX_PL_PROGID, XMLELEMENT( "plsql_subprogram_id", NULL, MAX_PL_PROGID), NULL), NVL2(MAX_PL_NAME, XMLELEMENT( "plsql_name", NULL, MAX_PL_NAME),
        NULL),
        CASE
          WHEN (:B13 = 0
          OR :B6    IS NOT NULL)
          THEN NULL
          ELSE XMLELEMENT( "sql_fulltext", XMLATTRIBUTES(NVL2(SQL_VTEXT, 'Y', IS_FULL_TEXT) AS "is_full"), NVL2(SQL_VTEXT, SQL_VTEXT, SQLMON_TEXT))
        END, XMLELEMENT( "status", NULL, MAX_STATUS), XMLELEMENT( "refresh_count", NULL, SUM_REFRESH_COUNT), XMLELEMENT( "first_refresh_time", NULL, TO_CHAR(MIN_FIRST_REFRESH_TIME, :B12 )), XMLELEMENT( "last_refresh_time", NULL, TO_CHAR(:B58 , :B12 )), XMLELEMENT( "duration", NULL, GREATEST(:B63 , LEAST(MAX_ELAPSED_TIME/1000000, 1), CEIL(MAX_QUEUING_TIME/1000000))), DECODE(MAX_RM_INFO, '00/00/0000 00:00:00', NULL, XMLTYPE(SUBSTR(MAX_RM_INFO, 20))), NVL(
        (SELECT XMLFOREST( XMLAGG( XMLELEMENT( "param", XMLATTRIBUTES(E.NAME AS "name"), DECODE(:B14 , 1, 'XXXX', E.VALUE))
        ORDER BY E.NAME) AS "optimizer_env") SQL_ENV
        FROM GV$SQL_OPTIMIZER_ENV E
        WHERE E.INST_ID                           = :B17
        AND E.SQL_ID                              = :B9
        AND E.CHILD_ADDRESS                       = HEXTORAW(:B64 )
        AND (DECODE(:B14 , 1, 'YES', E.ISDEFAULT) = 'NO'
        OR E.ID                                  IN (2, 12, 24, 35, 36, 37, 246, 256, 257, 274, 275, 289, 290))
        ),
        (SELECT XMLELEMENT( "optimizer_env", XMLATTRIBUTES('sys' AS "type"), XMLAGG( XMLELEMENT( "param", XMLATTRIBUTES(E.NAME AS "name"), DECODE(:B14 , 1, 'XXXX', E.VALUE))
        ORDER BY E.NAME)) SYS_ENV
        FROM V$SYS_OPTIMIZER_ENV E
        WHERE (DECODE(:B14 , 1, 'YES', E.ISDEFAULT) = 'NO'
        OR E.ID                                    IN (2, 12, 24, 35, 36, 37, 246, 256, 257, 274, 275, 289, 290))
        )) )
    END, XMLELEMENT( "stats", XMLATTRIBUTES('monitor' AS "type"), DECODE(NVL(SUM_ELAPSED_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), SUM_ELAPSED_TIME)), DECODE(NVL(MAX_QUEUING_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MAX_QUEUING_TIME)), DECODE(NVL(SUM_CPU_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), SUM_CPU_TIME)), DECODE(NVL(SUM_USER_IO_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_io_wait_time' AS "name"), SUM_USER_IO_WAIT_TIME)), DECODE(NVL(SUM_APPLICATION_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), SUM_APPLICATION_WAIT_TIME)), DECODE(NVL(SUM_CONCURRENCY_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time' AS "name"), SUM_CONCURRENCY_WAIT_TIME)), DECODE(NVL(SUM_CLUSTER_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), SUM_CLUSTER_WAIT_TIME)),
    DECODE(NVL(SUM_PLSQL_EXEC_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time' AS "name"), SUM_PLSQL_EXEC_TIME)), DECODE(NVL(SUM_JAVA_EXEC_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), SUM_JAVA_EXEC_TIME)), DECODE(NVL(SUM_OTHER_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('other_wait_time' AS "name"), SUM_OTHER_WAIT_TIME)), DECODE(NVL(SUM_FETCHES, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS "name"), SUM_FETCHES)), DECODE(NVL(SUM_BUFFER_GETS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), SUM_BUFFER_GETS)), DECODE(NVL(SUM_READ_REQS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('disk_reads' AS "name"), SUM_READ_REQS)), DECODE(NVL(SUM_WRITE_REQS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('direct_writes' AS "name"), SUM_WRITE_REQS)), DECODE(NVL(SUM_READ_REQS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), SUM_READ_REQS)), DECODE(NVL(
    SUM_READ_BYTES, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes'                      AS "name"), SUM_READ_BYTES)), DECODE(NVL(SUM_WRITE_REQS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), SUM_WRITE_REQS)), DECODE(NVL(SUM_WRITE_BYTES, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), SUM_WRITE_BYTES)),
    CASE
      WHEN SUM_IO_INTER_BYTES IS NULL
      OR SUM_IO_BYTES          = 0
      OR SUM_IO_INTER_BYTES    = SUM_IO_BYTES
      THEN NULL
      ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency'               AS "name"), ROUND(SUM_IO_BYTES / DECODE(SUM_IO_INTER_BYTES, 0, 1, SUM_IO_INTER_BYTES), 2))
    END), NVL2(MAX_ERROR_NUMBER, XMLELEMENT( "error", XMLATTRIBUTES(MAX_ERROR_NUMBER AS "number", MAX_ERROR_FACILITY AS "facility"), MAX_ERROR_MESSAGE), NULL),
    CASE
      WHEN :B62                 = 1
      AND MAGG.QC_HAS_BINDS_XML = 'Y'
      THEN
        (SELECT XMLTYPE(BINDS_XML)
        FROM GV$SQL_MONITOR MON
        WHERE MON.INST_ID      = :B17
        AND MON.KEY            = MAGG.MAX_KEY
        AND MON.SID            = MAGG.MAX_SESSION_ID
        AND MON.SQL_ID         = :B9
        AND MON.SQL_EXEC_START = :B8
        AND MON.SQL_EXEC_ID    = :B7
        AND ROWNUM             = 1
        )
      ELSE NULL
    END,
    CASE
      WHEN :B61                 = 1
      AND MAGG.QC_HAS_OTHER_XML = 'Y'
      THEN
        (SELECT XMLTYPE(OTHER_XML)
        FROM GV$SQL_MONITOR MON
        WHERE MON.INST_ID      = MAGG.MAX_INST_ID
        AND MON.KEY            = MAGG.MAX_KEY
        AND MON.SID            = MAGG.MAX_SESSION_ID
        AND MON.SQL_ID         = :B9
        AND MON.SQL_EXEC_START = :B8
        AND MON.SQL_EXEC_ID    = :B7
        AND ROWNUM             = 1
        )
      ELSE NULL
    END)
  FROM
    (SELECT V.*,
      CASE
        WHEN :B13        = 2
        AND IS_FULL_TEXT = 'N'
        AND :B46        IS NULL
        AND :B60        IS NULL
        THEN
          (SELECT SQL_FULLTEXT
          FROM GV$SQL SQ
          WHERE SQ.INST_ID BETWEEN :B11 AND :B10
          AND SQ.SQL_ID = :B9
          AND ROWNUM    = 1
          )
        ELSE NULL
      END SQL_VTEXT
    FROM MONITOR_AGG V
    ) MAGG
  ),
  CASE
    WHEN :B44 = 1
    THEN
      (SELECT
        CASE
          WHEN AT.ACTIVITY_COUNT > 0
          THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( :B41 AS "ash_missing_seconds", TO_CHAR(AT.ACTIVITY_START, :B12 ) AS "first_sample_time", TO_CHAR(AT.ACTIVITY_END, :B12 ) AS "last_sample_time", ROUND((AT.ACTIVITY_END - AT.ACTIVITY_START) * 3600 * 24) + 1 AS "duration", AT.ACTIVITY_COUNT AS "count", AT.WAIT_COUNT AS "wait_count", AT.CPU_COUNT AS "cpu_count", DECODE(AT.OTHER_SQL_COUNT, 0, NULL, AT.OTHER_SQL_COUNT) AS "other_sql_count", :B40 AS "cpu_cores", :B39 AS "hyperthread"), AT.ACTIVITY_TOTAL, AH.GLOB_ACTIVITY_HISTO)
          WHEN :B41 IS NOT NULL
          THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( DECODE( :B41 , -1, 'all', TO_CHAR( :B41 )) AS "ash_missing_seconds"))
          ELSE NULL
        END
      FROM
        (SELECT MIN(AD1.ACTIVITY_START) ACTIVITY_START,
          MAX(AD1.ACTIVITY_END) ACTIVITY_END,
          SUM(AD1.ACTIVITY_COUNT) ACTIVITY_COUNT,
          SUM(AD1.WAIT_COUNT) WAIT_COUNT,
          SUM(AD1.CPU_COUNT) CPU_COUNT,
          SUM(AD1.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
          SUBSTR(MAX(LPAD(AD1.ACTIVITY_COUNT,10)
          || AD1.ACTIVITY_TYPE), 11) MOST_ACTIVE,
          XMLAGG( XMLELEMENT( "activity", XMLATTRIBUTES( AD1.ACTIVITY_TYPE AS "class", AD1.EVENT_NAME AS "event"), AD1.ACTIVITY_COUNT)
        ORDER BY AD1.ACTIVITY_TYPE, AD1.EVENT_NAME) ACTIVITY_TOTAL
        FROM
          (SELECT AD0.ACTIVITY_TYPE,
            AD0.EVENT_NAME,
            MIN(AD0.ACTIVITY_START) ACTIVITY_START,
            MAX(AD0.ACTIVITY_END) ACTIVITY_END,
            SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT,
            SUM(AD0.WAIT_COUNT) WAIT_COUNT,
            SUM(AD0.CPU_COUNT) CPU_COUNT,
            SUM(AD0.OTHER_SQL_COUNT) OTHER_SQL_COUNT
          FROM ASH_DATA AD0
          GROUP BY AD0.ACTIVITY_TYPE,
            AD0.EVENT_NAME
          ) AD1
        ) AT,
        (SELECT
          CASE
            WHEN :B30 = 1
            AND :B27  > 1
            THEN XMLELEMENT( "activity_histogram", XMLATTRIBUTES( :B26 AS "bucket_interval", :B27 AS "bucket_count", TO_CHAR( :B20 , :B12 ) AS "start_time", TO_CHAR( :B22 , :B12 ) AS "end_time", ROUND(( :B22 - :B20 ) *3600*24) + 1 AS "duration"), XMLAGG( XMLELEMENT( "bucket", XMLATTRIBUTES( AD2.BUCKET_NUM AS "number"), ACTIVITY_BUCKET)
            ORDER BY AD2.BUCKET_NUM))
            ELSE NULL
          END GLOB_ACTIVITY_HISTO
        FROM
          (SELECT AD1.BUCKET_NUM,
            SUM(ACTIVITY_COUNT) ACTIVITY_COUNT,
            SUM(WAIT_COUNT) WAIT_COUNT,
            SUM(CPU_COUNT) CPU_COUNT,
            SUM(OTHER_SQL_COUNT) OTHER_SQL_COUNT,
            MIN(AD1.ACTIVITY_START) ACTIVITY_START,
            MAX(AD1.ACTIVITY_END) ACTIVITY_END,
            MIN(AD1.BUCKET_ACTIVITY_START) BUCKET_ACTIVITY_START,
            MAX(AD1.BUCKET_ACTIVITY_END) BUCKET_ACTIVITY_END,
            SUBSTR(MAX(LPAD(AD1.ACTIVITY_COUNT,10)
            || AD1.ACTIVITY_TYPE), 11) MOST_ACTIVE,
            XMLAGG( XMLELEMENT( "activity", XMLATTRIBUTES( AD1.ACTIVITY_TYPE AS "class", AD1.EVENT_NAME AS "event"), AD1.ACTIVITY_COUNT)
          ORDER BY AD1.ACTIVITY_TYPE, AD1.EVENT_NAME) ACTIVITY_BUCKET
          FROM
            (SELECT AD0.ACTIVITY_BUCKET_NUM BUCKET_NUM,
              AD0.ACTIVITY_TYPE,
              AD0.EVENT_NAME,
              MIN(AD0.ACTIVITY_START) ACTIVITY_START,
              MAX(AD0.ACTIVITY_END) ACTIVITY_END,
              SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT,
              SUM(AD0.WAIT_COUNT) WAIT_COUNT,
              SUM(AD0.CPU_COUNT) CPU_COUNT,
              SUM(AD0.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
              MIN(AD0.BUCKET_ACTIVITY_START) BUCKET_ACTIVITY_START,
              MAX(AD0.BUCKET_ACTIVITY_END) BUCKET_ACTIVITY_END
            FROM ASH_DATA AD0
            GROUP BY AD0.ACTIVITY_BUCKET_NUM,
              AD0.ACTIVITY_TYPE,
              AD0.EVENT_NAME
            ) AD1
          GROUP BY AD1.BUCKET_NUM
          ) AD2
        ) AH
      )
    ELSE NULL
  END,
  CASE
    WHEN :B33 = 1
    THEN
      (SELECT
        CASE
          WHEN AH.ACTIVITY_COUNT > 0
          THEN XMLELEMENT( "activity_detail", XMLATTRIBUTES( TO_CHAR( :B20 , :B12 ) AS "start_time", TO_CHAR( :B22 , :B12 ) AS "end_time", :B41 AS "ash_missing_seconds", TO_CHAR(AH.ACTIVITY_START, :B12 ) AS "first_sample_time", TO_CHAR(AH.ACTIVITY_END, :B12 ) AS "last_sample_time", ROUND((AH.ACTIVITY_END - AH.ACTIVITY_START) * 3600 * 24) + 1 AS "duration", :B25 AS "sample_interval", :B26 AS "bucket_interval", :B27 AS "bucket_count", ROUND((:B22 - :B20 ) *3600*24) + 1 AS "bucket_duration", :B40 AS "cpu_cores", :B34 AS "total_cpu_cores", :B39 AS "hyperthread"), AH.GLOB_ACTIVITY_HISTO)
          WHEN :B41 IS NOT NULL
          THEN XMLELEMENT( "activity_detail", XMLATTRIBUTES( DECODE( :B41 , -1, 'all', TO_CHAR( :B41 )) AS "ash_missing_seconds"))
          ELSE NULL
        END
      FROM
        (SELECT MIN(AD2.ACTIVITY_START) ACTIVITY_START,
          MAX(AD2.ACTIVITY_END) ACTIVITY_END,
          SUM(AD2.ACTIVITY_COUNT) ACTIVITY_COUNT,
          XMLAGG( XMLELEMENT( "bucket", XMLATTRIBUTES( AD2.BUCKET_NUM AS "number"), ACTIVITY_BUCKET_XML)
        ORDER BY AD2.BUCKET_NUM) GLOB_ACTIVITY_HISTO
        FROM
          (SELECT AD1.BUCKET_NUM,
            MIN(AD1.ACTIVITY_START) ACTIVITY_START,
            MAX(AD1.ACTIVITY_END) ACTIVITY_END,
            SUM(AD1.ACTIVITY_COUNT) ACTIVITY_COUNT,
            MAX(AD1.BUCKET_IDLE_SECONDS) BUCKET_IDLE_SECONDS,
            XMLAGG( XMLCONCAT(
            CASE
              WHEN AD1.DFO_PAIR_IDLE_RESP_TIME != 0
              AND DFO_PAIR_ROWNUM               = 1
              THEN XMLELEMENT( "activity", XMLATTRIBUTES( 'Parallel Skew' AS "class", AD1.PX_STEP_ARG AS "line", AD1.PX_ID AS "px", ROUND(AD1.DFO_PAIR_IDLE_RESP_TIME, 2) AS "rt"), 0)
              ELSE NULL
            END, XMLELEMENT( "activity", XMLATTRIBUTES( NVL(AD1.OTHER_SQL, AD1.RPI) AS "sql", AD1.NON_SQL AS "non_sql", AD1.CLASS AS "class", AD1.OTHER_SQL_CLASS AS "other_sql_class", AD1.EVENT AS "event", AD1.PLAN_LINE_ID AS "line", NVL2(AD1.PLSQL_OBJECT_ID, AD1.PLSQL_OBJECT_ID
            ||'.'
            || AD1.PLSQL_SUBPROGRAM_ID, NULL) AS "plsql_id", AD1.PLSQL_NAME AS "plsql_name",
            CASE
              WHEN AD1.SQL_ROWNUM = 1
              THEN AD1.TOP_LEVEL_SQL_ID
            END AS "top_sql_id",
            CASE
              WHEN AD1.DBOP_NAME IS NOT NULL
              THEN AD1.DBOP_NAME
            END AS "dbop_name",
            CASE
              WHEN AD1.DFO_MOST_ACTIVE_IID IS NOT NULL
              AND :B65                      = 'Y'
              THEN AD1.DFO_MOST_ACTIVE_IID
            END AS "skew_iid", DECODE(AD1.DFO_MOST_ACTIVE_COUNT, NULL,NULL, AD1.DFO_MOST_ACTIVE_SID) AS "skew_sid", AD1.DFO_MOST_ACTIVE_COUNT AS "skew_count", DECODE(AD1.PX_DOP, :B28 , NULL, AD1.PX_DOP) AS "dop", DECODE(AD1.PX_DOP, AD1.PX_MIN_DOP, NULL, AD1.PX_MIN_DOP) AS "min_dop", AD1.PX_ID AS "px", AD1.PX_STEP_ID AS "step", AD1.PX_STEP_ARG AS "arg", DECODE(AD1.ACTIVITY_COUNT, AD1.RESP_TIME, NULL, ROUND(AD1.RESP_TIME, 2)) AS "rt"), AD1.ACTIVITY_COUNT))
          ORDER BY AD1.PX_STEP_ID, AD1.PX_STEP_ARG, AD1.DFO_PAIR_ROWNUM) ACTIVITY_BUCKET_XML
          FROM
            (SELECT AD01.*,
              CASE
                WHEN AD01.ACTIVITY_TYPE != 'Other SQL Execution'
                AND AD01.ACTIVITY_TYPE  != 'Non SQL'
                THEN AD01.ACTIVITY_TYPE
              END CLASS,
              CASE
                WHEN (AD01.ACTIVITY_TYPE = 'Other SQL Execution'
                OR AD01.ACTIVITY_TYPE    = 'Non SQL')
                THEN AD01.OTHER_SQL_ACTIVITY_TYPE
              END OTHER_SQL_CLASS,
              CASE
                WHEN AD01.ACTIVITY_TYPE != 'Other SQL Execution'
                AND AD01.ACTIVITY_TYPE  != 'Non SQL'
                THEN AD01.EVENT_NAME
              END EVENT,
              CASE
                WHEN AD01.SQL IN ('this', 'anonymous')
                THEN NULL
                ELSE AD01.SQL
              END RPI,
              DECODE(AD01.ACTIVITY_TYPE, 'Other SQL Execution', SUBSTR(AD01.EVENT_NAME, 9), NULL) OTHER_SQL,
              DECODE(AD01.ACTIVITY_TYPE, 'Non SQL', AD01.EVENT_NAME, NULL) NON_SQL,
              ROW_NUMBER() OVER(PARTITION BY AD01.BUCKET_NUM, AD01.PX_DFO_PAIR_ID ORDER BY AD01.ACTIVITY_TYPE, AD01.EVENT_NAME, AD01.PLAN_LINE_ID) DFO_PAIR_ROWNUM
            FROM RESPONSE_TIME_DATA AD01
            ) AD1
          GROUP BY AD1.BUCKET_NUM
          ) AD2
        ) AH
      )
    ELSE NULL
  END,
  CASE
    WHEN :B23 = 'Y'
    THEN
      (SELECT XMLELEMENT( "parallel_info", XMLATTRIBUTES( :B17 AS "qc_instance_id", MAX_PX_QCSID AS "qc_session_id", MAX_PX_IS_CROSS_INSTANCE AS "is_cross_instance", MAX_PX_DOP AS "dop", MAX_PX_DOP_INSTANCES AS "max_dop_instances", DIST_INST_COUNT AS "inst_count", DIST_PX_GROUP_COUNT AS "server_group_count", DIST_PX_SET_COUNT AS "server_set_count"),
        CASE
          WHEN :B67 = 1
          THEN PX_SESSIONS
          ELSE NULL
        END,
        CASE
          WHEN :B65 = 'Y'
          THEN DECODE(:B66 , 1, PX_INSTANCES, NULL)
          ELSE NULL
        END)
      FROM
        (SELECT MAX_PX_QCSID,
          MAX_PX_DOP,
          MAX_PX_DOP_INSTANCES,
          MAX_PX_IS_CROSS_INSTANCE,
          SUM_SERVERS_REQUESTED,
          SUM_SERVERS_ALLOCATED,
          DIST_INST_COUNT,
          DIST_PX_GROUP_COUNT,
          DIST_PX_SET_COUNT,
          (SELECT XMLELEMENT( "sessions", XMLATTRIBUTES(MAX(PX_SESSION.ACTIVITY_COUNT) AS "max_activity_count", MAX(PX_SESSION.CPU_COUNT) AS "max_cpu_count", MAX(PX_SESSION.WAIT_COUNT) AS "max_wait_count", MAX(PX_SESSION.OTHER_SQL_COUNT) AS "max_other_sql_count", MAX(PX_SESSION.MAX_IO_REQS) AS "max_io_reqs", MAX(PX_SESSION.MAX_IO_BYTES) AS "max_io_bytes", MAX(PX_SESSION.MAX_BUFFER_GETS) AS "max_buffer_gets", MAX(PX_SESSION.MAX_ELAPSED_TIME) AS "max_elapsed_time"), XMLAGG(PX_SESSION.PX_SESSION_XML
          ORDER BY PX_SERVER_GROUP NULLS FIRST, PX_SERVER_SET, PX_SERVER#))
          FROM
            (SELECT PX_SERVER_GROUP,
              PX_SERVER_SET,
              PX_SERVER#,
              MAX(PI.MAX_ELAPSED_TIME) MAX_ELAPSED_TIME,
              MAX(PI.MAX_IO_REQS) MAX_IO_REQS,
              MAX(PI.MAX_IO_BYTES) MAX_IO_BYTES,
              MAX(PI.MAX_BUFFER_GETS) MAX_BUFFER_GETS,
              SUM(PI.ACTIVITY_COUNT) ACTIVITY_COUNT,
              SUM(PI.WAIT_COUNT) WAIT_COUNT,
              SUM(PI.CPU_COUNT) CPU_COUNT,
              SUM(PI.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
              XMLELEMENT( "session", XMLATTRIBUTES( INST_ID AS "inst_id", PROCESS_NAME AS "process_name", SID AS "session_id", SESSION_SERIAL# AS "session_serial", PX_SERVER_GROUP AS "server_group", PX_SERVER_SET AS "server_set", PX_SERVER# AS "server_num"), XMLELEMENT( "stats", XMLATTRIBUTES( 'monitor' AS "type"), NVL2(MAX(ELAPSED_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), MAX(ELAPSED_TIME)), NULL), NVL2(MAX(QUEUING_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MAX(QUEUING_TIME)), NULL), NVL2(MAX(CPU_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), MAX(CPU_TIME)), NULL), NVL2(MAX(USER_IO_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('user_io_wait_time' AS "name"), MAX(USER_IO_WAIT_TIME)), NULL), NVL2(MAX(APPLICATION_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), MAX(APPLICATION_WAIT_TIME)), NULL), NVL2(MAX(CONCURRENCY_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time'
                                                            AS "name"), MAX(CONCURRENCY_WAIT_TIME)), NULL), NVL2(MAX(CLUSTER_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), MAX(CLUSTER_WAIT_TIME)), NULL), NVL2(MAX(PLSQL_EXEC_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time' AS "name"), MAX(PLSQL_EXEC_TIME)), NULL), NVL2(MAX(JAVA_EXEC_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), MAX(JAVA_EXEC_TIME)), NULL), NVL2(MAX(OTHER_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES( 'other_wait_time' AS "name"), MAX(OTHER_WAIT_TIME)), NULL), NVL2(MAX(FETCHES), XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS "name"), MAX(FETCHES)), NULL), NVL2(MAX(BUFFER_GETS), XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), MAX(BUFFER_GETS)), NULL), NVL2(MAX(READ_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('disk_reads' AS "name"), MAX(READ_REQS)), NULL), NVL2(MAX(WRITE_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('direct_writes' AS "name"), MAX(WRITE_REQS)), NULL), NVL2(MAX(READ_REQS),
              XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), MAX(READ_REQS)), NULL), NVL2(MAX(READ_BYTES), XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), MAX(READ_BYTES)), NULL), NVL2(MAX(WRITE_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), MAX(WRITE_REQS)), NULL), NVL2(MAX(WRITE_BYTES), XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), MAX(WRITE_BYTES)), NULL),
              CASE
                WHEN MAX(IO_INTER_BYTES) IS NULL
                OR NVL(MAX(IO_BYTES), 0)  = 0
                OR MAX(IO_INTER_BYTES)    = MAX(IO_BYTES)
                THEN NULL
                ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(MAX(IO_BYTES) / DECODE(MAX(IO_INTER_BYTES), 0, 1, MAX(IO_INTER_BYTES)), 2))
              END),
              CASE
                WHEN SUM(PI.ACTIVITY_COUNT) > 0
                AND :B33                    = 1
                THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( TO_CHAR(MIN(PI.ACTIVITY_START), :B12 ) AS "first_sample_time", TO_CHAR(MAX(PI.ACTIVITY_END), :B12 ) AS "last_sample_time", ROUND((MAX(PI.ACTIVITY_END) - MIN(PI.ACTIVITY_START)) * 3600 * 24) + 1 AS "duration", SUM(PI.ACTIVITY_COUNT) AS "count", SUM(PI.CPU_COUNT) AS "cpu_count", SUM(PI.WAIT_COUNT) AS "wait_count", SUM(PI.OTHER_SQL_COUNT)AS "other_sql_count", :B40 AS "cpu_cores", :B39 AS "hyperthread"), XMLAGG( NVL2(ACTIVITY_TYPE, XMLELEMENT( "activity", XMLATTRIBUTES( PI.ACTIVITY_TYPE AS "class", PI.EVENT_NAME AS "event"), ACTIVITY_COUNT), NULL)
                ORDER BY PI.ACTIVITY_TYPE, PI.EVENT_NAME))
                ELSE NULL
              END,
              CASE
                WHEN :B61            = 1
                AND PI.HAS_OTHER_XML = 'Y'
                THEN
                  (SELECT XMLTYPE(OTHER_XML)
                  FROM GV$SQL_MONITOR MON
                  WHERE MON.INST_ID      = PI.INST_ID
                  AND MON.KEY            = PI.KEY
                  AND MON.SID            = PI.SID
                  AND MON.SQL_ID         = :B9
                  AND MON.SQL_EXEC_START = :B8
                  AND MON.SQL_EXEC_ID    = :B7
                  AND ROWNUM             = 1
                  )
                ELSE NULL
              END) PX_SESSION_XML
            FROM
              (SELECT MO.HAS_OTHER_XML,
                MO.KEY,
                MO.INST_ID,
                DECODE(MO.PROCESS_NAME, 'ora', 'PX Coordinator', MO.PROCESS_NAME) PROCESS_NAME,
                MO.SID,
                MO.SESSION_SERIAL#,
                MO.PX_SERVER_GROUP,
                MO.PX_SERVER_SET,
                MO.PX_SERVER#,
                ASH0.ACTIVITY_TYPE,
                ASH0.EVENT_NAME,
                MAX(MO.IO_REQS) MAX_IO_REQS,
                MAX(MO.IO_BYTES) MAX_IO_BYTES,
                MAX(MO.BUFFER_GETS) MAX_BUFFER_GETS,
                MAX(MO.ELAPSED_TIME) MAX_ELAPSED_TIME,
                SUM(DECODE(ASH0.ACTIVITY_TYPE, NULL, NULL, ASH0.ACTIVITY_COUNT)) ACTIVITY_COUNT,
                SUM(DECODE(ASH0.ACTIVITY_TYPE, NULL, NULL, ASH0.WAIT_COUNT)) WAIT_COUNT,
                SUM(DECODE(ASH0.ACTIVITY_TYPE, NULL, NULL, ASH0.CPU_COUNT)) CPU_COUNT,
                SUM(DECODE(ASH0.ACTIVITY_TYPE, NULL, NULL, ASH0.OTHER_SQL_COUNT)) OTHER_SQL_COUNT,
                MIN(ASH0.ACTIVITY_START) ACTIVITY_START,
                MAX(ASH0.ACTIVITY_END) ACTIVITY_END,
                MAX(DECODE(MO.ELAPSED_TIME, 0, NULL, MO.ELAPSED_TIME)) ELAPSED_TIME,
                MAX(DECODE(MO.QUEUING_TIME, 0, NULL, MO.QUEUING_TIME)) QUEUING_TIME,
                MAX(DECODE(MO.CPU_TIME, 0, NULL, CPU_TIME)) CPU_TIME,
                MAX(DECODE(MO.FETCHES, 0, NULL, FETCHES)) FETCHES,
                MAX(DECODE(MO.BUFFER_GETS, 0, NULL, MO.BUFFER_GETS)) BUFFER_GETS,
                MAX(DECODE(MO.IO_INTER_BYTES, 0, NULL, MO.IO_INTER_BYTES)) IO_INTER_BYTES,
                MAX(DECODE(MO.READ_REQS, 0, NULL, MO.READ_REQS)) READ_REQS,
                MAX(DECODE(MO.READ_BYTES, 0, NULL, MO.READ_BYTES)) READ_BYTES,
                MAX(DECODE(MO.WRITE_REQS, 0, NULL, MO.WRITE_REQS)) WRITE_REQS,
                MAX(DECODE(MO.WRITE_BYTES, 0, NULL, MO.WRITE_BYTES)) WRITE_BYTES,
                MAX(DECODE(MO.IO_BYTES, 0, NULL, MO.IO_BYTES)) IO_BYTES,
                MAX(DECODE(MO.APPLICATION_WAIT_TIME, 0, NULL, MO.APPLICATION_WAIT_TIME)) APPLICATION_WAIT_TIME,
                MAX(DECODE(MO.CONCURRENCY_WAIT_TIME, 0, NULL, MO.CONCURRENCY_WAIT_TIME)) CONCURRENCY_WAIT_TIME,
                MAX(DECODE(MO.CLUSTER_WAIT_TIME, 0, NULL, MO.CLUSTER_WAIT_TIME)) CLUSTER_WAIT_TIME,
                MAX(DECODE(MO.USER_IO_WAIT_TIME, 0, NULL, MO.USER_IO_WAIT_TIME)) USER_IO_WAIT_TIME,
                MAX(DECODE(PLSQL_EXEC_TIME, 0, NULL, PLSQL_EXEC_TIME)) PLSQL_EXEC_TIME,
                MAX(DECODE(MO.JAVA_EXEC_TIME, 0, NULL, MO.JAVA_EXEC_TIME)) JAVA_EXEC_TIME,
                MAX(DECODE(MO.OTHER_WAIT_TIME, 0, NULL, MO.OTHER_WAIT_TIME)) OTHER_WAIT_TIME
              FROM MONITOR_DATA MO,
                (SELECT ASH1.INST_ID,
                  ASH1.SESSION_ID,
                  ASH1.ACTIVITY_TYPE,
                  ASH1.EVENT_NAME,
                  SUM(ASH1.ACTIVITY_COUNT) ACTIVITY_COUNT,
                  SUM(ASH1.WAIT_COUNT) WAIT_COUNT,
                  SUM(ASH1.CPU_COUNT) CPU_COUNT,
                  SUM(ASH1.OTHER_SQL_COUNT)OTHER_SQL_COUNT,
                  MIN(ASH1.ACTIVITY_START) ACTIVITY_START,
                  MAX(ASH1.ACTIVITY_END) ACTIVITY_END
                FROM ASH_DATA ASH1
                GROUP BY ASH1.INST_ID,
                  ASH1.SESSION_ID,
                  ASH1.ACTIVITY_TYPE,
                  ASH1.EVENT_NAME
                ) ASH0
              WHERE MO.INST_ID = ASH0.INST_ID(+)
              AND MO.SID       = ASH0.SESSION_ID(+)
              AND (:B67        = 1
              OR :B66          = 1)
              GROUP BY MO.INST_ID,
                MO.KEY,
                MO.HAS_OTHER_XML,
                MO.PROCESS_NAME,
                MO.SID,
                MO.SESSION_SERIAL#,
                MO.PX_SERVER_GROUP,
                MO.PX_SERVER_SET,
                MO.PX_SERVER#,
                ASH0.ACTIVITY_TYPE,
                ASH0.EVENT_NAME
              ) PI
            WHERE (:B67 = 1)
            GROUP BY PI.INST_ID,
              PI.KEY,
              PI.HAS_OTHER_XML,
              PI.SID,
              PI.PROCESS_NAME,
              PI.SESSION_SERIAL#,
              PI.PX_SERVER_GROUP,
              PI.PX_SERVER_SET,
              PI.PX_SERVER#
            ) PX_SESSION
          ) PX_SESSIONS,
          (SELECT XMLELEMENT( "instances", XMLATTRIBUTES( MAX(PX_INSTANCE.ACTIVITY_COUNT) AS "max_activity_count", MAX(PX_INSTANCE.CPU_COUNT) AS "max_cpu_count", MAX(PX_INSTANCE.WAIT_COUNT) AS "max_wait_count", MAX(PX_INSTANCE.OTHER_SQL_COUNT) AS "max_other_sql_count", MAX(PX_INSTANCE.ELAPSED_TIME) AS "max_elapsed_time", MAX(PX_INSTANCE.BUFFER_GETS) AS "max_buffer_gets", MAX(PX_INSTANCE.IO_REQS) AS "max_io_reqs", MAX(PX_INSTANCE.IO_BYTES) AS "max_io_bytes"), XMLAGG(PX_INSTANCE.PX_INSTANCES_XML
          ORDER BY INST_ID))
          FROM
            (SELECT PI.INST_ID,
              MAX(PI.ELAPSED_TIME) ELAPSED_TIME,
              MAX(PI.IO_REQS) IO_REQS,
              MAX(PI.IO_BYTES) IO_BYTES,
              MAX(PI.BUFFER_GETS) BUFFER_GETS,
              SUM(PI.ACTIVITY_COUNT) ACTIVITY_COUNT,
              SUM(PI.WAIT_COUNT) WAIT_COUNT,
              SUM(PI.CPU_COUNT) CPU_COUNT,
              SUM(PI.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
              XMLELEMENT( "instance", XMLATTRIBUTES( INST_ID AS "inst_id"), XMLELEMENT( "stats", XMLATTRIBUTES( 'monitor' AS "type"), NVL2(MAX(ELAPSED_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), MAX(ELAPSED_TIME)), NULL), NVL2(MAX(QUEUING_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MAX(QUEUING_TIME)), NULL), NVL2(MAX(CPU_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), MAX(CPU_TIME)), NULL), NVL2(MAX(USER_IO_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('user_io_wait_time' AS "name"), MAX(USER_IO_WAIT_TIME)), NULL), NVL2(MAX(APPLICATION_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), MAX(APPLICATION_WAIT_TIME)), NULL), NVL2(MAX(CONCURRENCY_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time' AS "name"), MAX(CONCURRENCY_WAIT_TIME)), NULL), NVL2(MAX(CLUSTER_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), MAX(CLUSTER_WAIT_TIME)), NULL), NVL2(MAX
              (PLSQL_EXEC_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time'      AS "name"), MAX(PLSQL_EXEC_TIME)), NULL), NVL2(MAX(JAVA_EXEC_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), MAX(JAVA_EXEC_TIME)), NULL), NVL2(MAX(OTHER_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES( 'other_wait_time' AS "name"), MAX(OTHER_WAIT_TIME)), NULL), NVL2(MAX(FETCHES), XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS "name"), MAX(FETCHES)), NULL), NVL2(MAX(BUFFER_GETS), XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), MAX(BUFFER_GETS)), NULL), NVL2(MAX(READ_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('disk_reads' AS "name"), MAX(READ_REQS)), NULL), NVL2(MAX(WRITE_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('direct_writes' AS "name"), MAX(WRITE_REQS)), NULL), NVL2(MAX(READ_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), MAX(READ_REQS)), NULL), NVL2(MAX(READ_BYTES), XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), MAX(READ_BYTES)),
              NULL), NVL2(MAX(WRITE_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), MAX(WRITE_REQS)), NULL), NVL2(MAX(WRITE_BYTES), XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), MAX(WRITE_BYTES)), NULL),
              CASE
                WHEN MAX(IO_INTER_BYTES) IS NULL
                OR NVL(MAX(IO_BYTES), 0)  = 0
                OR MAX(IO_INTER_BYTES)    = MAX(IO_BYTES)
                THEN NULL
                ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(MAX(IO_BYTES)/ DECODE(MAX(IO_INTER_BYTES), 0, 1, MAX(IO_INTER_BYTES)), 2))
              END),
              CASE
                WHEN :B33                  = 1
                AND SUM(PI.ACTIVITY_COUNT) > 0
                THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( TO_CHAR(MIN(PI.ACTIVITY_START), :B12 ) AS "start_time", TO_CHAR(MAX(PI.ACTIVITY_END), :B12 ) AS "end_time", ROUND((MAX(PI.ACTIVITY_END) - MIN(PI.ACTIVITY_START)) * 3600 * 24) + 1 AS "duration", SUM(PI.ACTIVITY_COUNT) AS "count", SUM(PI.WAIT_COUNT) AS "wait_count", SUM(PI.CPU_COUNT) AS "cpu_count", SUM(PI.OTHER_SQL_COUNT) AS "other_sql_count", :B40 AS "cpu_cores", :B39 AS "hyperthread"), XMLAGG( NVL2(ACTIVITY_TYPE, XMLELEMENT( "activity", XMLATTRIBUTES( PI.ACTIVITY_TYPE AS "class", PI.EVENT_NAME AS "event"), ACTIVITY_COUNT), NULL)
                ORDER BY PI.ACTIVITY_TYPE, PI.EVENT_NAME))
                ELSE NULL
              END) PX_INSTANCES_XML
            FROM
              (SELECT MO.INST_ID,
                ASH.ACTIVITY_TYPE,
                ASH.EVENT_NAME,
                ASH.ACTIVITY_COUNT,
                ASH.WAIT_COUNT,
                ASH.CPU_COUNT,
                ASH.OTHER_SQL_COUNT,
                ASH.ACTIVITY_START,
                ASH.ACTIVITY_END,
                MO.ELAPSED_TIME,
                MO.QUEUING_TIME,
                MO.CPU_TIME,
                MO.APPLICATION_WAIT_TIME,
                MO.CONCURRENCY_WAIT_TIME,
                MO.CLUSTER_WAIT_TIME,
                MO.USER_IO_WAIT_TIME,
                MO.PLSQL_EXEC_TIME,
                MO.JAVA_EXEC_TIME,
                MO.OTHER_WAIT_TIME,
                MO.FETCHES,
                MO.BUFFER_GETS,
                MO.IO_INTER_BYTES,
                MO.IO_BYTES,
                MO.READ_REQS,
                MO.READ_BYTES,
                MO.WRITE_REQS,
                MO.WRITE_BYTES,
                MO.IO_REQS
              FROM
                (SELECT MO0.INST_ID,
                  SUM(MO0.ELAPSED_TIME) ELAPSED_TIME,
                  SUM(MO0.QUEUING_TIME) QUEUING_TIME,
                  SUM(MO0.CPU_TIME) CPU_TIME,
                  SUM(MO0.FETCHES) FETCHES,
                  SUM(MO0.BUFFER_GETS) BUFFER_GETS,
                  SUM(MO0.IO_INTER_BYTES) IO_INTER_BYTES,
                  SUM(MO0.IO_BYTES) IO_BYTES,
                  SUM(MO0.READ_REQS) READ_REQS,
                  SUM(MO0.READ_BYTES) READ_BYTES,
                  SUM(MO0.WRITE_REQS) WRITE_REQS,
                  SUM(MO0.WRITE_BYTES) WRITE_BYTES,
                  SUM(MO0.IO_REQS) IO_REQS,
                  SUM(MO0.APPLICATION_WAIT_TIME) APPLICATION_WAIT_TIME,
                  SUM(MO0.CONCURRENCY_WAIT_TIME) CONCURRENCY_WAIT_TIME,
                  SUM(MO0.CLUSTER_WAIT_TIME) CLUSTER_WAIT_TIME,
                  SUM(MO0.USER_IO_WAIT_TIME) USER_IO_WAIT_TIME,
                  SUM(MO0.PLSQL_EXEC_TIME) PLSQL_EXEC_TIME,
                  SUM(MO0.JAVA_EXEC_TIME) JAVA_EXEC_TIME,
                  SUM(MO0.OTHER_WAIT_TIME) OTHER_WAIT_TIME
                FROM MONITOR_DATA MO0
                GROUP BY MO0.INST_ID
                ) MO,
                (SELECT ASH0.INST_ID,
                  ASH0.ACTIVITY_TYPE,
                  ASH0.EVENT_NAME,
                  SUM(ASH0.ACTIVITY_COUNT) ACTIVITY_COUNT,
                  SUM(ASH0.WAIT_COUNT) WAIT_COUNT,
                  SUM(ASH0.CPU_COUNT) CPU_COUNT,
                  SUM(ASH0.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
                  MIN(ASH0.ACTIVITY_START) ACTIVITY_START,
                  MAX(ASH0.ACTIVITY_END) ACTIVITY_END
                FROM ASH_DATA ASH0
                GROUP BY ASH0.INST_ID,
                  ASH0.ACTIVITY_TYPE,
                  ASH0.EVENT_NAME
                ) ASH,
                MONITOR_AGG
              WHERE MO.INST_ID                = ASH.INST_ID(+)
              AND MONITOR_AGG.DIST_INST_COUNT > 0
              ) PI
            GROUP BY PI.INST_ID
            )PX_INSTANCE
          ) PX_INSTANCES
        FROM MONITOR_AGG
        )
      )
    ELSE NULL
  END, XPLAN_XML,
  CASE
    WHEN :B43 = 1
    THEN
      (SELECT XMLELEMENT( "plan_monitor", XMLATTRIBUTES(MAX(PLI.MAX_LINE_ACTIVITY_COUNT) AS "max_activity_count", MAX(PLI.OVERALL_MAX_IO_REQS) AS "max_io_reqs", MAX(PLI.OVERALL_MAX_IO_BYTES) AS "max_io_bytes", MAX(PLI.MAX_LINE_CPU_COUNT) AS "max_cpu_count", MAX(PLI.MAX_LINE_WAIT_COUNT) AS "max_wait_count", MAX(PLI.MAX_LINE_OTHER_SQL_COUNT) AS "max_other_sql_count"), XMLAGG( XMLELEMENT( "operation", XMLATTRIBUTES( PLI.PLAN_LINE_ID AS "id", PLI.PARENT_ID AS "parent_id", PLI.OPERATION AS "name", PLI.OPTIONS AS "options", PLI.DEPTH AS "depth", PLI.POSITION AS "position", PLI.PX_TYPE AS "px_type"), NVL2(PLI.OBJECT_NAME, XMLELEMENT( "object", XMLATTRIBUTES(PLI.OBJECT_TYPE AS "type"), XMLFOREST(PLI.OBJECT_OWNER AS "owner"), XMLFOREST(PLI.OBJECT_NAME AS "name")), NULL), XMLFOREST(PLI.PARTITION_START AS "partition_start", PLI.PARTITION_STOP AS "partition_stop"),
        CASE
          WHEN PLI.CARDINALITY IS NULL
          AND PLI.BYTES        IS NULL
          AND PLI.COST         IS NULL
          AND PLI.TEMP_SPACE   IS NULL
          AND PLI.TIME         IS NULL
          THEN NULL
          ELSE XMLELEMENT( "optimizer", NULL, NVL2(PLI.CARDINALITY, XMLFOREST(PLI.CARDINALITY AS "cardinality"), NULL), NVL2(PLI.BYTES, XMLFOREST(PLI.BYTES AS "bytes"), NULL), NVL2(PLI.COST, XMLFOREST(PLI.COST AS "cost"), NULL), NVL2(PLI.CPU_COST, XMLFOREST(PLI.CPU_COST AS "cpu_cost"), NULL), NVL2(PLI.IO_COST, XMLFOREST(PLI.IO_COST AS "io_cost"), NULL), NVL2(PLI.TEMP_SPACE, XMLFOREST(PLI.TEMP_SPACE AS "temp"), NULL), NVL2(PLI.TIME, XMLFOREST(PLI.TIME AS "time"), NULL))
        END, XMLELEMENT( "stats", XMLATTRIBUTES('plan_monitor' AS "type"), NVL2(PLI.FIRST_MOVE_TIME, XMLELEMENT( "stat", XMLATTRIBUTES('first_active' AS "name"), TO_CHAR(FIRST_MOVE_TIME, :B12 )), NULL),
        CASE
          WHEN PLI.FIRST_MOVE_TIME != PLI.FIRST_CHANGE_TIME
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('first_row' AS "name"), TO_CHAR(FIRST_CHANGE_TIME, :B12 ))
          ELSE NULL
        END, NVL2(PLI.LAST_MOVE_TIME, XMLELEMENT( "stat", XMLATTRIBUTES('last_active' AS "name"), TO_CHAR(LAST_MOVE_TIME, :B12 )), NULL),
        CASE
          WHEN (PLI.FIRST_MOVE_TIME IS NULL
          OR PLI.LAST_MOVE_TIME     IS NULL)
          THEN NULL
          ELSE XMLELEMENT( "stat", XMLATTRIBUTES('duration' AS "name"), ROUND((LAST_MOVE_TIME - FIRST_MOVE_TIME) * 3600 * 24)+1)
        END,
        CASE
          WHEN (PLI.OVERALL_LAST_MOVE_TIME IS NULL
          OR PLI.LAST_MOVE_TIME            IS NULL)
          THEN NULL
          ELSE XMLELEMENT( "stat", XMLATTRIBUTES('from_most_recent' AS "name"), ROUND((PLI.OVERALL_LAST_MOVE_TIME                  - PLI.LAST_MOVE_TIME) * 3600 * 24))
        END, NVL2(PLI.LAST_MOVE_TIME, XMLELEMENT( "stat", XMLATTRIBUTES( 'from_sql_exec_start' AS "name"), ROUND( (FIRST_MOVE_TIME - :B8 ) * 3600*24)), NULL), NVL2(PLI.PERCENT_COMPLETE, XMLELEMENT( "stat", XMLATTRIBUTES('percent_complete' AS "name"), PLI.PERCENT_COMPLETE), NULL), NVL2(PLI.TIME_REMAINING, XMLELEMENT( "stat", XMLATTRIBUTES('time_left' AS "name"), PLI.TIME_REMAINING), NULL),
        CASE
          WHEN PLI.HAS_EXECUTED = 1
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('starts' AS "name"), PLI.STARTS)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP         > 0
          AND PLI.HAS_EXECUTED = 1
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_starts' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MAX_STARTS/1000000), 10000), NULL) AS "iid", MOD(MAX_STARTS, 1000000) AS "sid"), TRUNC(PLI.MAX_STARTS/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP         > 0
          AND PLI.HAS_EXECUTED = 1
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('dop' AS "name"), PLI.DOP)
          ELSE NULL
        END,
        CASE
          WHEN NEED_ROWS          IS NOT NULL
          AND PLI.FIRST_MOVE_TIME IS NOT NULL
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('cardinality' AS "name"), PLI.OUTPUT_ROWS)
          ELSE NULL
        END,
        CASE
          WHEN PLI.NEED_ROWS       IS NOT NULL
          AND PLI.DOP               > 0
          AND PLI.MAX_OUTPUT_ROWS  IS NOT NULL
          AND (PLI.FIRST_MOVE_TIME IS NOT NULL)
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_card' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MAX_OUTPUT_ROWS/1000000), 10000), NULL) AS "iid", MOD(MAX_OUTPUT_ROWS, 1000000) AS "sid"), TRUNC(PLI.MAX_OUTPUT_ROWS/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.MEM > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('memory' AS "name"), PLI.MEM)
          ELSE NULL
        END,
        CASE
          WHEN PLI.MAX_MEM > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('max_memory' AS "name"), PLI.MAX_MEM)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP         > 0
          AND PLI.MIN_MAX_MEM IS NOT NULL
          AND PLI.MAX_MEM      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'min_max_mem' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MIN_MAX_MEM/1000000), 10000), NULL) AS "iid", MOD(MIN_MAX_MEM, 1000000) AS "sid"), TRUNC(PLI.MIN_MAX_MEM/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.TEMP > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('temp' AS "name"), PLI.TEMP)
          ELSE NULL
        END,
        CASE
          WHEN PLI.MAX_TEMP > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('max_temp' AS "name"), PLI.MAX_TEMP)
          ELSE NULL
        END,
        CASE
          WHEN PLI.MAX_TEMP > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('spill_count' AS "name"), PLI.SPILL_COUNT)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP          > 0
          AND PLI.MAX_MAX_TEMP IS NOT NULL
          AND PLI.MAX_TEMP      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_max_temp' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MAX_MAX_TEMP/1000000), 10000), NULL) AS "iid", MOD(MAX_MAX_TEMP, 1000000) AS "sid"), TRUNC(PLI.MAX_MAX_TEMP/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.READ_REQS > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), PLI.READ_REQS)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP           > 0
          AND PLI.MAX_READ_REQS IS NOT NULL
          AND PLI.READ_REQS      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_read_reqs' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(PLI.MAX_READ_REQS/1000000), 10000), NULL) AS "iid", MOD(PLI.MAX_READ_REQS, 1000000) AS "sid"), TRUNC(PLI.MAX_READ_REQS/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.READ_BYTES > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), PLI.READ_BYTES)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP            > 0
          AND PLI.MAX_READ_BYTES IS NOT NULL
          AND PLI.READ_BYTES      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_read_bytes' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(PLI.MAX_READ_BYTES/1000000), 10000), NULL) AS "iid", MOD(PLI.MAX_READ_BYTES, 1000000) AS "sid"), TRUNC(PLI.MAX_READ_BYTES/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.WRITE_REQS > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), PLI.WRITE_REQS)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP            > 0
          AND PLI.MAX_WRITE_REQS IS NOT NULL
          AND PLI.WRITE_REQS      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_write_reqs' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(PLI.MAX_WRITE_REQS/1000000), 10000), NULL) AS "iid", MOD(PLI.MAX_WRITE_REQS, 1000000) AS "sid"), TRUNC(PLI.MAX_WRITE_REQS/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.WRITE_BYTES > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), PLI.WRITE_BYTES)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP             > 0
          AND PLI.MAX_WRITE_BYTES IS NOT NULL
          AND PLI.WRITE_BYTES      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_write_bytes' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(PLI.MAX_WRITE_BYTES/1000000), 10000), NULL) AS "iid", MOD(PLI.MAX_WRITE_BYTES, 1000000) AS "sid"), TRUNC(PLI.MAX_WRITE_BYTES/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.IO_INTER_BYTES IS NOT NULL
          AND PLI.IO_BYTES         > 0
          AND PLI.IO_BYTES        != PLI.IO_INTER_BYTES
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('io_inter_bytes' AS "name"), PLI.IO_INTER_BYTES)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP                > 0
          AND PLI.MAX_IO_INTER_BYTES IS NOT NULL
          AND PLI.IO_BYTES            > 0
          AND PLI.IO_BYTES           != PLI.IO_INTER_BYTES
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_io_inter_bytes' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MAX_IO_INTER_BYTES/1000000), 10000), NULL) AS "iid", MOD(MAX_IO_INTER_BYTES,1000000) AS "sid"), TRUNC(PLI.MAX_IO_INTER_BYTES/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.IO_INTER_BYTES IS NOT NULL
          AND PLI.IO_BYTES         > 0
          AND PLI.IO_BYTES        != PLI.IO_INTER_BYTES
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(PLI.IO_BYTES / DECODE(PLI.IO_INTER_BYTES, 0, 1, PLI.IO_INTER_BYTES), 2))
          ELSE NULL
        END), NVL2(STAT_GID, XMLELEMENT( "rwsstats", XMLATTRIBUTES( PLI.STAT_GID AS "group_id"), DECODE(GID_ROWNUM, 1,
        (SELECT XMLELEMENT( "metadata", NULL, XMLAGG( XMLELEMENT( "stat", XMLATTRIBUTES( ROWNUM AS "id", NAME AS "name", DESCRIPTION AS "desc", TYPE AS "type", DECODE(FLAGS, 0, NULL, FLAGS) AS "flags"), NULL)
        ORDER BY ID))
        FROM V$SQL_MONITOR_STATNAME
        WHERE GROUP_ID = PLI.STAT_GID
        ), NULL), NVL2(STAT1_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(1 AS "id"), STAT1_VALUE), NULL), NVL2(STAT2_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(2 AS "id"), STAT2_VALUE), NULL), NVL2(STAT3_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(3 AS "id"), STAT3_VALUE), NULL), NVL2(STAT4_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(4 AS "id"), STAT4_VALUE), NULL), NVL2(STAT5_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(5 AS "id"), STAT5_VALUE), NULL), NVL2(STAT6_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(6 AS "id"), STAT6_VALUE), NULL), NVL2(STAT7_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(7 AS "id"), STAT7_VALUE), NULL), NVL2(STAT8_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(8 AS "id"), STAT8_VALUE), NULL), NVL2(STAT9_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(9 AS "id"), STAT9_VALUE), NULL), NVL2(STAT10_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(10 AS "id"), STAT10_VALUE), NULL)), NULL),
        CASE
          WHEN PLI.LINE_ACTIVITY_COUNT > 0
          AND :B33                     = 1
          THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( TO_CHAR(PLI.LINE_ACTIVITY_START, :B12 ) AS "start_time", TO_CHAR(PLI.LINE_ACTIVITY_END, :B12 ) AS "end_time", ROUND((PLI.LINE_ACTIVITY_END - PLI.LINE_ACTIVITY_START) * 3600*24) + 1 AS "duration", PLI.LINE_ACTIVITY_COUNT AS "count", PLI.LINE_WAIT_COUNT AS "wait_count", PLI.LINE_CPU_COUNT AS "cpu_count", PLI.LINE_OTHER_SQL_COUNT AS "other_sql_count", :B40 AS "cpu_cores", :B39 AS "hyperthread"), PLI.ACTIVITY_TOTAL, PLI.PLAN_ACTIVITY_HISTO)
          ELSE NULL
        END)
      ORDER BY PLI.PLAN_LINE_ID) )
      FROM
        (SELECT AT.MAX_LINE_ACTIVITY_COUNT,
          PM.OVERALL_MAX_IO_REQS,
          PM.OVERALL_MAX_IO_BYTES,
          AT.MAX_LINE_CPU_COUNT,
          AT.MAX_LINE_WAIT_COUNT,
          AT.LINE_OTHER_SQL_COUNT,
          AT.MAX_LINE_OTHER_SQL_COUNT,
          PM.PLAN_LINE_ID,
          PM.PARENT_ID,
          PM.OPERATION,
          PM.OPTIONS,
          PM.DEPTH,
          PM.POSITION,
          CASE
            WHEN PM.OPERATION      = 'PX COORDINATOR'
            AND :B23               = 'Y'
            AND (PM.PX_SERVER_SET IS NOT NULL
            OR AH.PX_SERVER_SET   IS NOT NULL)
            THEN 'QC'
            WHEN PM.PX_SERVER_SET IS NOT NULL
            THEN TO_CHAR(PM.PX_SERVER_SET)
            WHEN AH.PX_SERVER_SET IS NOT NULL
            THEN TO_CHAR(AH.PX_SERVER_SET)
            WHEN (:B23                = 'N'
            OR (PM.LAST_CHANGE_TIME  IS NULL
            AND AT.LINE_ACTIVITY_END IS NULL))
            THEN NULL
            ELSE 'QC'
          END PX_TYPE,
          PM.FIRST_CHANGE_TIME,
          AT.LINE_ACTIVITY_START,
          PM.LAST_CHANGE_TIME,
          PM.OVERALL_LAST_CHANGE_TIME,
          AT.LINE_ACTIVITY_END,
          AT.OVERALL_LINE_ACTIVITY_END,
          LEAST(NVL(AT.LINE_ACTIVITY_START, PM.FIRST_CHANGE_TIME), NVL(PM.FIRST_CHANGE_TIME, AT.LINE_ACTIVITY_START)) FIRST_MOVE_TIME,
          GREATEST(NVL(AT.LINE_ACTIVITY_END, PM.LAST_CHANGE_TIME), NVL(PM.LAST_CHANGE_TIME, AT.LINE_ACTIVITY_END)) LAST_MOVE_TIME,
          GREATEST(NVL(AT.OVERALL_LINE_ACTIVITY_END, PM.OVERALL_LAST_CHANGE_TIME), NVL(PM.OVERALL_LAST_CHANGE_TIME, AT.OVERALL_LINE_ACTIVITY_END)) OVERALL_LAST_MOVE_TIME,
          CASE
            WHEN PM.STARTS IS NOT NULL
            AND PM.STARTS   > 0
            THEN 1
            ELSE 0
          END HAS_EXECUTED,
          PM.OBJECT_NAME,
          PM.OBJECT_TYPE,
          PM.OBJECT_OWNER,
          PM.PARTITION_START,
          PM.PARTITION_STOP,
          PM.CARDINALITY,
          PM.BYTES,
          PM.COST,
          PM.TEMP_SPACE,
          PM.TIME,
          PM.CPU_COST,
          PM.IO_COST,
          LO.PERCENT_COMPLETE,
          LO.TIME_REMAINING,
          PM.STARTS,
          PM.DOP,
          PM.MAX_STARTS,
          PM.OUTPUT_ROWS,
          PM.NEED_ROWS,
          PM.MAX_OUTPUT_ROWS,
          PM.MEM,
          PM.MAX_MEM,
          PM.MIN_MAX_MEM,
          PM.TEMP,
          PM.MAX_TEMP,
          PM.SPILL_COUNT,
          PM.MAX_MAX_TEMP,
          PM.READ_REQS,
          PM.MAX_READ_REQS,
          PM.READ_BYTES,
          PM.MAX_READ_BYTES,
          PM.WRITE_REQS,
          PM.MAX_WRITE_REQS,
          PM.WRITE_BYTES,
          PM.MAX_WRITE_BYTES,
          PM.IO_INTER_BYTES,
          PM.IO_BYTES,
          PM.MAX_IO_INTER_BYTES,
          AT.LINE_ACTIVITY_COUNT,
          AT.LINE_WAIT_COUNT,
          AT.LINE_CPU_COUNT,
          AT.ACTIVITY_TOTAL,
          AH.PLAN_ACTIVITY_HISTO,
          PM.STAT_GID,
          PM.GID_ROWNUM,
          PM.STAT1_VALUE,
          PM.STAT2_VALUE,
          PM.STAT3_VALUE,
          PM.STAT4_VALUE,
          PM.STAT5_VALUE,
          PM.STAT6_VALUE,
          PM.STAT7_VALUE,
          PM.STAT8_VALUE,
          PM.STAT9_VALUE,
          PM.STAT10_VALUE
        FROM
          (SELECT AT0.*,
            MAX(LINE_ACTIVITY_END) OVER() OVERALL_LINE_ACTIVITY_END,
            MAX(LINE_ACTIVITY_COUNT) OVER() MAX_LINE_ACTIVITY_COUNT,
            MAX(LINE_CPU_COUNT) OVER() MAX_LINE_CPU_COUNT,
            MAX(LINE_WAIT_COUNT) OVER() MAX_LINE_WAIT_COUNT,
            MAX(LINE_OTHER_SQL_COUNT) OVER() MAX_LINE_OTHER_SQL_COUNT
          FROM
            (SELECT AD1.PLAN_LINE_ID,
              MIN(AD1.LINE_ACTIVITY_START) LINE_ACTIVITY_START,
              MAX(AD1.LINE_ACTIVITY_END) LINE_ACTIVITY_END,
              SUM(AD1.ACTIVITY_COUNT) LINE_ACTIVITY_COUNT,
              SUM(AD1.WAIT_COUNT) LINE_WAIT_COUNT,
              SUM(AD1.OTHER_SQL_COUNT) LINE_OTHER_SQL_COUNT,
              SUM(AD1.CPU_COUNT) LINE_CPU_COUNT,
              SUBSTR(MAX(LPAD(AD1.ACTIVITY_COUNT,10)
              || AD1.ACTIVITY_TYPE), 11) MOST_ACTIVE,
              XMLAGG(XMLELEMENT( "activity", XMLATTRIBUTES( AD1.ACTIVITY_TYPE AS "class", AD1.EVENT_NAME AS "event"), AD1.ACTIVITY_COUNT)
            ORDER BY AD1.ACTIVITY_TYPE, AD1.EVENT_NAME) ACTIVITY_TOTAL
            FROM
              (SELECT AD0.PLAN_LINE_ID,
                AD0.ACTIVITY_TYPE,
                AD0.EVENT_NAME,
                MIN(AD0.ACTIVITY_START) LINE_ACTIVITY_START,
                MAX(AD0.ACTIVITY_END) LINE_ACTIVITY_END,
                SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT,
                SUM(AD0.WAIT_COUNT) WAIT_COUNT,
                SUM(AD0.CPU_COUNT) CPU_COUNT,
                SUM(AD0.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
                MAX(AD0.DFO_MOST_ACTIVE_IID) DFO_MOST_ACTIVE_IID,
                MAX(AD0.DFO_MOST_ACTIVE_SID) DFO_MOST_ACTIVE_SID,
                SUM(AD0.DFO_MOST_ACTIVE_COUNT) DFO_MOST_ACTIVE_COUNT
              FROM ASH_DATA AD0
              WHERE AD0.PLAN_LINE_ID IS NOT NULL
              GROUP BY AD0.PLAN_LINE_ID,
                AD0.ACTIVITY_TYPE,
                AD0.EVENT_NAME
              ) AD1
            GROUP BY AD1.PLAN_LINE_ID
            ) AT0
          ) AT,
          (SELECT AD2.PLAN_LINE_ID,
            MIN(AD2.PX_SERVER_SET) PX_SERVER_SET,
            MIN(AD2.LINE_ACTIVITY_START) LINE_ACTIVITY_START,
            MAX(AD2.LINE_ACTIVITY_END) LINE_ACTIVITY_END,
            SUM(AD2.ACTIVITY_COUNT) ACTIVITY_COUNT,
            SUM(AD2.WAIT_COUNT) WAIT_COUNT,
            SUM(AD2.CPU_COUNT) CPU_COUNT,
            SUM(AD2.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
            CASE
              WHEN :B29                   = 1
              AND SUM(AD2.ACTIVITY_COUNT) > 0
              THEN XMLELEMENT( "activity_histogram", XMLATTRIBUTES( :B26 AS "bucket_interval", :B27 AS "bucket_count", TO_CHAR( :B20 , :B12 ) AS "start_time", TO_CHAR(:B22 , :B12 ) AS "end_time", ROUND((:B22 -:B20 ) *3600*24) + 1 AS "duration"), XMLAGG(XMLELEMENT( "bucket", XMLATTRIBUTES( AD2.BUCKET_NUM AS "number"), AD2.ACTIVITY_BUCKET)
              ORDER BY AD2.BUCKET_NUM))
              ELSE NULL
            END PLAN_ACTIVITY_HISTO
          FROM
            (SELECT AD1.PLAN_LINE_ID,
              AD1.BUCKET_NUM,
              MIN(AD1.PX_SERVER_SET) PX_SERVER_SET,
              MIN(AD1.LINE_ACTIVITY_START) LINE_ACTIVITY_START,
              MAX(AD1.LINE_ACTIVITY_END) LINE_ACTIVITY_END,
              MIN(AD1.BUCKET_ACTIVITY_START) BUCKET_ACTIVITY_START,
              MAX(AD1.BUCKET_ACTIVITY_END) BUCKET_ACTIVITY_END,
              SUM(AD1.ACTIVITY_COUNT) ACTIVITY_COUNT,
              SUM(AD1.WAIT_COUNT) WAIT_COUNT,
              SUM(AD1.CPU_COUNT) CPU_COUNT,
              SUM(AD1.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
              SUBSTR(MAX(LPAD(AD1.ACTIVITY_COUNT,10)
              || AD1.ACTIVITY_TYPE), 11) MOST_ACTIVE,
              XMLAGG(NVL2(AD1.ACTIVITY_TYPE, XMLELEMENT( "activity", XMLATTRIBUTES( AD1.ACTIVITY_TYPE AS "class", AD1.EVENT_NAME AS "event"), AD1.ACTIVITY_COUNT), NULL)
            ORDER BY AD1.ACTIVITY_TYPE, AD1.EVENT_NAME) ACTIVITY_BUCKET
            FROM
              (SELECT AD0.PLAN_LINE_ID,
                AD0.PLAN_ACTIVITY_BUCKET_NUM BUCKET_NUM,
                AD0.ACTIVITY_TYPE,
                AD0.EVENT_NAME,
                MIN(NVL2(AD0.ACTIVITY_START, AD0.PX_SERVER_SET, NULL)) PX_SERVER_SET,
                MIN(AD0.ACTIVITY_START) LINE_ACTIVITY_START,
                MAX(AD0.ACTIVITY_END) LINE_ACTIVITY_END,
                MIN(AD0.BUCKET_ACTIVITY_START) BUCKET_ACTIVITY_START,
                MAX(AD0.BUCKET_ACTIVITY_END) BUCKET_ACTIVITY_END,
                SUM(AD0.CPU_COUNT) CPU_COUNT,
                SUM(AD0.WAIT_COUNT) WAIT_COUNT,
                SUM(AD0.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
                SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT
              FROM ASH_DATA AD0
              GROUP BY AD0.PLAN_LINE_ID,
                AD0.PLAN_ACTIVITY_BUCKET_NUM,
                AD0.ACTIVITY_TYPE,
                AD0.EVENT_NAME
              ) AD1
            GROUP BY AD1.PLAN_LINE_ID,
              AD1.BUCKET_NUM
            ) AD2
          GROUP BY AD2.PLAN_LINE_ID
          ) AH,
          (SELECT LO.SQL_PLAN_LINE_ID PLAN_LINE_ID,
            DECODE(SUM(LO.TOTALWORK), 0, NULL, ROUND(SUM(LO.SOFAR)*100/SUM(LO.TOTALWORK))) PERCENT_COMPLETE,
            MAX(LO.TIME_REMAINING) TIME_REMAINING
          FROM GV$SESSION_LONGOPS LO,
            MONITOR_DATA MO
          WHERE (:B49           = 'Y'
          OR :B68               = 'DONE (ERROR)')
          AND LO.SQL_ID         = :B9
          AND LO.SQL_EXEC_START = :B8
          AND LO.SQL_EXEC_ID    = :B7
          AND LO.INST_ID        = MO.INST_ID
          AND LO.SID            = MO.SID
          GROUP BY LO.SQL_PLAN_LINE_ID
          ) LO,
          (SELECT PM0.*,
            CASE
              WHEN PM0.STARTS    IS NULL
              OR PM0.STARTS       = 0
              OR PM0.OUTPUT_ROWS IS NULL
              THEN NULL
              ELSE 1
            END NEED_ROWS,
            ROW_NUMBER() OVER(PARTITION BY PM0.STAT_GID ORDER BY PM0.PLAN_LINE_ID ) GID_ROWNUM,
            MAX(LAST_CHANGE_TIME) OVER() OVERALL_LAST_CHANGE_TIME,
            MAX(MAX_IO_REQS) OVER() OVERALL_MAX_IO_REQS,
            MAX(MAX_IO_BYTES) OVER() OVERALL_MAX_IO_BYTES
          FROM
            (SELECT
              /*+ leading(mo) use_hash(plm) */
              PLM.PLAN_LINE_ID PLAN_LINE_ID,
              PLM.PLAN_OPERATION OPERATION,
              PLM.PLAN_OPTIONS OPTIONS,
              MAX(PLM.PLAN_PARENT_ID) PARENT_ID,
              MAX(PLM.PLAN_DEPTH) DEPTH,
              MAX(PLM.PLAN_POSITION) POSITION,
              MAX(PLM.PLAN_OBJECT_OWNER) OBJECT_OWNER,
              MAX(PLM.PLAN_OBJECT_NAME) OBJECT_NAME,
              MAX(PLM.PLAN_OBJECT_TYPE) OBJECT_TYPE,
              MAX(PLM.PLAN_COST) COST,
              MAX(PLM.PLAN_CARDINALITY) CARDINALITY,
              MAX(PLM.PLAN_BYTES) BYTES,
              MAX(PLM.PLAN_CPU_COST) CPU_COST,
              MAX(PLM.PLAN_IO_COST) IO_COST,
              MAX(PLM.PLAN_TEMP_SPACE) TEMP_SPACE,
              MAX(PLM.PLAN_TIME) TIME,
              MAX(PLM.PLAN_PARTITION_START) PARTITION_START,
              MAX(PLM.PLAN_PARTITION_STOP) PARTITION_STOP,
              MIN(PLM.FIRST_CHANGE_TIME) FIRST_CHANGE_TIME,
              MAX(PLM.LAST_CHANGE_TIME) LAST_CHANGE_TIME,
              MIN(PLM.LAST_CHANGE_TIME) MIN_LAST_CHANGE_TIME,
              MIN(NVL2(PLM.FIRST_CHANGE_TIME, MO.PX_SERVER_SET, NULL)) PX_SERVER_SET,
              COUNT(
              CASE
                WHEN PLM.PAR           IS NOT NULL
                AND PLM.STARTS         IS NOT NULL
                AND PLM.STARTS          > 0
                AND PLM.PLAN_LINE_ID   != 0
                AND PLM.PLAN_OPERATION != 'PX COORDINATOR'
                THEN 1
                ELSE NULL
              END) DOP,
              SUM(PLM.STARTS) STARTS,
              MAX(NVL2(PAR, PLM.STARTS * 10000000000 + PLM.ES, NULL)) MAX_STARTS,
              SUM(PLM.OUTPUT_ROWS) OUTPUT_ROWS,
              MAX(NVL2(PAR, PLM.OUTPUT_ROWS * 10000000000 +PLM.ES, NULL)) MAX_OUTPUT_ROWS,
              SUM(PLM.WORKAREA_MEM) MEM,
              SUM(PLM.WORKAREA_MAX_MEM) MAX_MEM,
              MIN(NVL2(PAR, PLM.WORKAREA_MAX_MEM * 10000000000 + PLM.ES, NULL)) MIN_MAX_MEM,
              SUM(PLM.WORKAREA_TEMPSEG) TEMP,
              SUM(PLM.WORKAREA_MAX_TEMPSEG) MAX_TEMP,
              MAX(NVL2(PAR, PLM.WORKAREA_MAX_TEMPSEG * 10000000000 + PLM.ES, NULL)) MAX_MAX_TEMP,
              COUNT(PLM.WORKAREA_MAX_TEMPSEG) SPILL_COUNT,
              SUM(PLM.PHYSICAL_READ_REQUESTS) READ_REQS,
              MAX(NVL2(PAR, PLM.PHYSICAL_READ_REQUESTS * 10000000000 + PLM.ES, NULL)) MAX_READ_REQS,
              SUM(PLM.PHYSICAL_READ_BYTES) READ_BYTES,
              MAX(NVL2(PAR, PLM.PHYSICAL_READ_BYTES * 10000000000 + PLM.ES, NULL)) MAX_READ_BYTES,
              SUM(PLM.PHYSICAL_WRITE_REQUESTS) WRITE_REQS,
              MAX(NVL2(PAR, PLM.PHYSICAL_WRITE_REQUESTS * 10000000000 + PLM.ES, NULL)) MAX_WRITE_REQS,
              SUM(PLM.PHYSICAL_WRITE_BYTES) WRITE_BYTES,
              MAX(NVL2(PAR, PLM.PHYSICAL_WRITE_BYTES * 10000000000 + PLM.ES, NULL)) MAX_WRITE_BYTES,
              NVL(SUM(PLM.PHYSICAL_READ_BYTES), 0)   + NVL(SUM(PLM.PHYSICAL_WRITE_BYTES), 0) IO_BYTES,
              SUM(NVL(PLM.PHYSICAL_READ_REQUESTS, 0) + NVL(PLM.PHYSICAL_WRITE_REQUESTS, 0)) MAX_IO_REQS,
              SUM(NVL(PLM.PHYSICAL_READ_BYTES, 0)    + NVL(PLM.PHYSICAL_WRITE_BYTES, 0)) MAX_IO_BYTES,
              SUM(PLM.IO_INTERCONNECT_BYTES) IO_INTER_BYTES,
              MAX(NVL2(PAR, PLM.IO_INTERCONNECT_BYTES * 10000000000 + PLM.ES, NULL)) MAX_IO_INTER_BYTES,
              MAX(OTHERSTAT_GROUP_ID) STAT_GID,
              NVL(DECODE(MAX(OTHERSTAT_1_TYPE), 3, MAX(OTHERSTAT_1_VALUE), 4, MAX(OTHERSTAT_1_VALUE), 6, MIN(OTHERSTAT_1_VALUE), 7, MIN(OTHERSTAT_1_VALUE), NULL), SUM(DECODE(OTHERSTAT_1_TYPE, 1, OTHERSTAT_1_VALUE, 2, OTHERSTAT_1_VALUE, NULL))) STAT1_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_2_TYPE), 3, MAX(OTHERSTAT_2_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_2_VALUE), 7, MIN(RMAX1 + OTHERSTAT_2_VALUE), NULL), 6, MIN(OTHERSTAT_2_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_2_TYPE, 1, OTHERSTAT_2_VALUE, 2, OTHERSTAT_2_VALUE, NULL))) STAT2_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_3_TYPE), 3, MAX(OTHERSTAT_3_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_3_VALUE), 7, MIN(RMAX1 + OTHERSTAT_3_VALUE), NULL), 6, MIN(OTHERSTAT_3_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_3_TYPE, 1, OTHERSTAT_3_VALUE, 2, OTHERSTAT_3_VALUE, NULL))) STAT3_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_4_TYPE), 3, MAX(OTHERSTAT_4_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_4_VALUE), 7, MIN(RMAX1 + OTHERSTAT_4_VALUE), NULL), 6, MIN(OTHERSTAT_4_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_4_TYPE, 1, OTHERSTAT_4_VALUE, 2, OTHERSTAT_4_VALUE, NULL))) STAT4_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_5_TYPE), 3, MAX(OTHERSTAT_5_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_5_VALUE), 7, MIN(RMAX1 + OTHERSTAT_5_VALUE), NULL), 6, MIN(OTHERSTAT_5_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_5_TYPE, 1, OTHERSTAT_5_VALUE, 2, OTHERSTAT_5_VALUE, NULL))) STAT5_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_6_TYPE), 3, MAX(OTHERSTAT_6_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_6_VALUE), 7, MIN(RMAX1 + OTHERSTAT_6_VALUE), NULL), 6, MIN(OTHERSTAT_6_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_6_TYPE, 1, OTHERSTAT_6_VALUE, 2, OTHERSTAT_6_VALUE, NULL))) STAT6_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_7_TYPE), 3, MAX(OTHERSTAT_7_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_7_VALUE), 7, MIN(RMAX1 + OTHERSTAT_7_VALUE), NULL), 6, MIN(OTHERSTAT_7_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_7_TYPE, 1, OTHERSTAT_7_VALUE, 2, OTHERSTAT_7_VALUE, NULL))) STAT7_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_8_TYPE), 3, MAX(OTHERSTAT_8_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_8_VALUE), 7, MIN(RMAX1 + OTHERSTAT_8_VALUE), NULL), 6, MIN(OTHERSTAT_8_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_8_TYPE, 1, OTHERSTAT_8_VALUE, 2, OTHERSTAT_8_VALUE, NULL))) STAT8_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_9_TYPE), 3, MAX(OTHERSTAT_9_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_9_VALUE), 7, MIN(RMAX1 + OTHERSTAT_9_VALUE), NULL), 6, MIN(OTHERSTAT_9_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_9_TYPE, 1, OTHERSTAT_9_VALUE, 2, OTHERSTAT_9_VALUE, NULL))) STAT9_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_10_TYPE), 3, MAX(OTHERSTAT_10_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1 + OTHERSTAT_10_VALUE), 7, MIN(RMAX1 + OTHERSTAT_10_VALUE), NULL), 6, MIN(OTHERSTAT_10_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_10_TYPE, 1, OTHERSTAT_10_VALUE, 2, OTHERSTAT_10_VALUE, NULL))) STAT10_VALUE
            FROM
              (SELECT A.*,
                OTHERSTAT_1_VALUE * 10000000000000000 RMAX1,
                A.INST_ID         * 1000000 + A.SID ES,
                DECODE(A.PROCESS_NAME, 'ora', NULL, 1) PAR
              FROM GV$SQL_PLAN_MONITOR A
              ) PLM,
              MONITOR_DATA MO
            WHERE PLM.SQL_ID       = :B9
            AND PLM.SQL_EXEC_START = :B8
            AND PLM.SQL_EXEC_ID    = :B7
            AND PLM.INST_ID        = MO.INST_ID
            AND PLM.INST_ID BETWEEN :B11 AND :B10
            AND PLM.KEY = MO.KEY
            GROUP BY PLM.PLAN_LINE_ID,
              PLM.PLAN_OPERATION,
              PLM.PLAN_OPTIONS
            ) PM0
          ) PM
        WHERE AH.PLAN_LINE_ID(+) = PM.PLAN_LINE_ID
        AND AT.PLAN_LINE_ID(+)   = PM.PLAN_LINE_ID
        AND LO.PLAN_LINE_ID(+)   = PM.PLAN_LINE_ID
        AND (:B21               IS NULL
        OR PM.PLAN_LINE_ID       = :B21 )
        ) PLI
      )
    ELSE NULL
  END,
  CASE
    WHEN :B42 = 1
    THEN DBMS_SQLTUNE.BUILD_STASH_XML( SESSION_ID=>:B19 , SESSION_SERIAL=>:B18 , SESSION_INST_ID=>:B17 , PX_MODE=>'yes', START_TIME=>:B20 , END_TIME=>:B22 , MISSING_SECONDS=> :B41 , INSTANCE_LOW_FILTER=>:B11 , INSTANCE_HIGH_FILTER=>:B10 , BUCKET_MAX_COUNT=>NULL, BUCKET_INTERVAL=>:B26 , REPORT_LEVEL=>'typical', CPU_CORES=>:B40 , IS_HYPER=>:B39 )
    ELSE NULL
  END),
  (
  CASE
    WHEN :B38 = 1
    THEN
      (SELECT XMLELEMENT( "skewed_sessions", XMLATTRIBUTES( DECODE(MIN(INST_ID), NULL, :B17 , MIN(INST_ID)) AS "min_iid", DECODE(MAX(INST_ID), NULL, :B17 , MAX(INST_ID)) AS "max_iid"), XMLAGG( XMLELEMENT( "s", XMLATTRIBUTES( INST_ID AS "i"), SESSION_ID)
      ORDER BY INST_ID, SESSION_ID))
      FROM
        (SELECT SESS.*
        FROM
          (SELECT DECODE(AD.DFO_MOST_ACTIVE_IID, :B17 , NULL, AD.DFO_MOST_ACTIVE_IID) INST_ID,
            AD.DFO_MOST_ACTIVE_SID SESSION_ID
          FROM ASH_DATA AD
          WHERE AD.DFO_MOST_ACTIVE_COUNT IS NOT NULL
          GROUP BY AD.DFO_MOST_ACTIVE_IID,
            AD.DFO_MOST_ACTIVE_SID
          ORDER BY MAX(AD.DFO_MOST_ACTIVE_COUNT) DESC
          ) SESS
        WHERE ROWNUM <= 100
        )
      )
    ELSE NULL
  END),
  (
  CASE
    WHEN :B37 = 1
    THEN
      (SELECT XMLELEMENT( "report_repository_summary",
        CASE
          WHEN MA.MAX_DBOP_NAME IS NOT NULL
          THEN XMLELEMENT( "dbop", XMLATTRIBUTES('F' AS "detail", MA.MAX_DBOP_NAME AS "dbop_name", TO_CHAR(MA.MIN_FIRST_REFRESH_TIME, :B12 ) AS "dbop_exec_start", MA.MAX_DBOP_EXEC_ID AS "dbop_exec_id"), XMLFOREST( MA.MAX_STATUS AS "status", TO_CHAR(NVL(MA.MAX_SQL_EXEC_START, MA.MIN_FIRST_REFRESH_TIME), :B12 )AS "first_refresh_time", TO_CHAR(MA.MAX_LAST_REFRESH_TIME, :B12 )AS "last_refresh_time", MA.SUM_REFRESH_COUNT AS "refresh_count", MA.MAX_INST_ID AS "inst_id", MA.MAX_SESSION_ID AS "session_id", MA.MAX_SESSION_SERIAL AS "session_serial", MA.MAX_USERID AS "user_id", MA.MAX_USERNAME AS "user", MA.MAX_CON_ID AS "con_id", MA.MAX_CON_NAME AS "con_name", MA.MAX_MODULE AS "module", MA.MAX_ACTION AS "action", MA.MAX_SERVICE_NAME AS "service", MA.MAX_CLIENT_ID AS "client_id", MA.MAX_CLIENT_INFO AS "client_info", MA.MAX_PROGRAM AS "program", MA.MAX_PL_ENTRY_OID AS "plsql_entry_object_id", MA.MAX_PL_ENTRY_PROGID AS "plsql_entry_subprogram_id", MA.MAX_PL_OID AS "plsql_object_id",
            MA.MAX_PL_PROGID                         AS "plsql_subprogram_id", MA.MAX_PX_IS_CROSS_INSTANCE AS "is_cross_instance", MA.MAX_PX_DOP AS "dop", MA.MAX_PX_DOP_INSTANCES AS "instances"),
            CASE
              WHEN MA.MAX_ERROR_NUMBER IS NULL
              THEN NULL
              ELSE XMLELEMENT( "error", XMLATTRIBUTES(MA.MAX_ERROR_NUMBER AS "number", MA.MAX_ERROR_FACILITY AS "facility"), MA.MAX_ERROR_MESSAGE)
            END, XMLELEMENT( "stats", XMLATTRIBUTES('monitor'             AS "type"), XMLELEMENT( "stat", XMLATTRIBUTES('duration' AS "name"), GREATEST(ROUND((MA.MAX_LAST_REFRESH_TIME- NVL(MA.MAX_SQL_EXEC_START, MA.MIN_FIRST_REFRESH_TIME))*86400), LEAST(MA.SUM_ELAPSED_TIME/1000000, 1), CEIL(MA.MAX_QUEUING_TIME/1000000))), DECODE(MA.SUM_ELAPSED_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), MA.SUM_ELAPSED_TIME)), DECODE(MA.MAX_QUEUING_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MA.MAX_QUEUING_TIME)), DECODE(MA.SUM_CPU_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), MA.SUM_CPU_TIME)), DECODE(MA.SUM_USER_IO_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_io_wait_time' AS "name"), MA.SUM_USER_IO_WAIT_TIME)), DECODE(MA.SUM_APPLICATION_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), MA.SUM_APPLICATION_WAIT_TIME)), DECODE(MA.SUM_CONCURRENCY_WAIT_TIME, 0,
            NULL, XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time'            AS "name"), MA.SUM_CONCURRENCY_WAIT_TIME)), DECODE(MA.SUM_CLUSTER_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), MA.SUM_CLUSTER_WAIT_TIME)), DECODE(MA.SUM_PLSQL_EXEC_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time' AS "name"), MA.SUM_PLSQL_EXEC_TIME)), DECODE(MA.SUM_JAVA_EXEC_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), MA.SUM_JAVA_EXEC_TIME)), DECODE(MA.SUM_OTHER_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('other_wait_time' AS "name"), MA.SUM_OTHER_WAIT_TIME)), DECODE(MA.SUM_FETCHES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS "name"), MA.SUM_FETCHES)), DECODE(MA.SUM_BUFFER_GETS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), MA.SUM_BUFFER_GETS)), DECODE(MA.SUM_READ_REQS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), MA.SUM_READ_REQS)), DECODE(
            MA.SUM_READ_BYTES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), MA.SUM_READ_BYTES)), DECODE(MA.SUM_WRITE_REQS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), MA.SUM_WRITE_REQS)), DECODE(MA.SUM_WRITE_BYTES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), MA.SUM_WRITE_BYTES)),
            CASE
              WHEN MA.SUM_IO_INTER_BYTES IS NULL
              OR MA.SUM_IO_INTER_BYTES    = MA.SUM_IO_BYTES
              OR MA.SUM_IO_BYTES          = 0
              THEN NULL
              ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(MA.SUM_IO_BYTES / DECODE(MA.SUM_IO_INTER_BYTES, 0, 1, MA.SUM_IO_INTER_BYTES), 2))
            END) )
          ELSE XMLELEMENT( "sql", XMLATTRIBUTES( MA.MAX_SQL_ID AS "sql_id", TO_CHAR(MA.MAX_SQL_EXEC_START, :B12 ) AS "sql_exec_start", MA.MAX_SQL_EXEC_ID AS "sql_exec_id"), XMLFOREST(MA.MAX_STATUS AS "status", SUBSTR(MA.SQLMON_TEXT, 1, 100) AS "sql_text", TO_CHAR(MA.MIN_FIRST_REFRESH_TIME, :B12 ) AS "first_refresh_time", TO_CHAR(MA.MAX_LAST_REFRESH_TIME, :B12 ) AS "last_refresh_time", MA.SUM_REFRESH_COUNT AS "refresh_count", MA.MAX_INST_ID AS "inst_id", MA.MAX_SESSION_ID AS "session_id", MA.MAX_SESSION_SERIAL AS "session_serial", MA.MAX_USERID AS "user_id", MA.MAX_USERNAME AS "user", MA.MAX_CON_ID AS "con_id", MA.MAX_CON_NAME AS "con_name", MA.MAX_MODULE AS "module", MA.MAX_ACTION AS "action", MA.MAX_SERVICE_NAME AS "service", MA.MAX_CLIENT_ID AS "client_id", MA.MAX_CLIENT_INFO AS "client_info", MA.MAX_PROGRAM AS "program", MA.MAX_PLAN_HASH_VALUE AS "plan_hash", MA.MAX_PL_ENTRY_OID AS "plsql_entry_object_id", MA.MAX_PL_ENTRY_PROGID AS "plsql_entry_subprogram_id", MA.MAX_PL_OID AS
            "plsql_object_id", MA.MAX_PL_PROGID                AS "plsql_subprogram_id", MA.MAX_PX_IS_CROSS_INSTANCE AS "is_cross_instance", MA.MAX_PX_DOP AS "dop", MA.MAX_PX_DOP_INSTANCES AS "instances", MA.SUM_SERVERS_REQUESTED AS "px_servers_requested", MA.SUM_SERVERS_ALLOCATED AS "px_servers_allocated"), XMLELEMENT( "stats", XMLATTRIBUTES('monitor' AS "type"), XMLELEMENT( "stat", XMLATTRIBUTES('duration' AS "name"), GREATEST(ROUND((MA.MAX_LAST_REFRESH_TIME- MA.MAX_SQL_EXEC_START)*86400), LEAST(MA.SUM_ELAPSED_TIME/1000000, 1), CEIL(MA.MAX_QUEUING_TIME/1000000))), DECODE(MA.SUM_ELAPSED_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), MA.SUM_ELAPSED_TIME)), DECODE(MA.MAX_QUEUING_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MA.MAX_QUEUING_TIME)), DECODE(MA.SUM_CPU_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), MA.SUM_CPU_TIME)), DECODE(MA.SUM_USER_IO_WAIT_TIME, 0, NULL, XMLELEMENT( "stat",
            XMLATTRIBUTES('user_io_wait_time'                                                                              AS "name"), MA.SUM_USER_IO_WAIT_TIME)), DECODE(MA.SUM_APPLICATION_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), MA.SUM_APPLICATION_WAIT_TIME)), DECODE(MA.SUM_CONCURRENCY_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time' AS "name"), MA.SUM_CONCURRENCY_WAIT_TIME)), DECODE(MA.SUM_CLUSTER_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), MA.SUM_CLUSTER_WAIT_TIME)), DECODE(MA.SUM_PLSQL_EXEC_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time' AS "name"), MA.SUM_PLSQL_EXEC_TIME)), DECODE(MA.SUM_JAVA_EXEC_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), MA.SUM_JAVA_EXEC_TIME)), DECODE(MA.SUM_OTHER_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('other_wait_time' AS "name"), MA.SUM_OTHER_WAIT_TIME)), DECODE(MA.SUM_FETCHES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS
            "name"), MA.SUM_FETCHES)), DECODE(MA.SUM_BUFFER_GETS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), MA.SUM_BUFFER_GETS)), DECODE(MA.SUM_READ_REQS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), MA.SUM_READ_REQS)), DECODE(MA.SUM_READ_BYTES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), MA.SUM_READ_BYTES)), DECODE(MA.SUM_WRITE_REQS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), MA.SUM_WRITE_REQS)), DECODE(MA.SUM_WRITE_BYTES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), MA.SUM_WRITE_BYTES)),
            CASE
              WHEN MA.SUM_IO_INTER_BYTES IS NULL
              OR MA.SUM_IO_INTER_BYTES    = MA.SUM_IO_BYTES
              OR MA.SUM_IO_BYTES          = 0
              THEN NULL
              ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(MA.SUM_IO_BYTES / DECODE(MA.SUM_IO_INTER_BYTES, 0, 1, MA.SUM_IO_INTER_BYTES), 2))
            END) )
        END)
      FROM MONITOR_AGG MA
      )
    ELSE NULL
  END)
FROM
  (SELECT
    CASE
      WHEN V1.XPLAN_XML                   IS NULL
      OR V1.XPLAN_XML.EXISTSNODE('/error') > 0
      THEN NULL
      ELSE V1.XPLAN_XML
    END XPLAN_XML
  FROM
    (SELECT
      CASE
        WHEN :B36 = 1
        THEN DBMS_XPLAN.BUILD_PLAN_XML(TABLE_NAME=>'gv$sql_plan', PLAN_TAG=>'plan', FILTER_PREDS=>:B35 , FORMAT=>'+PROJECTION +ALIAS')
        ELSE NULL
      END XPLAN_XML
    FROM DUAL
    ) V1
  ) CONST_VIEW