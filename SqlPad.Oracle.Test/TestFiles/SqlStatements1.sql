select('x')as"x"from(dual"d");
select q'|x|'as"x"from(dual"d");
select(1)"x"from(dual);
select('x')"x"from(dual);
select '--' "/*x"from(dual);
select '/*' "--x"from(dual);
select 'x' "x"from(dual);
select('x')from(dual);
select('x')as"x"from(dual)d;
select('x')as"x"from(dual d);
select('x')as"x"from(dual"d");
select 'x' "x"from(dual);
select/**/1/**/from/**/dual;
select--
1--
from--
dual;
select 'some
--
/*
*/
thin'
from dual;

SELECT
    ROWNUM,
    CASE WHEN ROW_COUNT > 2 THEN NVL(TO_CHAR(SID), 'Total') ELSE TO_CHAR(SID) END SID,
    PARALLEL_SERVERS,
    CPU_SECONDS,
    FETCHES,
    BUFFER_GETS,
    PHYSICAL_READ_REQUESTS,
    PHYSICAL_READS,
    PHYSICAL_READ_MB,
    PHYSICAL_WRITE_REQUESTS,
    DIRECT_WRITES,
    PHYSICAL_WRITE_MB,
    USER_IO_WAIT,
    USER_IO_WAIT_PCT,
    CONCURRENCY_WAIT,
    CONCURRENCY_WAIT_PCT,
    PLSQL_EXEC_TIME,
    PLSQL_EXEC_TIME_PCT
FROM
    (SELECT
        SID,
        PARALLEL_SERVERS,
        COALESCE(CPU_SECONDS, SUM(CPU_SECONDS)) CPU_SECONDS,
        COALESCE(FETCHES, SUM(FETCHES)) FETCHES,
        COALESCE(BUFFER_GETS, SUM(BUFFER_GETS)) BUFFER_GETS,
        COALESCE(PHYSICAL_READ_REQUESTS, SUM(PHYSICAL_READ_REQUESTS)) PHYSICAL_READ_REQUESTS,
        COALESCE(PHYSICAL_READS, SUM(PHYSICAL_READS)) PHYSICAL_READS,
        COALESCE(PHYSICAL_READ_MB, SUM(PHYSICAL_READ_MB)) PHYSICAL_READ_MB,
        COALESCE(PHYSICAL_WRITE_REQUESTS, SUM(PHYSICAL_WRITE_REQUESTS)) PHYSICAL_WRITE_REQUESTS,
        COALESCE(DIRECT_WRITES, SUM(DIRECT_WRITES)) DIRECT_WRITES,
        COALESCE(PHYSICAL_WRITE_MB, SUM(PHYSICAL_WRITE_MB)) PHYSICAL_WRITE_MB,
        COALESCE(USER_IO_WAIT, SUM(USER_IO_WAIT)) USER_IO_WAIT,
        ROUND(USER_IO_WAIT / TOTAL_TIME_PERCENT_BASE, 1) USER_IO_WAIT_PCT,
        COALESCE(CONCURRENCY_WAIT, SUM(CONCURRENCY_WAIT)) CONCURRENCY_WAIT,
        ROUND(CONCURRENCY_WAIT / TOTAL_TIME_PERCENT_BASE, 1) CONCURRENCY_WAIT_PCT,
        COALESCE(PLSQL_EXEC_TIME, SUM(PLSQL_EXEC_TIME)) PLSQL_EXEC_TIME,
        ROUND(PLSQL_EXEC_TIME / TOTAL_TIME_PERCENT_BASE, 1) PLSQL_EXEC_TIME_PCT,
        COUNT(*) OVER () ROW_COUNT
    FROM
        (SELECT
            V$SESSION.SID,
            CPU_TIME / 1000000 CPU_SECONDS,
            FETCHES,
            BUFFER_GETS,
            PHYSICAL_READ_REQUESTS,
            DISK_READS PHYSICAL_READS,
            ROUND(PHYSICAL_READ_BYTES / 1048576) PHYSICAL_READ_MB,
            PHYSICAL_WRITE_REQUESTS,
            DIRECT_WRITES,
            ROUND(PHYSICAL_WRITE_BYTES / 1048576) PHYSICAL_WRITE_MB,
            USER_IO_WAIT_TIME / 1000000 USER_IO_WAIT,
            CONCURRENCY_WAIT_TIME / 1000000 CONCURRENCY_WAIT,
            PLSQL_EXEC_TIME / 1000000 PLSQL_EXEC_TIME,
            NULLIF(SUM(USER_IO_WAIT_TIME + CONCURRENCY_WAIT_TIME + PLSQL_EXEC_TIME) OVER () / 100000000, 0) TOTAL_TIME_PERCENT_BASE,
            CASE
                WHEN PX_SERVERS_REQUESTED IS NOT NULL THEN 'QC ' || PX_SERVERS_ALLOCATED || '/' || PX_SERVERS_REQUESTED
                WHEN PX_SERVER# IS NOT NULL THEN 'Slave ' || PX_SERVER#
                ELSE 'Serial'
            END PARALLEL_SERVERS,
            CASE
                WHEN PX_SERVERS_REQUESTED IS NOT NULL THEN 0
                WHEN PX_SERVER# IS NOT NULL THEN PX_SERVER#
            END SORTORDER
        FROM
            V$SESSION
            JOIN V$SQL_MONITOR
                ON V$SESSION.SID = V$SQL_MONITOR.SID AND V$SESSION.SQL_EXEC_ID = V$SQL_MONITOR.SQL_EXEC_ID AND V$SESSION.SQL_ID = V$SQL_MONITOR.SQL_ID AND V$SQL_MONITOR.STATUS = 'EXECUTING'
            /*LEFT JOIN
            (SELECT SESSION_ID, SQL_EXEC_ID, MAX(EVENT) KEEP (DENSE_RANK FIRST ORDER BY COUNT(*) OVER (PARTITION BY EVENT)) FROM V$ACTIVE_SESSION_HISTORY) ASH
                ON V$SESSION.SID = ASH.SESSION_ID AND V$SQL_MONITOR.SQL_EXEC_ID = ASH.SQL_EXEC_ID*/
        WHERE
            V$SESSION.SID = 184 OR BITAND(V$SESSION.OWNERID, 65535) = 184)
    GROUP BY
        ROLLUP((SID, CPU_SECONDS, FETCHES, BUFFER_GETS, PHYSICAL_READ_REQUESTS, PHYSICAL_READS, PHYSICAL_READ_MB, PHYSICAL_WRITE_REQUESTS, DIRECT_WRITES, PHYSICAL_WRITE_MB, USER_IO_WAIT, ROUND(USER_IO_WAIT / TOTAL_TIME_PERCENT_BASE, 1), CONCURRENCY_WAIT, ROUND(CONCURRENCY_WAIT / TOTAL_TIME_PERCENT_BASE, 1), PLSQL_EXEC_TIME, ROUND(PLSQL_EXEC_TIME / TOTAL_TIME_PERCENT_BASE, 1), PARALLEL_SERVERS, SORTORDER))
    ORDER BY
        SORTORDER) MONITOR_DATA
WHERE
    ROW_COUNT > 2 OR ROWNUM = 1;

WITH MONITOR_DATA AS
  (SELECT INST_ID,
    KEY,
    NVL2(PX_QCSID, NULL, STATUS) STATUS,
    FIRST_REFRESH_TIME,
    LAST_REFRESH_TIME,
    REFRESH_COUNT,
    PROCESS_NAME,
    SID,
    SQL_ID,
    SQL_EXEC_START,
    SQL_EXEC_ID,
    DBOP_NAME,
    DBOP_EXEC_ID,
    SQL_PLAN_HASH_VALUE,
    SESSION_SERIAL#,
    SQL_TEXT,
    IS_FULL_SQLTEXT,
    PX_SERVER#,
    PX_SERVER_GROUP,
    PX_SERVER_SET,
    PX_QCINST_ID,
    PX_QCSID,
    CASE
      WHEN ELAPSED_TIME < (CPU_TIME+ APPLICATION_WAIT_TIME+ CONCURRENCY_WAIT_TIME+ CLUSTER_WAIT_TIME+ USER_IO_WAIT_TIME+ QUEUING_TIME)
      THEN (CPU_TIME               + APPLICATION_WAIT_TIME+ CONCURRENCY_WAIT_TIME+ CLUSTER_WAIT_TIME+ USER_IO_WAIT_TIME+ QUEUING_TIME)
      ELSE ELAPSED_TIME
    END ELAPSED_TIME,
    QUEUING_TIME,
    CPU_TIME,
    APPLICATION_WAIT_TIME,
    CONCURRENCY_WAIT_TIME,
    CLUSTER_WAIT_TIME,
    USER_IO_WAIT_TIME,
    CASE
      WHEN ELAPSED_TIME < (CPU_TIME+ APPLICATION_WAIT_TIME+ CONCURRENCY_WAIT_TIME+ CLUSTER_WAIT_TIME+ USER_IO_WAIT_TIME+ QUEUING_TIME)
      THEN 0
      ELSE ELAPSED_TIME - (CPU_TIME+ APPLICATION_WAIT_TIME+ CONCURRENCY_WAIT_TIME+ CLUSTER_WAIT_TIME+ USER_IO_WAIT_TIME+ QUEUING_TIME)
    END OTHER_WAIT_TIME,
    PLSQL_EXEC_TIME,
    JAVA_EXEC_TIME,
    FETCHES,
    BUFFER_GETS,
    IO_INTERCONNECT_BYTES IO_INTER_BYTES,
    PHYSICAL_READ_REQUESTS READ_REQS,
    PHYSICAL_READ_BYTES READ_BYTES,
    PHYSICAL_WRITE_REQUESTS WRITE_REQS,
    PHYSICAL_WRITE_BYTES WRITE_BYTES,
    NVL(PHYSICAL_READ_BYTES, 0)    + NVL(PHYSICAL_WRITE_BYTES, 0) IO_BYTES,
    NVL(PHYSICAL_READ_REQUESTS, 0) + NVL(PHYSICAL_WRITE_REQUESTS, 0) IO_REQS,
    USER# USERID,
    USERNAME,
    MODULE,
    ACTION,
    SERVICE_NAME,
    CLIENT_IDENTIFIER,
    CLIENT_INFO,
    PROGRAM,
    PLSQL_OBJECT_ID PL_OID,
    PLSQL_SUBPROGRAM_ID PL_PROGID,
    PLSQL_ENTRY_OBJECT_ID PL_ENTRY_OID,
    PLSQL_ENTRY_SUBPROGRAM_ID PL_ENTRY_PROGID,
    PX_MAXDOP MAX_DOP,
    PX_IS_CROSS_INSTANCE,
    PX_MAXDOP_INSTANCES MAX_DOP_INSTANCES,
    PX_SERVERS_REQUESTED SERVERS_REQUESTED,
    PX_SERVERS_ALLOCATED SERVERS_ALLOCATED,
    ERROR_NUMBER,
    ERROR_FACILITY,
    ERROR_MESSAGE,
    NVL2(OTHER_XML, 'Y', NULL) HAS_OTHER_XML,
    NVL2(BINDS_XML, 'Y', NULL) HAS_BINDS_XML,
    NVL2(RM_CONSUMER_GROUP, NVL2(RM_LAST_ACTION_TIME, TO_CHAR(RM_LAST_ACTION_TIME, :B12 ), '00/00/0000 00:00:01')
    || XMLELEMENT( "rminfo", XMLATTRIBUTES( RM_LAST_ACTION AS "rmlastact", RM_LAST_ACTION_REASON AS "rmlastreason", TO_CHAR(RM_LAST_ACTION_TIME, :B12 ) AS "rmlasttime", RM_CONSUMER_GROUP AS "rmcg")).GETSTRINGVAL(), '00/00/0000 00:00:00') RM_INFO,
    CON_NAME,
    CON_ID
  FROM GV$SQL_MONITOR MO1
  WHERE MO1.INST_ID BETWEEN :B11 AND :B10
  AND MO1.SQL_ID          = NVL(:B9 , MO1.SQL_ID)
  AND MO1.SQL_EXEC_START  = NVL(:B8 , MO1.SQL_EXEC_START)
  AND MO1.SQL_EXEC_ID     = NVL(:B7 , MO1.SQL_EXEC_ID)
  OR (MO1.DBOP_NAME       = NVL(:B6 , MO1.DBOP_NAME)
  AND MO1.DBOP_EXEC_ID    = NVL(:B5 , MO1.DBOP_EXEC_ID))
  AND ((:B4               = 1
  AND MO1.PX_QCSID       IS NULL)
  OR (MO1.PX_SERVER_GROUP = NVL(:B3 , MO1.PX_SERVER_GROUP)
  AND MO1.PX_SERVER_SET   = NVL(:B2 , MO1.PX_SERVER_SET)
  AND MO1.PX_SERVER#      = NVL(:B1 , MO1.PX_SERVER#)))
  ),
  MONITOR_AGG AS
  (SELECT MAX_PX_QCSID,
    MAX_KEY,
    MAX_INST_ID,
    MAX_SESSION_ID,
    MAX_SESSION_SERIAL,
    MAX_PX_DOP,
    MAX_PX_DOP_INSTANCES,
    MAX_PX_IS_CROSS_INSTANCE,
    SUM_SERVERS_REQUESTED,
    SUM_SERVERS_ALLOCATED,
    DIST_INST_COUNT,
    DIST_PX_GROUP_COUNT,
    DIST_PX_SET_COUNT,
    MAX_PLAN_HASH_VALUE,
    MAX_USERID,
    MAX_PROGRAM,
    MAX_USERNAME,
    MAX_MODULE,
    MAX_ACTION,
    MAX_SERVICE_NAME,
    MAX_CLIENT_ID,
    MAX_CLIENT_INFO,
    MAX_ERROR_NUMBER,
    MAX_ERROR_FACILITY,
    MAX_ERROR_MESSAGE,
    QC_HAS_OTHER_XML,
    QC_HAS_BINDS_XML,
    MAX_PL_OID,
    MAX_PL_PROGID,
    MAX_PL_ENTRY_OID,
    MAX_PL_ENTRY_PROGID,
    MAX_SQL_ID,
    MAX_SQL_EXEC_START,
    MAX_SQL_EXEC_ID,
    MAX_LAST_REFRESH_TIME,
    MAX_DBOP_NAME,
    MAX_DBOP_EXEC_ID,
    CASE
      WHEN MAX_PL_OID IS NOT NULL
      THEN NVL(
        (SELECT P.OWNER
          || '.'
          || P.OBJECT_NAME
          || DECODE(P.PROCEDURE_NAME, NULL, '', '.'
          || P.PROCEDURE_NAME)
        FROM DBA_PROCEDURES P
        WHERE P.OBJECT_ID   = MAX_PL_OID
        AND P.SUBPROGRAM_ID = MAX_PL_PROGID
        ), 'Unavailable')
    END MAX_PL_NAME,
    CASE
      WHEN MAX_PL_ENTRY_OID IS NOT NULL
      THEN NVL(
        (SELECT P.OWNER
          || '.'
          || P.OBJECT_NAME
          || DECODE(P.PROCEDURE_NAME, NULL, '', '.'
          || P.PROCEDURE_NAME)
        FROM DBA_PROCEDURES P
        WHERE P.OBJECT_ID   = MAX_PL_ENTRY_OID
        AND P.SUBPROGRAM_ID = MAX_PL_ENTRY_PROGID
        ), 'Unavailable')
    END MAX_PL_ENTRY_NAME,
    MAX_STATUS,
    SUM_REFRESH_COUNT,
    MIN_FIRST_REFRESH_TIME,
    IS_FULL_TEXT,
    SQLMON_TEXT,
    SUM_ELAPSED_TIME,
    MAX_ELAPSED_TIME,
    MAX_QUEUING_TIME,
    SUM_CPU_TIME,
    SUM_USER_IO_WAIT_TIME,
    SUM_APPLICATION_WAIT_TIME,
    SUM_CONCURRENCY_WAIT_TIME,
    SUM_CLUSTER_WAIT_TIME,
    SUM_PLSQL_EXEC_TIME,
    SUM_JAVA_EXEC_TIME,
    SUM_OTHER_WAIT_TIME,
    SUM_FETCHES,
    SUM_BUFFER_GETS,
    SUM_READ_REQS,
    SUM_READ_BYTES,
    SUM_WRITE_REQS,
    SUM_WRITE_BYTES,
    SUM_IO_BYTES,
    SUM_IO_INTER_BYTES,
    DECODE(:B14 , 1, 'db_name', DB.DB_UNIQUE_NAME) DB_UNIQUE_NAME,
    DECODE(:B14 , 1, 'platform_name', DB.PLATFORM_NAME) PLATFORM_NAME,
    DECODE(:B14 , 1, 'host_name', INST.HOST_NAME) HOST_NAME,
    AGG_RM_INFO MAX_RM_INFO,
    MAX_CON_NAME,
    DECODE(MAX_CON_ID, 0, NULL, MAX_CON_ID) MAX_CON_ID
  FROM
    (SELECT MAX(PX_QCSID) MAX_PX_QCSID,
      MAX(
      CASE
        WHEN PX_QCSID IS NULL
        THEN KEY
        ELSE NULL
      END) MAX_KEY,
      MAX(
      CASE
        WHEN PX_QCSID IS NULL
        THEN INST_ID
        ELSE NULL
      END) MAX_INST_ID,
      MAX(
      CASE
        WHEN PX_QCSID IS NULL
        THEN SID
        ELSE NULL
      END) MAX_SESSION_ID,
      MAX(
      CASE
        WHEN PX_QCSID IS NULL
        THEN SESSION_SERIAL#
        ELSE NULL
      END) MAX_SESSION_SERIAL,
      MAX(MAX_DOP) MAX_PX_DOP,
      MAX(MAX_DOP_INSTANCES) MAX_PX_DOP_INSTANCES,
      MAX(PX_IS_CROSS_INSTANCE) MAX_PX_IS_CROSS_INSTANCE,
      SUM(SERVERS_REQUESTED) SUM_SERVERS_REQUESTED,
      SUM(SERVERS_ALLOCATED) SUM_SERVERS_ALLOCATED,
      COUNT(DISTINCT INST_ID) DIST_INST_COUNT,
      COUNT(DISTINCT PX_SERVER_GROUP) DIST_PX_GROUP_COUNT,
      COUNT(DISTINCT PX_SERVER_SET) DIST_PX_SET_COUNT,
      MAX(SQL_PLAN_HASH_VALUE) MAX_PLAN_HASH_VALUE,
      MAX(USERID) MAX_USERID,
      MAX(PROGRAM) MAX_PROGRAM,
      MAX(USERNAME) MAX_USERNAME,
      MAX(MODULE) MAX_MODULE,
      MAX(ACTION) MAX_ACTION,
      MAX(SERVICE_NAME) MAX_SERVICE_NAME,
      MAX(CLIENT_IDENTIFIER) MAX_CLIENT_ID,
      MAX(CLIENT_INFO) MAX_CLIENT_INFO,
      MAX(ERROR_NUMBER) MAX_ERROR_NUMBER,
      MAX(ERROR_FACILITY) MAX_ERROR_FACILITY,
      MAX(ERROR_MESSAGE) MAX_ERROR_MESSAGE,
      MAX(NVL2(PX_QCSID, HAS_OTHER_XML, NULL)) QC_HAS_OTHER_XML,
      MAX(HAS_BINDS_XML) QC_HAS_BINDS_XML,
      MAX(PL_OID) MAX_PL_OID,
      MAX(PL_PROGID) MAX_PL_PROGID,
      MAX(PL_ENTRY_OID) MAX_PL_ENTRY_OID,
      MAX(PL_ENTRY_PROGID) MAX_PL_ENTRY_PROGID,
      MAX(SQL_ID) MAX_SQL_ID,
      MAX(SQL_EXEC_START) MAX_SQL_EXEC_START,
      MAX(SQL_EXEC_ID) MAX_SQL_EXEC_ID,
      MAX(LAST_REFRESH_TIME) MAX_LAST_REFRESH_TIME,
      MAX(STATUS) MAX_STATUS,
      SUM(REFRESH_COUNT) SUM_REFRESH_COUNT,
      MIN(FIRST_REFRESH_TIME) MIN_FIRST_REFRESH_TIME,
      MAX(DBOP_NAME) MAX_DBOP_NAME,
      MAX(DBOP_EXEC_ID) MAX_DBOP_EXEC_ID,
      CASE
        WHEN :B13 = 0
        THEN NULL
        ELSE MAX(SQL_TEXT)
      END SQLMON_TEXT,
      MAX(IS_FULL_SQLTEXT) IS_FULL_TEXT,
      SUM(ELAPSED_TIME) SUM_ELAPSED_TIME,
      MAX(ELAPSED_TIME) MAX_ELAPSED_TIME,
      MAX(QUEUING_TIME) MAX_QUEUING_TIME,
      SUM(CPU_TIME) SUM_CPU_TIME,
      SUM(USER_IO_WAIT_TIME) SUM_USER_IO_WAIT_TIME,
      SUM(APPLICATION_WAIT_TIME) SUM_APPLICATION_WAIT_TIME,
      SUM(CONCURRENCY_WAIT_TIME) SUM_CONCURRENCY_WAIT_TIME,
      SUM(CLUSTER_WAIT_TIME) SUM_CLUSTER_WAIT_TIME,
      SUM(PLSQL_EXEC_TIME) SUM_PLSQL_EXEC_TIME,
      SUM(JAVA_EXEC_TIME) SUM_JAVA_EXEC_TIME,
      SUM(OTHER_WAIT_TIME) SUM_OTHER_WAIT_TIME,
      SUM(FETCHES) SUM_FETCHES,
      SUM(BUFFER_GETS) SUM_BUFFER_GETS,
      SUM(READ_REQS) SUM_READ_REQS,
      SUM(READ_BYTES) SUM_READ_BYTES,
      SUM(WRITE_REQS) SUM_WRITE_REQS,
      SUM(WRITE_BYTES) SUM_WRITE_BYTES,
      NVL(SUM(READ_BYTES), 0) + NVL(SUM(WRITE_BYTES), 0) SUM_IO_BYTES,
      SUM(IO_INTER_BYTES) SUM_IO_INTER_BYTES,
      MAX(RM_INFO) AGG_RM_INFO,
      MAX(CON_NAME) MAX_CON_NAME,
      MAX(CON_ID) MAX_CON_ID
    FROM MONITOR_DATA
    ) MD,
    (SELECT HOST_NAME FROM V$INSTANCE
    ) INST,
    (SELECT DB_UNIQUE_NAME, PLATFORM_NAME FROM V$DATABASE
    ) DB
  ),
  ASH_DATA AS
  (SELECT AD0.INST_ID,
    AD0.SESSION_ID,
    AD0.PLAN_LINE_ID,
    AD0.PLSQL_OBJECT_ID,
    AD0.PLSQL_SUBPROGRAM_ID,
    AD0.ACTIVITY_BUCKET_NUM,
    AD0.PLAN_ACTIVITY_BUCKET_NUM,
    AD0.SQL,
    AD0.TOP_LEVEL_SQL_ID,
    AD0.DBOP_NAME,
    AD0.IS_MONITORED_SQL,
    AD0.IS_PX_SLAVE,
    AD0.BUCKET_ACTIVITY_START,
    AD0.ACTIVITY_START,
    AD0.BUCKET_ACTIVITY_END,
    AD0.ACTIVITY_END,
    AD0.ACTIVITY_COUNT,
    AD0.ACTIVITY_TYPE,
    AD0.OTHER_SQL_ACTIVITY_TYPE,
    AD0.EVENT_NAME,
    AD0.WAIT_COUNT,
    AD0.CPU_COUNT,
    AD0.OTHER_SQL_COUNT,
    AD0.PX_SERVER_SET,
    AD0.PX_DFO_ACTIVITY_COUNT,
    AD0.DFO_MOST_ACTIVE_IID,
    AD0.DFO_MOST_ACTIVE_SID,
    (
    CASE
      WHEN AD0.DFO_MOST_ACTIVE_IID                                   = AD0.INST_ID
      AND AD0.DFO_MOST_ACTIVE_SID                                    = AD0.SESSION_ID
      AND (((AD0.PX_DFO_ACTIVITY_COUNT / AD0.DFO_MOST_ACTIVE_COUNT) >= AD0.PX_DOP * 1.05)
      OR ((AD0.PX_DFO_ACTIVITY_COUNT   / AD0.DFO_MOST_ACTIVE_COUNT) <= AD0.PX_DOP *0.95))
      AND (AD0.DFO_DURATION            * 100)                        > :B32
      THEN AD0.ACTIVITY_COUNT
      ELSE NULL
    END) DFO_MOST_ACTIVE_COUNT,
    AD0.BUCKET_DISTINCT_SAMPLES,
    AD0.SQL_BUCKET_DISTINCT_SAMPLES,
    CASE
      WHEN AD0.PX_SERVER_GROUP IS NULL
      AND AD0.IS_PX_SLAVE       = 1
      THEN 1
      ELSE AD0.PX_SERVER_GROUP
    END PX_SERVER_GROUP,
    AD0.PX_STEP_ID,
    AD0.PX_DFO_PAIR_TYPE,
    AD0.PX_DFO_PAIR_ID,
    AD0.PX_STEP_ARG,
    AD0.PX_DOP,
    CASE
      WHEN AD0.PX_DOP    IS NOT NULL
      AND AD0.PX_DOP     <> AD0.PX_MIN_DOP
      AND AD0.PX_MIN_DOP != 0
      THEN PX_MIN_DOP
      ELSE NULL
    END PX_MIN_DOP
  FROM
    (SELECT
      /*+ use_hash(ash) leading(mo) */
      ASH.INST_ID,
      ASH.IS_PX_SLAVE,
      ASH.SESSION_ID,
      ASH.PLAN_LINE_ID,
      ASH.PLSQL_OBJECT_ID,
      ASH.PLSQL_SUBPROGRAM_ID,
      ASH.ACTIVITY_BUCKET_NUM,
      ASH.PLAN_ACTIVITY_BUCKET_NUM,
      ASH.SQL,
      ASH.TOP_LEVEL_SQL_ID,
      ASH.DBOP_NAME,
      ASH.IS_MONITORED_SQL,
      ASH.BUCKET_ACTIVITY_START,
      ASH.ACTIVITY_START,
      ASH.BUCKET_ACTIVITY_END,
      ASH.ACTIVITY_END,
      ASH.ACTIVITY_COUNT,
      ASH.ACTIVITY_TYPE,
      ASH.OTHER_SQL_ACTIVITY_TYPE,
      ASH.EVENT_NAME,
      ASH.WAIT_COUNT,
      ASH.CPU_COUNT,
      ASH.OTHER_SQL_COUNT,
      MO.PX_SERVER_SET,
      ASH.PX_DFO_ACTIVITY_COUNT,
      TRUNC(ASH.MOST_ACTIVE_IN_DFO     / 10000000000) DFO_MOST_ACTIVE_COUNT,
      MOD(TRUNC(ASH.MOST_ACTIVE_IN_DFO / 1000000), 10000) DFO_MOST_ACTIVE_IID,
      MOD(ASH.MOST_ACTIVE_IN_DFO, 1000000) DFO_MOST_ACTIVE_SID,
      ASH.DFO_DURATION,
      ASH.BUCKET_DISTINCT_SAMPLES,
      ASH.SQL_BUCKET_DISTINCT_SAMPLES,
      MO.PX_SERVER_GROUP,
      ASH.PX_STEP_ID,
      ASH.PX_DFO_PAIR_TYPE,
      ASH.PX_DFO_PAIR_ID,
      ASH.PX_STEP_ARG,
      ASH.PX_DOP,
      ASH.PX_MIN_DOP
    FROM
      (SELECT
        /*+ no_merge */
        MD.INST_ID,
        MD.SID,
        MD.SESSION_SERIAL#,
        MD.PX_SERVER_SET,
        MD.PX_SERVER_GROUP
      FROM MONITOR_DATA MD
      WHERE MD.SID IS NOT NULL
      OR :B31       = 1
      ) MO,
      (SELECT
        /*+ no_merge */
        GVTF.INST_ID,
        GVTF.GLOBAL_SAMPLE_ID,
        GVTF.IS_PX_SLAVE,
        GVTF.SESSION_ID,
        GVTF.PLAN_LINE_ID,
        GVTF.PLSQL_OBJECT_ID,
        GVTF.PLSQL_SUBPROGRAM_ID,
        GVTF.ACTIVITY_BUCKET_NUM,
        GVTF.PLAN_ACTIVITY_BUCKET_NUM,
        GVTF.SQL,
        GVTF.TOP_LEVEL_SQL_ID,
        GVTF.DBOP_NAME,
        GVTF.IS_MONITORED_SQL,
        GVTF.BUCKET_ACTIVITY_START,
        GVTF.ACTIVITY_START,
        GVTF.BUCKET_ACTIVITY_END,
        GVTF.ACTIVITY_END,
        GVTF.ACTIVITY_COUNT,
        GVTF.ACTIVITY_TYPE,
        GVTF.OTHER_SQL_ACTIVITY_TYPE,
        GVTF.EVENT_NAME,
        GVTF.WAIT_COUNT,
        GVTF.CPU_COUNT,
        GVTF.OTHER_SQL_COUNT,
        MAX(GVTF.PER_SERVER_DFO_COUNT * 10000000000 + GVTF.INST_ID * 1000000 + GVTF.SESSION_ID) OVER(PARTITION BY GVTF.PX_DFO_PAIR_TYPE, GVTF.PX_DFO_PAIR_ID) MOST_ACTIVE_IN_DFO,
        SUM(GVTF.ACTIVITY_COUNT) OVER(PARTITION BY GVTF.PX_DFO_PAIR_TYPE, GVTF.PX_DFO_PAIR_ID) PX_DFO_ACTIVITY_COUNT,
        GVTF.DFO_DURATION,
        GVTF.PX_STEP_ID,
        GVTF.PX_DFO_PAIR_TYPE,
        GVTF.PX_DFO_PAIR_ID,
        GVTF.PX_STEP_ARG,
        GVTF.PX_DOP,
        GVTF.PX_MIN_DOP,
        COUNT(DISTINCT GVTF.GLOBAL_SAMPLE_ID) OVER(PARTITION BY GVTF.ACTIVITY_BUCKET_NUM) BUCKET_DISTINCT_SAMPLES,
        COUNT(DISTINCT GVTF.GLOBAL_SAMPLE_ID) OVER(PARTITION BY GVTF.SQL, GVTF.ACTIVITY_BUCKET_NUM) SQL_BUCKET_DISTINCT_SAMPLES
      FROM TABLE(GV$(CURSOR(
        (SELECT USERENV('INSTANCE') INST_ID,
          ASH2.GLOBAL_SAMPLE_ID,
          CASE
            WHEN :B30 = 1
            AND :B27  > 1
            THEN BUCKET_NUM
            ELSE NULL
          END ACTIVITY_BUCKET_NUM,
          CASE
            WHEN :B29 = 1
            AND :B27  > 1
            THEN BUCKET_NUM
            ELSE NULL
          END PLAN_ACTIVITY_BUCKET_NUM,
          ASH2.SQL,
          ASH2.TOP_LEVEL_SQL_ID,
          ASH2.DBOP_NAME,
          ASH2.IS_MONITORED_SQL,
          ASH2.PLAN_LINE_ID,
          ASH2.PLSQL_OBJECT_ID,
          ASH2.PLSQL_SUBPROGRAM_ID,
          ASH2.ACTIVITY_TYPE,
          ASH2.OTHER_SQL_ACTIVITY_TYPE,
          ASH2.EVENT_NAME,
          ASH2.IS_PX_SLAVE,
          ASH2.SESSION_ID,
          ASH2.PX_STEP_ID,
          ASH2.PX_DFO_PAIR_TYPE,
          ASH2.PX_DFO_PAIR_ID,
          ASH2.PX_STEP_ARG,
          CASE
            WHEN ASH2.PX_DFO_PAIR_ID IS NOT NULL
            THEN DECODE(ASH2.PX_DOP, 0, :B28 , ASH2.PX_DOP)
            ELSE NULL
          END PX_DOP,
          ASH2.PX_MIN_DOP,
          :B20 + NUMTODSINTERVAL(:B26 * (ASH2.BUCKET_NUM-1), 'SECOND') BUCKET_ACTIVITY_START,
          :B20 + NUMTODSINTERVAL( :B26 * ASH2.BUCKET_NUM - 1, 'SECOND') BUCKET_ACTIVITY_END,
          ASH2.ACTIVITY_START,
          ASH2.ACTIVITY_END,
          ASH2.ACTIVITY_COUNT,
          ASH2.WAIT_COUNT,
          ASH2.CPU_COUNT,
          ASH2.OTHER_SQL_COUNT,
          SUM(ASH2.ACTIVITY_COUNT) OVER(PARTITION BY ASH2.PX_DFO_PAIR_ID, ASH2.PX_DFO_PAIR_TYPE, DECODE(ASH2.PX_DFO_PAIR_ID, NULL, NULL, ASH2.SESSION_ID)) PER_SERVER_DFO_COUNT,
          CEIL((MAX(ASH2.MAX_SAMPLE_DATE) OVER(PARTITION BY ASH2.PX_DFO_PAIR_ID, ASH2.PX_DFO_PAIR_TYPE) - MIN(ASH2.MIN_SAMPLE_DATE) OVER(PARTITION BY ASH2.PX_DFO_PAIR_ID, ASH2.PX_DFO_PAIR_TYPE)) * 3600 * 24) DFO_DURATION
        FROM
          (SELECT ASH1.BUCKET_NUM,
            ASH1.GLOBAL_SAMPLE_ID,
            ASH1.PLAN_LINE_ID,
            ASH1.PLSQL_OBJECT_ID,
            ASH1.PLSQL_SUBPROGRAM_ID,
            ASH1.ACTIVITY_TYPE,
            ASH1.OTHER_SQL_ACTIVITY_TYPE,
            ASH1.EVENT_NAME,
            ASH1.SESSION_ID,
            ASH1.PX_STEP_ID,
            ASH1.PX_STEP_ARG,
            MAX(ASH1.SQL) SQL,
            MAX(ASH1.IS_MONITORED_SQL) IS_MONITORED_SQL,
            MAX(ASH1.PX_DFO_PAIR_TYPE) PX_DFO_PAIR_TYPE,
            MAX(ASH1.PX_DFO_PAIR_ID) PX_DFO_PAIR_ID,
            MIN(SAMPLE_DATE) MIN_SAMPLE_DATE,
            MAX(SAMPLE_DATE) MAX_SAMPLE_DATE,
            MAX(ASH1.IS_PX_SLAVE) IS_PX_SLAVE,
            MAX(ASH1.PX_DOP) PX_DOP,
            MIN(ASH1.PX_DOP) PX_MIN_DOP,
            MIN(ASH1.SAMPLE_DATE) ACTIVITY_START,
            MAX(ASH1.SAMPLE_DATE) ACTIVITY_END,
            COUNT(ASH1.SQL) ACTIVITY_COUNT,
            COUNT(
            CASE
              WHEN ASH1.ACTIVITY_TYPE != 'Other SQL Execution'
              AND ASH1.ACTIVITY_TYPE  != 'Non SQL'
              AND ASH1.ACTIVITY_TYPE  != 'Cpu'
              THEN 1
              ELSE NULL
            END) WAIT_COUNT,
            COUNT(
            CASE
              WHEN ASH1.ACTIVITY_TYPE = 'Cpu'
              THEN 1
              ELSE NULL
            END) CPU_COUNT,
            COUNT(
            CASE
              WHEN ASH1.ACTIVITY_TYPE = 'Other SQL Execution'
              AND ASH1.ACTIVITY_TYPE != 'Non SQL'
              THEN 1
              ELSE NULL
            END) OTHER_SQL_COUNT,
            MAX(ASH1.TOP_LEVEL_SQL_ID) TOP_LEVEL_SQL_ID,
            MAX(ASH1.DBOP_NAME) DBOP_NAME
          FROM
            (SELECT (
              CASE
                WHEN :B27 > 1
                THEN (TRUNC(DELTA_TIME_SECONDS/ :B26 ) + 1)
                ELSE 1
              END) BUCKET_NUM,
              ASH00.SQL,
              ASH00.SAMPLE_DATE,
              NVL2(DUP.C2, TRUNC(DELTA_TIME_SECONDS/ (:B25 )) + 1, NULL) GLOBAL_SAMPLE_ID,
              NVL2(DUP.C2, NULL, ASH00.IS_MONITORED_SQL) IS_MONITORED_SQL,
              NVL2(DUP.C2, NULL, ASH00.WAIT_CLASS) WAIT_CLASS,
              NVL2(DUP.C2, NULL, ASH00.ACTIVITY_TYPE) ACTIVITY_TYPE,
              NVL2(DUP.C2, NULL, ASH00.OTHER_SQL_ACTIVITY_TYPE) OTHER_SQL_ACTIVITY_TYPE,
              NVL2(DUP.C2, NULL, ASH00.EVENT_NAME) EVENT_NAME,
              NVL2(DUP.C2, NULL, ASH00.TOP_LEVEL_SQL_ID) TOP_LEVEL_SQL_ID,
              NVL2(DUP.C2, NULL, ASH00.DBOP_NAME) DBOP_NAME,
              NVL2(DUP.C2, NULL, ASH00.IS_PX_SLAVE) IS_PX_SLAVE,
              NVL2(DUP.C2, NULL, ASH00.SESSION_ID) SESSION_ID,
              NVL2(DUP.C2, NULL, ASH00.PLSQL_OBJECT_ID) PLSQL_OBJECT_ID,
              NVL2(DUP.C2, NULL, ASH00.PLSQL_SUBPROGRAM_ID) PLSQL_SUBPROGRAM_ID,
              NVL2(DUP.C2, NULL, ASH00.PLAN_LINE_ID) PLAN_LINE_ID,
              NVL2(DUP.C2, NULL, ASH00.PX_STEP_ID) PX_STEP_ID,
              NVL2(DUP.C2, NULL, ASH00.PX_STEP_ARG) PX_STEP_ARG,
              NVL2(DUP.C2, NULL, ASH00.PX_DFO_PAIR_ID) PX_DFO_PAIR_ID,
              NVL2(DUP.C2, NULL, ASH00.PX_DFO_PAIR_TYPE) PX_DFO_PAIR_TYPE,
              NVL2(DUP.C2, NULL, ASH00.PX_DOP) PX_DOP
            FROM
              (SELECT 1 C1, NULL C2 FROM V$TIMER
              UNION ALL
              SELECT 1 C1, 1 C2 FROM V$TIMER
              ) DUP,
              (SELECT
                /*+ no_merge */
                1 C1,
                ASH000.SAMPLE_DATE,
                ASH000.IS_MONITORED_SQL,
                ((EXTRACT(SECOND FROM(DELTA_TIME)) + EXTRACT(MINUTE FROM(DELTA_TIME)) * 60 + EXTRACT(HOUR FROM(DELTA_TIME)) * 3600 + EXTRACT(DAY FROM(DELTA_TIME)) * 86400)) DELTA_TIME_SECONDS,
                ASH000.WAIT_CLASS,
                DECODE(ASH000.IS_MONITORED_SQL, 1, NVL(ASH000.WAIT_CLASS, 'Cpu'), DECODE(SQL_ID, NULL, 'Non SQL', 'Other SQL Execution')) ACTIVITY_TYPE,
                NVL(ASH000.WAIT_CLASS, 'Cpu') OTHER_SQL_ACTIVITY_TYPE,
                DECODE(:B24 , 1,
                CASE
                  WHEN ASH000.IS_MONITORED_SQL = 1
                  THEN ASH000.EVENT
                  WHEN ASH000.SQL_ID IS NOT NULL
                  THEN 'sql_id: '
                    || ASH000.SQL_ID
                  WHEN ASH000.CALL_NAME IS NOT NULL
                  THEN 'call: '
                    || ASH000.CALL_NAME
                  ELSE 'anonymous: '
                    || ASH000.EVENT
                END, NULL) EVENT_NAME,
                CASE
                  WHEN ASH000.IS_MONITORED_SQL   = 1
                  AND (NVL(ASH000.SQL_ID, :B9 )  = :B9
                  OR NVL(ASH000.DBOP_NAME, :B6 ) = :B6 )
                  THEN 'this'
                  WHEN ASH000.IS_PX_SLAVE      = 1
                  AND ASH000.SQL_ID           IS NOT NULL
                  AND ASH000.TOP_LEVEL_SQL_ID != ASH000.SQL_ID
                  THEN ASH000.TOP_LEVEL_SQL_ID
                  WHEN ASH000.SQL_ID IS NOT NULL
                  THEN ASH000.SQL_ID
                  ELSE NVL(CALL_NAME, 'anonymous')
                END SQL,
                CASE
                  WHEN ASH000.IS_PX_SLAVE     = 0
                  AND (ASH000.SQL_ID         IS NULL
                  OR ASH000.TOP_LEVEL_SQL_ID != ASH000.SQL_ID)
                  THEN ASH000.TOP_LEVEL_SQL_ID
                END TOP_LEVEL_SQL_ID,
                ASH000.DBOP_NAME,
                ASH000.IS_PX_SLAVE,
                CASE
                  WHEN ASH000.IS_PX_SLAVE      = 1
                  AND ASH000.IS_MONITORED_SQL != 1
                  THEN 65536
                  ELSE ASH000.SESSION_ID
                END SESSION_ID,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PLSQL_OBJECT_ID, NULL) PLSQL_OBJECT_ID,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PLSQL_SUBPROGRAM_ID, NULL) PLSQL_SUBPROGRAM_ID,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.SQL_PLAN_LINE_ID, NULL) PLAN_LINE_ID,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PX_STEP_ID, NULL) PX_STEP_ID,
                CASE
                  WHEN ASH000.IS_PX_SLAVE     = 1
                  AND ASH000.IS_MONITORED_SQL = 1
                  AND ASH000.PX_STEP_ID      IN (1, 2, 3)
                  THEN ASH000.PX_STEP_ARG
                  ELSE NULL
                END PX_DFO_PAIR_ID,
                CASE
                  WHEN ASH000.IS_PX_SLAVE     = 0
                  OR ASH000.IS_MONITORED_SQL != 1
                  THEN NULL
                  WHEN ASH000.PX_STEP_ID = 1
                  THEN 1
                  WHEN ASH000.PX_STEP_ID IN (2, 3)
                  THEN 0
                  ELSE NULL
                END PX_DFO_PAIR_TYPE,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PX_STEP_ARG, NULL) PX_STEP_ARG,
                DECODE(ASH000.IS_MONITORED_SQL, 1, ASH000.PX_DOP, NULL) PX_DOP
              FROM
                (SELECT ASH0.*,
                  CASE
                    WHEN ASH0.IS_TARGET_SQL                        = 1
                    OR (ASH0.IS_PX_SLAVE                           = 1
                    AND ((NVL(ASH0.TOP_LEVEL_SQL_ID, ASH0.SQL_ID) IS NOT NULL
                    AND NVL(ASH0.TOP_LEVEL_SQL_ID, ASH0.SQL_ID)    = :B9 )
                    OR (SQL_ID                                    IS NULL
                    AND :B23                                       = 'Y')))
                    THEN 1
                    ELSE 0
                  END IS_MONITORED_SQL
                FROM
                  (SELECT (
                    CASE
                      WHEN (ASH.SQL_ID       = :B9
                      AND ASH.SQL_EXEC_ID    = :B7
                      AND ASH.SQL_EXEC_START = :B8 )
                      THEN 1
                      ELSE 0
                    END) IS_TARGET_SQL,
                    ASH.SQL_ID,
                    ASH.SQL_PLAN_LINE_ID,
                    ASH.PLSQL_OBJECT_ID,
                    ASH.PLSQL_SUBPROGRAM_ID,
                    ASH.TOP_LEVEL_SQL_ID,
                    DECODE(ASH.SQL_ID, NULL, ASH.TOP_LEVEL_CALL_NAME, NULL) CALL_NAME,
                    ASH.EVENT,
                    ASH.WAIT_CLASS,
                    ASH.SQL_EXEC_ID,
                    ASH.SQL_EXEC_START,
                    ASH.DBOP_NAME,
                    ASH.DBOP_EXEC_ID,
                    ASH.SESSION_ID,
                    ASH.SESSION_SERIAL#,
                    CASE
                      WHEN QC_INSTANCE_ID    IS NOT NULL
                      AND (ASH.SESSION_ID    != ASH.QC_SESSION_ID
                      OR ASH.SESSION_SERIAL# != ASH.QC_SESSION_SERIAL#
                      OR USERENV('instance') != ASH.QC_INSTANCE_ID)
                      THEN 1
                      ELSE 0
                    END IS_PX_SLAVE,
                    SAMPLE_TIME - CAST(:B20 AS                   TIMESTAMP) DELTA_TIME,
                    CAST(FROM_TZ(ASH.SAMPLE_TIME, DBTIMEZONE) AS DATE) SAMPLE_DATE,
                    TRUNC(MOD(PX_FLAGS/65536, 32)) PX_STEP_ID,
                    MOD(PX_FLAGS, 65536) PX_STEP_ARG,
                    TRUNC(PX_FLAGS/2097152) PX_DOP
                  FROM V$ACTIVE_SESSION_HISTORY ASH
                  WHERE ((ASH.SESSION_ID     = :B19
                  AND ASH.SESSION_SERIAL#    = :B18
                  AND USERENV('INSTANCE')    = :B17 )
                  OR (ASH.QC_SESSION_ID     IS NOT NULL
                  AND ASH.QC_SESSION_ID      = :B19
                  AND ASH.QC_SESSION_SERIAL# = :B18
                  AND ASH.QC_INSTANCE_ID     = :B17 ))
                  AND SAMPLE_TIME BETWEEN :B16 AND :B15
                  ) ASH0
                WHERE (ASH0.SAMPLE_DATE BETWEEN :B20 + 1/24/3600 AND :B22 - 1/24/3600
                OR (ASH0.SQL_ID          = :B9
                AND ASH0.SQL_EXEC_START  = :B8
                AND ASH0.SQL_EXEC_ID     = :B7 )
                OR (ASH0.DBOP_NAME       = :B6
                AND ASH0.DBOP_EXEC_ID    = :B5 ))
                AND (:B21               IS NULL
                OR ASH0.SQL_PLAN_LINE_ID = :B21 )
                AND (ASH0.IS_PX_SLAVE    = 0
                OR ASH0.SQL_ID          IS NOT NULL)
                ) ASH000
              ) ASH00
            WHERE ASH00.C1 = DUP.C1
            ) ASH1
          WHERE ASH1.BUCKET_NUM > 0
          AND ASH1.BUCKET_NUM  <= :B27
          GROUP BY USERENV('INSTANCE'),
            ASH1.GLOBAL_SAMPLE_ID,
            ASH1.BUCKET_NUM,
            ASH1.SESSION_ID,
            ASH1.PLAN_LINE_ID,
            ASH1.PLSQL_OBJECT_ID,
            ASH1.PLSQL_SUBPROGRAM_ID,
            ASH1.ACTIVITY_TYPE,
            ASH1.EVENT_NAME,
            ASH1.OTHER_SQL_ACTIVITY_TYPE,
            ASH1.PX_STEP_ID,
            ASH1.PX_STEP_ARG
          ) ASH2
        )))) GVTF
      WHERE GVTF.INST_ID BETWEEN :B11 AND :B10
      ) ASH
    WHERE ASH.GLOBAL_SAMPLE_ID IS NULL
    AND ASH.SESSION_ID          = MO.SID(+)
    AND ASH.INST_ID             = MO.INST_ID(+)
    ) AD0
  ),
  RESPONSE_TIME_DATA AS
  (SELECT ADH.BUCKET_NUM,
    ADH.SQL_ROWNUM,
    ADH.SQL,
    ADH.TOP_LEVEL_SQL_ID,
    ADH.DBOP_NAME,
    ADH.PX_ID,
    DECODE( ADH.PX_STEP_ID, NULL, NULL, 0, NULL, 1, 'PX Server(s) - Executing Parent DFO', 2, 'PX Server(s) - Executing Child DFO', 3, 'PX Server(s) - Sampling Child DFO', 4, 'PX Server(s) - Joining Group', 5, 'QC - Scheduling Child DFO', 6, 'QC - Scheduling Parent DFO', 7, 'QC - Initializing Objects', 8, 'QC - Flushing Objects', 9, 'QC - Allocating Slaves', 10, 'QC - Initializing Granules', 11, 'PX Server(s) - Parsing Cursor', 12, 'PX Server(s) - Executing Cursor', 13, 'PX Server(s) - Preparing Transaction', 14, 'PX Server(s) - Joining Transaction', 15, 'PX Server(s) - Load Commit', 16, 'PX Server(s) - Aborting Transaction', 17, 'QC - Executing Child DFO', 18, 'QC - Executing Parent DFO', 'PX Step - '
    || PX_STEP_ID) PX_STEP_ID,
    ADH.PX_STEP_ARG,
    ADH.PX_DFO_PAIR_ID,
    ADH.PX_DOP,
    ADH.PX_MIN_DOP,
    ADH.DFO_MOST_ACTIVE_IID,
    ADH.DFO_MOST_ACTIVE_SID,
    ADH.DFO_MOST_ACTIVE_COUNT,
    ADH.ACTIVITY_START,
    ADH.ACTIVITY_END,
    ADH.ACTIVITY_TYPE,
    ADH.OTHER_SQL_ACTIVITY_TYPE,
    ADH.EVENT_NAME,
    ADH.PLAN_LINE_ID,
    ADH.PLSQL_OBJECT_ID,
    ADH.PLSQL_SUBPROGRAM_ID,
    CASE
      WHEN PLSQL_ROWNUM        = 1
      AND ADH.PLSQL_OBJECT_ID IS NOT NULL
      THEN NVL(
        (SELECT P.OWNER
          || '.'
          || P.OBJECT_NAME
          || DECODE(P.PROCEDURE_NAME, NULL, '', '.'
          || P.PROCEDURE_NAME)
        FROM DBA_PROCEDURES P
        WHERE P.OBJECT_ID   = ADH.PLSQL_OBJECT_ID
        AND P.SUBPROGRAM_ID = ADH.PLSQL_SUBPROGRAM_ID
        ), 'Unavailable')
      ELSE NULL
    END PLSQL_NAME,
    ADH.ACTIVITY_COUNT,
    ADH.BUCKET_ACTIVE_SECONDS,
    ADH.BUCKET_IDLE_SECONDS,
    (
    CASE
      WHEN ADH.IS_MONITORED_SQL = 0
      THEN ADH.ACTIVE_SECONDS
      WHEN ADH.PX_DFO_PAIR_ID     IS NOT NULL
      AND ADH.DFO_PAIR_CPU_HEIGHT >= :B34
      THEN DECODE(ADH.ACTIVITY_TYPE, 'Cpu', (ADH.DFO_PAIR_ACTIVITY_HEIGHT / ADH.DFO_PAIR_CPU_HEIGHT) * ADH.DFO_PAIR_TOTAL_SECONDS, 0)
      WHEN ADH.PX_DFO_PAIR_ID IS NOT NULL
      AND ADH.PX_DOP           > :B34
      THEN (ADH.DFO_PAIR_TOTAL_SECONDS * DECODE(ADH.ACTIVITY_TYPE, 'Cpu', ADH.DFO_PAIR_ACTIVITY_HEIGHT, (ADH.DFO_PAIR_ACTIVITY_HEIGHT * (:B34 - ADH.DFO_PAIR_CPU_HEIGHT)) / (ADH.DFO_PAIR_TOTAL_HEIGHT_ADJ - ADH.DFO_PAIR_CPU_HEIGHT))) / :B34
      WHEN ADH.PX_DFO_PAIR_ID IS NOT NULL
      THEN (ADH.DFO_PAIR_TOTAL_SECONDS * ADH.DFO_PAIR_ACTIVITY_HEIGHT) / ADH.PX_DOP
      ELSE ADH.ACTIVE_SECONDS
    END) RESP_TIME,
    (
    CASE
      WHEN ADH.PX_DFO_PAIR_ID     IS NOT NULL
      AND ADH.DFO_PAIR_IDLE_HEIGHT > 0
      AND ADH.PX_DOP               > :B34
      THEN (ADH.DFO_PAIR_TOTAL_SECONDS * (ADH.DFO_PAIR_IDLE_HEIGHT * (:B34 - ADH.DFO_PAIR_CPU_HEIGHT)) / (ADH.DFO_PAIR_TOTAL_HEIGHT_ADJ - ADH.DFO_PAIR_CPU_HEIGHT)) / :B34
      WHEN ADH.PX_DFO_PAIR_ID     IS NOT NULL
      AND ADH.DFO_PAIR_IDLE_HEIGHT > 0
      THEN (ADH.DFO_PAIR_TOTAL_SECONDS * ADH.DFO_PAIR_IDLE_HEIGHT) / ADH.PX_DOP
      ELSE 0
    END) DFO_PAIR_IDLE_RESP_TIME,
    ADH.DFO_PAIR_ACTIVITY_HEIGHT,
    ADH.DFO_PAIR_CPU_HEIGHT,
    ADH.DFO_PAIR_IDLE_HEIGHT,
    ADH.DFO_PAIR_TOTAL_HEIGHT,
    ADH.DFO_PAIR_CPU_ACTIVITY,
    ADH.DFO_PAIR_TOTAL_SECONDS
  FROM
    (SELECT ADH_1.*,
      (ROW_NUMBER() OVER(PARTITION BY ADH_1.PLSQL_OBJECT_ID, ADH_1.PLSQL_SUBPROGRAM_ID ORDER BY ADH_1.BUCKET_NUM, ADH_1.ACTIVITY_TYPE, ADH_1.EVENT_NAME)) PLSQL_ROWNUM,
      (ROW_NUMBER() OVER(PARTITION BY ADH_1.SQL ORDER BY ADH_1.BUCKET_NUM, ADH_1.ACTIVITY_TYPE, ADH_1.EVENT_NAME)) SQL_ROWNUM,
      (
      CASE
        WHEN ADH_1.PX_DFO_PAIR_ID       IS NOT NULL
        AND (ADH_1.DFO_PAIR_TOTAL_HEIGHT < ADH_1.PX_DOP)
        AND (ADH_1.DFO_PAIR_CPU_HEIGHT   < :B34 )
        THEN ADH_1.PX_DOP - ADH_1.DFO_PAIR_TOTAL_HEIGHT
        ELSE 0
      END) DFO_PAIR_IDLE_HEIGHT,
      (
      CASE
        WHEN ADH_1.PX_DFO_PAIR_ID       IS NOT NULL
        AND (ADH_1.DFO_PAIR_TOTAL_HEIGHT < ADH_1.PX_DOP)
        AND (ADH_1.DFO_PAIR_CPU_HEIGHT   < :B34 )
        THEN ADH_1.PX_DOP
        ELSE ADH_1.DFO_PAIR_TOTAL_HEIGHT
      END) DFO_PAIR_TOTAL_HEIGHT_ADJ
    FROM
      (SELECT ADH_0.*,
        (
        CASE
          WHEN ADH_0.DFO_PAIR_TOTAL_SECONDS > 0
          THEN (ADH_0.DFO_PAIR_TOTAL_ACTIVITY * :B25 ) / ADH_0.DFO_PAIR_TOTAL_SECONDS
          ELSE 0
        END) DFO_PAIR_TOTAL_HEIGHT,
        (
        CASE
          WHEN ADH_0.DFO_PAIR_TOTAL_SECONDS > 0
          THEN (ADH_0.DFO_PAIR_CPU_ACTIVITY * :B25 ) / ADH_0.DFO_PAIR_TOTAL_SECONDS
          ELSE 0
        END) DFO_PAIR_CPU_HEIGHT,
        (
        CASE
          WHEN ADH_0.PX_DFO_PAIR_ID       IS NOT NULL
          AND ADH_0.DFO_PAIR_TOTAL_SECONDS > 0
          THEN (ADH_0.ACTIVITY_COUNT * :B25 ) / ADH_0.DFO_PAIR_TOTAL_SECONDS
          ELSE 0
        END) DFO_PAIR_ACTIVITY_HEIGHT
      FROM
        (SELECT AD3.*,
          (SUM(DECODE(AD3.PX_DFO_PAIR_ID, NULL, 0, AD3.ACTIVE_SECONDS)) OVER(PARTITION BY DECODE(AD3.PX_DFO_PAIR_ID, NULL, NULL, AD3.BUCKET_NUM), DECODE(AD3.PX_DFO_PAIR_ID, NULL, NULL, AD3.PX_STEP_ARG))) DFO_PAIR_TOTAL_SECONDS
        FROM
          (SELECT AD2.*,
            CASE
              WHEN AD2.IS_MONITORED_SQL = 0
              THEN SQL_BUCKET_DISTINCT_SAMPLES * :B25
              WHEN AD2.PX_ID IS NULL
              THEN AD2.ACTIVITY_COUNT * :B25
              WHEN AD2.BUCKET_PARALLEL_MON_ACTIVITY > 0
              THEN (AD2.ACTIVITY_COUNT * AD2.BUCKET_PARALLEL_MON_SECONDS) / AD2.BUCKET_PARALLEL_MON_ACTIVITY
              ELSE 0
            END ACTIVE_SECONDS,
            CASE
              WHEN AD2.BUCKET_INTERVAL > BUCKET_ACTIVE_SECONDS
              THEN AD2.BUCKET_INTERVAL - BUCKET_ACTIVE_SECONDS
              ELSE 0
            END BUCKET_IDLE_SECONDS
          FROM
            (SELECT AD1.*,
              (AD1.BUCKET_SERIAL_MON_ACTIVITY * :B25 ) BUCKET_SERIAL_MON_SECONDS,
              (AD1.BUCKET_TOTAL_MON_ACTIVITY  - AD1.BUCKET_SERIAL_MON_ACTIVITY) BUCKET_PARALLEL_MON_ACTIVITY,
              (AD1.BUCKET_ACTIVE_SECONDS      - (AD1.BUCKET_OTHER_ACTIVITY + AD1.BUCKET_SERIAL_MON_ACTIVITY) * :B25 ) BUCKET_PARALLEL_MON_SECONDS,
              (AD1.BUCKET_OTHER_ACTIVITY      * :B25 ) BUCKET_OTHER_SECONDS,
              DECODE(AD1.PX_DFO_PAIR_ID, NULL, NULL, SUM(AD1.ACTIVITY_COUNT) OVER(PARTITION BY DECODE(AD1.PX_DFO_PAIR_ID, NULL, NULL, AD1.BUCKET_NUM), AD1.PX_DFO_PAIR_ID)) DFO_PAIR_TOTAL_ACTIVITY,
              DECODE(AD1.PX_DFO_PAIR_ID, NULL, NULL, SUM(DECODE(AD1.ACTIVITY_TYPE, 'Cpu', AD1.ACTIVITY_COUNT, 0)) OVER(PARTITION BY DECODE(AD1.PX_DFO_PAIR_ID, NULL, NULL, AD1.BUCKET_NUM), AD1.PX_DFO_PAIR_ID)) DFO_PAIR_CPU_ACTIVITY
            FROM
              (SELECT AD01.*,
                NVL((SUM(DECODE(AD01.IS_MONITORED_SQL, 1, AD01.ACTIVITY_COUNT, NULL)) OVER(PARTITION BY AD01.BUCKET_NUM)), 0) BUCKET_TOTAL_MON_ACTIVITY,
                (NVL(SUM(
                CASE
                  WHEN AD01.IS_MONITORED_SQL = 1
                  AND AD01.PX_ID            IS NULL
                  THEN AD01.ACTIVITY_COUNT
                  ELSE NULL
                END) OVER(PARTITION BY AD01.BUCKET_NUM), 0)) BUCKET_SERIAL_MON_ACTIVITY,
                (NVL((SUM(DECODE(AD01.IS_MONITORED_SQL, 0, AD01.SQL_BUCKET_DISTINCT_SAMPLES, NULL)) OVER(PARTITION BY AD01.BUCKET_NUM)), 0)) BUCKET_OTHER_ACTIVITY,
                (NVL(AD01.BUCKET_DISTINCT_SAMPLES, 0) * :B25 ) BUCKET_ACTIVE_SECONDS,
                DECODE(AD01.BUCKET_NUM, :B27 , MOD(:B32 , :B26 ), :B26 ) BUCKET_INTERVAL
              FROM
                (SELECT AD0.ACTIVITY_BUCKET_NUM BUCKET_NUM,
                  AD0.PX_ID,
                  AD0.ACTIVITY_TYPE,
                  AD0.OTHER_SQL_ACTIVITY_TYPE,
                  AD0.EVENT_NAME,
                  AD0.PLAN_LINE_ID,
                  AD0.PX_STEP_ID,
                  AD0.PX_STEP_ARG,
                  AD0.PLSQL_OBJECT_ID,
                  AD0.PLSQL_SUBPROGRAM_ID,
                  SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT,
                  MIN(AD0.ACTIVITY_START) ACTIVITY_START,
                  MAX(AD0.ACTIVITY_END) ACTIVITY_END,
                  MAX(AD0.IS_MONITORED_SQL) IS_MONITORED_SQL,
                  MAX(AD0.SQL) SQL,
                  MAX(AD0.TOP_LEVEL_SQL_ID) TOP_LEVEL_SQL_ID,
                  MAX(AD0.DBOP_NAME) DBOP_NAME,
                  MAX(DECODE(AD0.DFO_MOST_ACTIVE_COUNT, NULL, NULL, AD0.DFO_MOST_ACTIVE_IID)) DFO_MOST_ACTIVE_IID,
                  MAX(DECODE(AD0.DFO_MOST_ACTIVE_COUNT, NULL, NULL, AD0.DFO_MOST_ACTIVE_SID)) DFO_MOST_ACTIVE_SID,
                  SUM(AD0.DFO_MOST_ACTIVE_COUNT) DFO_MOST_ACTIVE_COUNT,
                  MAX(PX_DFO_PAIR_TYPE) PX_DFO_PAIR_TYPE,
                  MAX(PX_DFO_PAIR_ID) PX_DFO_PAIR_ID,
                  MAX(AD0.PX_DOP) PX_DOP,
                  MIN(AD0.PX_MIN_DOP) PX_MIN_DOP,
                  MAX(AD0.BUCKET_DISTINCT_SAMPLES) BUCKET_DISTINCT_SAMPLES,
                  MAX(AD0.SQL_BUCKET_DISTINCT_SAMPLES) SQL_BUCKET_DISTINCT_SAMPLES
                FROM
                  (SELECT AD00.*,
                    (
                    CASE
                      WHEN AD00.IS_MONITORED_SQL = 1
                      AND (AD00.SESSION_ID      != :B19
                      OR AD00.INST_ID           != :B17 )
                      THEN AD00.PX_SERVER_GROUP
                    END) PX_ID
                  FROM ASH_DATA AD00
                  WHERE :B33 = 1
                  ) AD0
                GROUP BY AD0.ACTIVITY_BUCKET_NUM,
                  AD0.PX_ID,
                  AD0.ACTIVITY_TYPE,
                  AD0.EVENT_NAME,
                  AD0.OTHER_SQL_ACTIVITY_TYPE,
                  AD0.PLAN_LINE_ID,
                  AD0.PLSQL_OBJECT_ID,
                  AD0.PLSQL_SUBPROGRAM_ID,
                  AD0.PX_STEP_ID,
                  AD0.PX_STEP_ARG
                ) AD01
              ) AD1
            ) AD2
          ) AD3
        ) ADH_0
      ) ADH_1
    ) ADH
  )
SELECT
  /*+ no_monitor no_xml_query_rewrite */
  XMLELEMENT( "sql_monitor_report", XMLATTRIBUTES(:B59 AS "version", TO_CHAR(:B58 , :B12 ) AS "sysdate"), XMLELEMENT( "report_parameters", NULL,
  CASE
    WHEN :B57 IS NOT NULL
    THEN XMLFOREST( :B57 AS "dbop_name", :B56 AS "dbop_exec_id")
    ELSE XMLFOREST( :B55 AS "sql_id", :B54 AS "sql_exec_id")
  END, XMLFOREST( :B53   AS "session_id", :B52 AS "session_serial", TO_CHAR(:B51 , :B12 ) AS "sql_exec_start", :B27 AS "bucket_count", TO_CHAR(:B50 , :B12 ) AS "interval_start", TO_CHAR(:B22 , :B12 ) AS "interval_end", DECODE(:B49 , 'Y', :B48 , NULL) AS "auto_refresh", :B47 AS "base_path"),
  CASE
    WHEN :B23    = 'Y'
    AND :B46    IS NOT NULL
    AND NOT (:B4 = 1
    AND :B3     IS NULL
    AND :B2     IS NULL
    AND :B1     IS NULL)
    THEN XMLELEMENT( "parallel_filter", NULL, XMLFOREST( DECODE(:B4 , 1, 'yes', 'no') AS "qc", :B3 AS "server_group", :B2 AS "server_set", :B1 AS "server_number"))
    ELSE NULL
  END),
  CASE
    WHEN :B14 = 1
    THEN XMLELEMENT( "derived_parameters_testing", NULL, XMLFOREST(:B11 AS "instance_id_low", :B10 AS "instance_id_high", :B26 AS "bucket_interval_sec", :B32 AS "interval_second", :B27 AS "bucket_calc_count", :B45 AS "bucket_calc_max_count", :B13 AS "sel_sqltext"))
    ELSE NULL
  END,
  (SELECT XMLCONCAT(
    CASE
      WHEN :B46 IS NULL
      AND :B60  IS NULL
      THEN XMLELEMENT( "target", XMLATTRIBUTES(:B17 AS "instance_id", :B19 AS "session_id", :B18 AS "session_serial", NVL2(:B6 , NULL, :B9 ) AS "sql_id", NVL2(:B6 , NULL, TO_CHAR(:B8 , :B12 )) AS "sql_exec_start", NVL2(:B6 , NULL, :B7 ) AS "sql_exec_id", NVL2(:B6 , :B6 , NULL) AS "dbop_name", NVL2(:B6 , :B5 , NULL) AS "dbop_exec_id", NVL2(:B6 , TO_CHAR(:B8 , :B12 ), NULL) AS "dbop_exec_start", NVL2(:B6 , NULL, MAX_PLAN_HASH_VALUE) AS "sql_plan_hash", MAGG.DB_UNIQUE_NAME AS "db_unique_name", MAGG.PLATFORM_NAME AS "db_platform_name", MAGG.HOST_NAME AS "report_host_name"), NVL2(SUM_SERVERS_REQUESTED, XMLELEMENT( "servers_requested", NULL, SUM_SERVERS_REQUESTED), NULL), NVL2(SUM_SERVERS_ALLOCATED, XMLELEMENT( "servers_allocated", NULL, SUM_SERVERS_ALLOCATED), NULL), NVL2(MAX_USERID, XMLELEMENT( "user_id", NULL, MAX_USERID), NULL), NVL2(MAX_USERNAME, XMLELEMENT( "user", NULL, MAX_USERNAME), NULL), NVL2(MAX_CON_ID, XMLELEMENT( "con_id", NULL, MAX_CON_ID), NULL), NVL2(MAX_CON_NAME,
        XMLELEMENT( "con_name", NULL, MAX_CON_NAME), NULL), NVL2(MAX_PROGRAM, XMLELEMENT( "program", NULL, MAX_PROGRAM), NULL), NVL2(MAX_MODULE, XMLELEMENT( "module", NULL, MAX_MODULE), NULL), NVL2(MAX_ACTION, XMLELEMENT( "action", NULL, MAX_ACTION), NULL), NVL2(MAX_SERVICE_NAME, XMLELEMENT( "service", NULL, MAX_SERVICE_NAME), NULL), NVL2(MAX_CLIENT_ID, XMLELEMENT( "client_id", NULL, MAX_CLIENT_ID), NULL), NVL2(MAX_CLIENT_INFO, XMLELEMENT( "client_info", NULL, MAX_CLIENT_INFO), NULL), NVL2(MAX_PL_ENTRY_OID, XMLELEMENT( "plsql_entry_object_id", NULL, MAX_PL_ENTRY_OID), NULL), NVL2(MAX_PL_ENTRY_PROGID, XMLELEMENT( "plsql_entry_subprogram_id", NULL, MAX_PL_ENTRY_PROGID), NULL), NVL2(MAX_PL_ENTRY_NAME, XMLELEMENT( "plsql_entry_name", NULL, MAX_PL_ENTRY_NAME), NULL), NVL2(MAX_PL_OID, XMLELEMENT( "plsql_object_id", NULL, MAX_PL_OID), NULL), NVL2(MAX_PL_PROGID, XMLELEMENT( "plsql_subprogram_id", NULL, MAX_PL_PROGID), NULL), NVL2(MAX_PL_NAME, XMLELEMENT( "plsql_name", NULL, MAX_PL_NAME),
        NULL),
        CASE
          WHEN (:B13 = 0
          OR :B6    IS NOT NULL)
          THEN NULL
          ELSE XMLELEMENT( "sql_fulltext", XMLATTRIBUTES(NVL2(SQL_VTEXT, 'Y', IS_FULL_TEXT) AS "is_full"), NVL2(SQL_VTEXT, SQL_VTEXT, SQLMON_TEXT))
        END, XMLELEMENT( "status", NULL, MAX_STATUS), XMLELEMENT( "refresh_count", NULL, SUM_REFRESH_COUNT), XMLELEMENT( "first_refresh_time", NULL, TO_CHAR(MIN_FIRST_REFRESH_TIME, :B12 )), XMLELEMENT( "last_refresh_time", NULL, TO_CHAR(:B58 , :B12 )), XMLELEMENT( "duration", NULL, GREATEST(:B63 , LEAST(MAX_ELAPSED_TIME/1000000, 1), CEIL(MAX_QUEUING_TIME/1000000))), DECODE(MAX_RM_INFO, '00/00/0000 00:00:00', NULL, XMLTYPE(SUBSTR(MAX_RM_INFO, 20))), NVL(
        (SELECT XMLFOREST( XMLAGG( XMLELEMENT( "param", XMLATTRIBUTES(E.NAME AS "name"), DECODE(:B14 , 1, 'XXXX', E.VALUE))
        ORDER BY E.NAME) AS "optimizer_env") SQL_ENV
        FROM GV$SQL_OPTIMIZER_ENV E
        WHERE E.INST_ID                           = :B17
        AND E.SQL_ID                              = :B9
        AND E.CHILD_ADDRESS                       = HEXTORAW(:B64 )
        AND (DECODE(:B14 , 1, 'YES', E.ISDEFAULT) = 'NO'
        OR E.ID                                  IN (2, 12, 24, 35, 36, 37, 246, 256, 257, 274, 275, 289, 290))
        ),
        (SELECT XMLELEMENT( "optimizer_env", XMLATTRIBUTES('sys' AS "type"), XMLAGG( XMLELEMENT( "param", XMLATTRIBUTES(E.NAME AS "name"), DECODE(:B14 , 1, 'XXXX', E.VALUE))
        ORDER BY E.NAME)) SYS_ENV
        FROM V$SYS_OPTIMIZER_ENV E
        WHERE (DECODE(:B14 , 1, 'YES', E.ISDEFAULT) = 'NO'
        OR E.ID                                    IN (2, 12, 24, 35, 36, 37, 246, 256, 257, 274, 275, 289, 290))
        )) )
    END, XMLELEMENT( "stats", XMLATTRIBUTES('monitor' AS "type"), DECODE(NVL(SUM_ELAPSED_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), SUM_ELAPSED_TIME)), DECODE(NVL(MAX_QUEUING_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MAX_QUEUING_TIME)), DECODE(NVL(SUM_CPU_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), SUM_CPU_TIME)), DECODE(NVL(SUM_USER_IO_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_io_wait_time' AS "name"), SUM_USER_IO_WAIT_TIME)), DECODE(NVL(SUM_APPLICATION_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), SUM_APPLICATION_WAIT_TIME)), DECODE(NVL(SUM_CONCURRENCY_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time' AS "name"), SUM_CONCURRENCY_WAIT_TIME)), DECODE(NVL(SUM_CLUSTER_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), SUM_CLUSTER_WAIT_TIME)),
    DECODE(NVL(SUM_PLSQL_EXEC_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time' AS "name"), SUM_PLSQL_EXEC_TIME)), DECODE(NVL(SUM_JAVA_EXEC_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), SUM_JAVA_EXEC_TIME)), DECODE(NVL(SUM_OTHER_WAIT_TIME, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('other_wait_time' AS "name"), SUM_OTHER_WAIT_TIME)), DECODE(NVL(SUM_FETCHES, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS "name"), SUM_FETCHES)), DECODE(NVL(SUM_BUFFER_GETS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), SUM_BUFFER_GETS)), DECODE(NVL(SUM_READ_REQS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('disk_reads' AS "name"), SUM_READ_REQS)), DECODE(NVL(SUM_WRITE_REQS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('direct_writes' AS "name"), SUM_WRITE_REQS)), DECODE(NVL(SUM_READ_REQS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), SUM_READ_REQS)), DECODE(NVL(
    SUM_READ_BYTES, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes'                      AS "name"), SUM_READ_BYTES)), DECODE(NVL(SUM_WRITE_REQS, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), SUM_WRITE_REQS)), DECODE(NVL(SUM_WRITE_BYTES, 0), 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), SUM_WRITE_BYTES)),
    CASE
      WHEN SUM_IO_INTER_BYTES IS NULL
      OR SUM_IO_BYTES          = 0
      OR SUM_IO_INTER_BYTES    = SUM_IO_BYTES
      THEN NULL
      ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency'               AS "name"), ROUND(SUM_IO_BYTES / DECODE(SUM_IO_INTER_BYTES, 0, 1, SUM_IO_INTER_BYTES), 2))
    END), NVL2(MAX_ERROR_NUMBER, XMLELEMENT( "error", XMLATTRIBUTES(MAX_ERROR_NUMBER AS "number", MAX_ERROR_FACILITY AS "facility"), MAX_ERROR_MESSAGE), NULL),
    CASE
      WHEN :B62                 = 1
      AND MAGG.QC_HAS_BINDS_XML = 'Y'
      THEN
        (SELECT XMLTYPE(BINDS_XML)
        FROM GV$SQL_MONITOR MON
        WHERE MON.INST_ID      = :B17
        AND MON.KEY            = MAGG.MAX_KEY
        AND MON.SID            = MAGG.MAX_SESSION_ID
        AND MON.SQL_ID         = :B9
        AND MON.SQL_EXEC_START = :B8
        AND MON.SQL_EXEC_ID    = :B7
        AND ROWNUM             = 1
        )
      ELSE NULL
    END,
    CASE
      WHEN :B61                 = 1
      AND MAGG.QC_HAS_OTHER_XML = 'Y'
      THEN
        (SELECT XMLTYPE(OTHER_XML)
        FROM GV$SQL_MONITOR MON
        WHERE MON.INST_ID      = MAGG.MAX_INST_ID
        AND MON.KEY            = MAGG.MAX_KEY
        AND MON.SID            = MAGG.MAX_SESSION_ID
        AND MON.SQL_ID         = :B9
        AND MON.SQL_EXEC_START = :B8
        AND MON.SQL_EXEC_ID    = :B7
        AND ROWNUM             = 1
        )
      ELSE NULL
    END)
  FROM
    (SELECT V.*,
      CASE
        WHEN :B13        = 2
        AND IS_FULL_TEXT = 'N'
        AND :B46        IS NULL
        AND :B60        IS NULL
        THEN
          (SELECT SQL_FULLTEXT
          FROM GV$SQL SQ
          WHERE SQ.INST_ID BETWEEN :B11 AND :B10
          AND SQ.SQL_ID = :B9
          AND ROWNUM    = 1
          )
        ELSE NULL
      END SQL_VTEXT
    FROM MONITOR_AGG V
    ) MAGG
  ),
  CASE
    WHEN :B44 = 1
    THEN
      (SELECT
        CASE
          WHEN AT.ACTIVITY_COUNT > 0
          THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( :B41 AS "ash_missing_seconds", TO_CHAR(AT.ACTIVITY_START, :B12 ) AS "first_sample_time", TO_CHAR(AT.ACTIVITY_END, :B12 ) AS "last_sample_time", ROUND((AT.ACTIVITY_END - AT.ACTIVITY_START) * 3600 * 24) + 1 AS "duration", AT.ACTIVITY_COUNT AS "count", AT.WAIT_COUNT AS "wait_count", AT.CPU_COUNT AS "cpu_count", DECODE(AT.OTHER_SQL_COUNT, 0, NULL, AT.OTHER_SQL_COUNT) AS "other_sql_count", :B40 AS "cpu_cores", :B39 AS "hyperthread"), AT.ACTIVITY_TOTAL, AH.GLOB_ACTIVITY_HISTO)
          WHEN :B41 IS NOT NULL
          THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( DECODE( :B41 , -1, 'all', TO_CHAR( :B41 )) AS "ash_missing_seconds"))
          ELSE NULL
        END
      FROM
        (SELECT MIN(AD1.ACTIVITY_START) ACTIVITY_START,
          MAX(AD1.ACTIVITY_END) ACTIVITY_END,
          SUM(AD1.ACTIVITY_COUNT) ACTIVITY_COUNT,
          SUM(AD1.WAIT_COUNT) WAIT_COUNT,
          SUM(AD1.CPU_COUNT) CPU_COUNT,
          SUM(AD1.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
          SUBSTR(MAX(LPAD(AD1.ACTIVITY_COUNT,10)
          || AD1.ACTIVITY_TYPE), 11) MOST_ACTIVE,
          XMLAGG( XMLELEMENT( "activity", XMLATTRIBUTES( AD1.ACTIVITY_TYPE AS "class", AD1.EVENT_NAME AS "event"), AD1.ACTIVITY_COUNT)
        ORDER BY AD1.ACTIVITY_TYPE, AD1.EVENT_NAME) ACTIVITY_TOTAL
        FROM
          (SELECT AD0.ACTIVITY_TYPE,
            AD0.EVENT_NAME,
            MIN(AD0.ACTIVITY_START) ACTIVITY_START,
            MAX(AD0.ACTIVITY_END) ACTIVITY_END,
            SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT,
            SUM(AD0.WAIT_COUNT) WAIT_COUNT,
            SUM(AD0.CPU_COUNT) CPU_COUNT,
            SUM(AD0.OTHER_SQL_COUNT) OTHER_SQL_COUNT
          FROM ASH_DATA AD0
          GROUP BY AD0.ACTIVITY_TYPE,
            AD0.EVENT_NAME
          ) AD1
        ) AT,
        (SELECT
          CASE
            WHEN :B30 = 1
            AND :B27  > 1
            THEN XMLELEMENT( "activity_histogram", XMLATTRIBUTES( :B26 AS "bucket_interval", :B27 AS "bucket_count", TO_CHAR( :B20 , :B12 ) AS "start_time", TO_CHAR( :B22 , :B12 ) AS "end_time", ROUND(( :B22 - :B20 ) *3600*24) + 1 AS "duration"), XMLAGG( XMLELEMENT( "bucket", XMLATTRIBUTES( AD2.BUCKET_NUM AS "number"), ACTIVITY_BUCKET)
            ORDER BY AD2.BUCKET_NUM))
            ELSE NULL
          END GLOB_ACTIVITY_HISTO
        FROM
          (SELECT AD1.BUCKET_NUM,
            SUM(ACTIVITY_COUNT) ACTIVITY_COUNT,
            SUM(WAIT_COUNT) WAIT_COUNT,
            SUM(CPU_COUNT) CPU_COUNT,
            SUM(OTHER_SQL_COUNT) OTHER_SQL_COUNT,
            MIN(AD1.ACTIVITY_START) ACTIVITY_START,
            MAX(AD1.ACTIVITY_END) ACTIVITY_END,
            MIN(AD1.BUCKET_ACTIVITY_START) BUCKET_ACTIVITY_START,
            MAX(AD1.BUCKET_ACTIVITY_END) BUCKET_ACTIVITY_END,
            SUBSTR(MAX(LPAD(AD1.ACTIVITY_COUNT,10)
            || AD1.ACTIVITY_TYPE), 11) MOST_ACTIVE,
            XMLAGG( XMLELEMENT( "activity", XMLATTRIBUTES( AD1.ACTIVITY_TYPE AS "class", AD1.EVENT_NAME AS "event"), AD1.ACTIVITY_COUNT)
          ORDER BY AD1.ACTIVITY_TYPE, AD1.EVENT_NAME) ACTIVITY_BUCKET
          FROM
            (SELECT AD0.ACTIVITY_BUCKET_NUM BUCKET_NUM,
              AD0.ACTIVITY_TYPE,
              AD0.EVENT_NAME,
              MIN(AD0.ACTIVITY_START) ACTIVITY_START,
              MAX(AD0.ACTIVITY_END) ACTIVITY_END,
              SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT,
              SUM(AD0.WAIT_COUNT) WAIT_COUNT,
              SUM(AD0.CPU_COUNT) CPU_COUNT,
              SUM(AD0.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
              MIN(AD0.BUCKET_ACTIVITY_START) BUCKET_ACTIVITY_START,
              MAX(AD0.BUCKET_ACTIVITY_END) BUCKET_ACTIVITY_END
            FROM ASH_DATA AD0
            GROUP BY AD0.ACTIVITY_BUCKET_NUM,
              AD0.ACTIVITY_TYPE,
              AD0.EVENT_NAME
            ) AD1
          GROUP BY AD1.BUCKET_NUM
          ) AD2
        ) AH
      )
    ELSE NULL
  END,
  CASE
    WHEN :B33 = 1
    THEN
      (SELECT
        CASE
          WHEN AH.ACTIVITY_COUNT > 0
          THEN XMLELEMENT( "activity_detail", XMLATTRIBUTES( TO_CHAR( :B20 , :B12 ) AS "start_time", TO_CHAR( :B22 , :B12 ) AS "end_time", :B41 AS "ash_missing_seconds", TO_CHAR(AH.ACTIVITY_START, :B12 ) AS "first_sample_time", TO_CHAR(AH.ACTIVITY_END, :B12 ) AS "last_sample_time", ROUND((AH.ACTIVITY_END - AH.ACTIVITY_START) * 3600 * 24) + 1 AS "duration", :B25 AS "sample_interval", :B26 AS "bucket_interval", :B27 AS "bucket_count", ROUND((:B22 - :B20 ) *3600*24) + 1 AS "bucket_duration", :B40 AS "cpu_cores", :B34 AS "total_cpu_cores", :B39 AS "hyperthread"), AH.GLOB_ACTIVITY_HISTO)
          WHEN :B41 IS NOT NULL
          THEN XMLELEMENT( "activity_detail", XMLATTRIBUTES( DECODE( :B41 , -1, 'all', TO_CHAR( :B41 )) AS "ash_missing_seconds"))
          ELSE NULL
        END
      FROM
        (SELECT MIN(AD2.ACTIVITY_START) ACTIVITY_START,
          MAX(AD2.ACTIVITY_END) ACTIVITY_END,
          SUM(AD2.ACTIVITY_COUNT) ACTIVITY_COUNT,
          XMLAGG( XMLELEMENT( "bucket", XMLATTRIBUTES( AD2.BUCKET_NUM AS "number"), ACTIVITY_BUCKET_XML)
        ORDER BY AD2.BUCKET_NUM) GLOB_ACTIVITY_HISTO
        FROM
          (SELECT AD1.BUCKET_NUM,
            MIN(AD1.ACTIVITY_START) ACTIVITY_START,
            MAX(AD1.ACTIVITY_END) ACTIVITY_END,
            SUM(AD1.ACTIVITY_COUNT) ACTIVITY_COUNT,
            MAX(AD1.BUCKET_IDLE_SECONDS) BUCKET_IDLE_SECONDS,
            XMLAGG( XMLCONCAT(
            CASE
              WHEN AD1.DFO_PAIR_IDLE_RESP_TIME != 0
              AND DFO_PAIR_ROWNUM               = 1
              THEN XMLELEMENT( "activity", XMLATTRIBUTES( 'Parallel Skew' AS "class", AD1.PX_STEP_ARG AS "line", AD1.PX_ID AS "px", ROUND(AD1.DFO_PAIR_IDLE_RESP_TIME, 2) AS "rt"), 0)
              ELSE NULL
            END, XMLELEMENT( "activity", XMLATTRIBUTES( NVL(AD1.OTHER_SQL, AD1.RPI) AS "sql", AD1.NON_SQL AS "non_sql", AD1.CLASS AS "class", AD1.OTHER_SQL_CLASS AS "other_sql_class", AD1.EVENT AS "event", AD1.PLAN_LINE_ID AS "line", NVL2(AD1.PLSQL_OBJECT_ID, AD1.PLSQL_OBJECT_ID
            ||'.'
            || AD1.PLSQL_SUBPROGRAM_ID, NULL) AS "plsql_id", AD1.PLSQL_NAME AS "plsql_name",
            CASE
              WHEN AD1.SQL_ROWNUM = 1
              THEN AD1.TOP_LEVEL_SQL_ID
            END AS "top_sql_id",
            CASE
              WHEN AD1.DBOP_NAME IS NOT NULL
              THEN AD1.DBOP_NAME
            END AS "dbop_name",
            CASE
              WHEN AD1.DFO_MOST_ACTIVE_IID IS NOT NULL
              AND :B65                      = 'Y'
              THEN AD1.DFO_MOST_ACTIVE_IID
            END AS "skew_iid", DECODE(AD1.DFO_MOST_ACTIVE_COUNT, NULL,NULL, AD1.DFO_MOST_ACTIVE_SID) AS "skew_sid", AD1.DFO_MOST_ACTIVE_COUNT AS "skew_count", DECODE(AD1.PX_DOP, :B28 , NULL, AD1.PX_DOP) AS "dop", DECODE(AD1.PX_DOP, AD1.PX_MIN_DOP, NULL, AD1.PX_MIN_DOP) AS "min_dop", AD1.PX_ID AS "px", AD1.PX_STEP_ID AS "step", AD1.PX_STEP_ARG AS "arg", DECODE(AD1.ACTIVITY_COUNT, AD1.RESP_TIME, NULL, ROUND(AD1.RESP_TIME, 2)) AS "rt"), AD1.ACTIVITY_COUNT))
          ORDER BY AD1.PX_STEP_ID, AD1.PX_STEP_ARG, AD1.DFO_PAIR_ROWNUM) ACTIVITY_BUCKET_XML
          FROM
            (SELECT AD01.*,
              CASE
                WHEN AD01.ACTIVITY_TYPE != 'Other SQL Execution'
                AND AD01.ACTIVITY_TYPE  != 'Non SQL'
                THEN AD01.ACTIVITY_TYPE
              END CLASS,
              CASE
                WHEN (AD01.ACTIVITY_TYPE = 'Other SQL Execution'
                OR AD01.ACTIVITY_TYPE    = 'Non SQL')
                THEN AD01.OTHER_SQL_ACTIVITY_TYPE
              END OTHER_SQL_CLASS,
              CASE
                WHEN AD01.ACTIVITY_TYPE != 'Other SQL Execution'
                AND AD01.ACTIVITY_TYPE  != 'Non SQL'
                THEN AD01.EVENT_NAME
              END EVENT,
              CASE
                WHEN AD01.SQL IN ('this', 'anonymous')
                THEN NULL
                ELSE AD01.SQL
              END RPI,
              DECODE(AD01.ACTIVITY_TYPE, 'Other SQL Execution', SUBSTR(AD01.EVENT_NAME, 9), NULL) OTHER_SQL,
              DECODE(AD01.ACTIVITY_TYPE, 'Non SQL', AD01.EVENT_NAME, NULL) NON_SQL,
              ROW_NUMBER() OVER(PARTITION BY AD01.BUCKET_NUM, AD01.PX_DFO_PAIR_ID ORDER BY AD01.ACTIVITY_TYPE, AD01.EVENT_NAME, AD01.PLAN_LINE_ID) DFO_PAIR_ROWNUM
            FROM RESPONSE_TIME_DATA AD01
            ) AD1
          GROUP BY AD1.BUCKET_NUM
          ) AD2
        ) AH
      )
    ELSE NULL
  END,
  CASE
    WHEN :B23 = 'Y'
    THEN
      (SELECT XMLELEMENT( "parallel_info", XMLATTRIBUTES( :B17 AS "qc_instance_id", MAX_PX_QCSID AS "qc_session_id", MAX_PX_IS_CROSS_INSTANCE AS "is_cross_instance", MAX_PX_DOP AS "dop", MAX_PX_DOP_INSTANCES AS "max_dop_instances", DIST_INST_COUNT AS "inst_count", DIST_PX_GROUP_COUNT AS "server_group_count", DIST_PX_SET_COUNT AS "server_set_count"),
        CASE
          WHEN :B67 = 1
          THEN PX_SESSIONS
          ELSE NULL
        END,
        CASE
          WHEN :B65 = 'Y'
          THEN DECODE(:B66 , 1, PX_INSTANCES, NULL)
          ELSE NULL
        END)
      FROM
        (SELECT MAX_PX_QCSID,
          MAX_PX_DOP,
          MAX_PX_DOP_INSTANCES,
          MAX_PX_IS_CROSS_INSTANCE,
          SUM_SERVERS_REQUESTED,
          SUM_SERVERS_ALLOCATED,
          DIST_INST_COUNT,
          DIST_PX_GROUP_COUNT,
          DIST_PX_SET_COUNT,
          (SELECT XMLELEMENT( "sessions", XMLATTRIBUTES(MAX(PX_SESSION.ACTIVITY_COUNT) AS "max_activity_count", MAX(PX_SESSION.CPU_COUNT) AS "max_cpu_count", MAX(PX_SESSION.WAIT_COUNT) AS "max_wait_count", MAX(PX_SESSION.OTHER_SQL_COUNT) AS "max_other_sql_count", MAX(PX_SESSION.MAX_IO_REQS) AS "max_io_reqs", MAX(PX_SESSION.MAX_IO_BYTES) AS "max_io_bytes", MAX(PX_SESSION.MAX_BUFFER_GETS) AS "max_buffer_gets", MAX(PX_SESSION.MAX_ELAPSED_TIME) AS "max_elapsed_time"), XMLAGG(PX_SESSION.PX_SESSION_XML
          ORDER BY PX_SERVER_GROUP NULLS FIRST, PX_SERVER_SET, PX_SERVER#))
          FROM
            (SELECT PX_SERVER_GROUP,
              PX_SERVER_SET,
              PX_SERVER#,
              MAX(PI.MAX_ELAPSED_TIME) MAX_ELAPSED_TIME,
              MAX(PI.MAX_IO_REQS) MAX_IO_REQS,
              MAX(PI.MAX_IO_BYTES) MAX_IO_BYTES,
              MAX(PI.MAX_BUFFER_GETS) MAX_BUFFER_GETS,
              SUM(PI.ACTIVITY_COUNT) ACTIVITY_COUNT,
              SUM(PI.WAIT_COUNT) WAIT_COUNT,
              SUM(PI.CPU_COUNT) CPU_COUNT,
              SUM(PI.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
              XMLELEMENT( "session", XMLATTRIBUTES( INST_ID AS "inst_id", PROCESS_NAME AS "process_name", SID AS "session_id", SESSION_SERIAL# AS "session_serial", PX_SERVER_GROUP AS "server_group", PX_SERVER_SET AS "server_set", PX_SERVER# AS "server_num"), XMLELEMENT( "stats", XMLATTRIBUTES( 'monitor' AS "type"), NVL2(MAX(ELAPSED_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), MAX(ELAPSED_TIME)), NULL), NVL2(MAX(QUEUING_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MAX(QUEUING_TIME)), NULL), NVL2(MAX(CPU_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), MAX(CPU_TIME)), NULL), NVL2(MAX(USER_IO_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('user_io_wait_time' AS "name"), MAX(USER_IO_WAIT_TIME)), NULL), NVL2(MAX(APPLICATION_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), MAX(APPLICATION_WAIT_TIME)), NULL), NVL2(MAX(CONCURRENCY_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time'
                                                            AS "name"), MAX(CONCURRENCY_WAIT_TIME)), NULL), NVL2(MAX(CLUSTER_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), MAX(CLUSTER_WAIT_TIME)), NULL), NVL2(MAX(PLSQL_EXEC_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time' AS "name"), MAX(PLSQL_EXEC_TIME)), NULL), NVL2(MAX(JAVA_EXEC_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), MAX(JAVA_EXEC_TIME)), NULL), NVL2(MAX(OTHER_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES( 'other_wait_time' AS "name"), MAX(OTHER_WAIT_TIME)), NULL), NVL2(MAX(FETCHES), XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS "name"), MAX(FETCHES)), NULL), NVL2(MAX(BUFFER_GETS), XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), MAX(BUFFER_GETS)), NULL), NVL2(MAX(READ_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('disk_reads' AS "name"), MAX(READ_REQS)), NULL), NVL2(MAX(WRITE_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('direct_writes' AS "name"), MAX(WRITE_REQS)), NULL), NVL2(MAX(READ_REQS),
              XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), MAX(READ_REQS)), NULL), NVL2(MAX(READ_BYTES), XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), MAX(READ_BYTES)), NULL), NVL2(MAX(WRITE_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), MAX(WRITE_REQS)), NULL), NVL2(MAX(WRITE_BYTES), XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), MAX(WRITE_BYTES)), NULL),
              CASE
                WHEN MAX(IO_INTER_BYTES) IS NULL
                OR NVL(MAX(IO_BYTES), 0)  = 0
                OR MAX(IO_INTER_BYTES)    = MAX(IO_BYTES)
                THEN NULL
                ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(MAX(IO_BYTES) / DECODE(MAX(IO_INTER_BYTES), 0, 1, MAX(IO_INTER_BYTES)), 2))
              END),
              CASE
                WHEN SUM(PI.ACTIVITY_COUNT) > 0
                AND :B33                    = 1
                THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( TO_CHAR(MIN(PI.ACTIVITY_START), :B12 ) AS "first_sample_time", TO_CHAR(MAX(PI.ACTIVITY_END), :B12 ) AS "last_sample_time", ROUND((MAX(PI.ACTIVITY_END) - MIN(PI.ACTIVITY_START)) * 3600 * 24) + 1 AS "duration", SUM(PI.ACTIVITY_COUNT) AS "count", SUM(PI.CPU_COUNT) AS "cpu_count", SUM(PI.WAIT_COUNT) AS "wait_count", SUM(PI.OTHER_SQL_COUNT)AS "other_sql_count", :B40 AS "cpu_cores", :B39 AS "hyperthread"), XMLAGG( NVL2(ACTIVITY_TYPE, XMLELEMENT( "activity", XMLATTRIBUTES( PI.ACTIVITY_TYPE AS "class", PI.EVENT_NAME AS "event"), ACTIVITY_COUNT), NULL)
                ORDER BY PI.ACTIVITY_TYPE, PI.EVENT_NAME))
                ELSE NULL
              END,
              CASE
                WHEN :B61            = 1
                AND PI.HAS_OTHER_XML = 'Y'
                THEN
                  (SELECT XMLTYPE(OTHER_XML)
                  FROM GV$SQL_MONITOR MON
                  WHERE MON.INST_ID      = PI.INST_ID
                  AND MON.KEY            = PI.KEY
                  AND MON.SID            = PI.SID
                  AND MON.SQL_ID         = :B9
                  AND MON.SQL_EXEC_START = :B8
                  AND MON.SQL_EXEC_ID    = :B7
                  AND ROWNUM             = 1
                  )
                ELSE NULL
              END) PX_SESSION_XML
            FROM
              (SELECT MO.HAS_OTHER_XML,
                MO.KEY,
                MO.INST_ID,
                DECODE(MO.PROCESS_NAME, 'ora', 'PX Coordinator', MO.PROCESS_NAME) PROCESS_NAME,
                MO.SID,
                MO.SESSION_SERIAL#,
                MO.PX_SERVER_GROUP,
                MO.PX_SERVER_SET,
                MO.PX_SERVER#,
                ASH0.ACTIVITY_TYPE,
                ASH0.EVENT_NAME,
                MAX(MO.IO_REQS) MAX_IO_REQS,
                MAX(MO.IO_BYTES) MAX_IO_BYTES,
                MAX(MO.BUFFER_GETS) MAX_BUFFER_GETS,
                MAX(MO.ELAPSED_TIME) MAX_ELAPSED_TIME,
                SUM(DECODE(ASH0.ACTIVITY_TYPE, NULL, NULL, ASH0.ACTIVITY_COUNT)) ACTIVITY_COUNT,
                SUM(DECODE(ASH0.ACTIVITY_TYPE, NULL, NULL, ASH0.WAIT_COUNT)) WAIT_COUNT,
                SUM(DECODE(ASH0.ACTIVITY_TYPE, NULL, NULL, ASH0.CPU_COUNT)) CPU_COUNT,
                SUM(DECODE(ASH0.ACTIVITY_TYPE, NULL, NULL, ASH0.OTHER_SQL_COUNT)) OTHER_SQL_COUNT,
                MIN(ASH0.ACTIVITY_START) ACTIVITY_START,
                MAX(ASH0.ACTIVITY_END) ACTIVITY_END,
                MAX(DECODE(MO.ELAPSED_TIME, 0, NULL, MO.ELAPSED_TIME)) ELAPSED_TIME,
                MAX(DECODE(MO.QUEUING_TIME, 0, NULL, MO.QUEUING_TIME)) QUEUING_TIME,
                MAX(DECODE(MO.CPU_TIME, 0, NULL, CPU_TIME)) CPU_TIME,
                MAX(DECODE(MO.FETCHES, 0, NULL, FETCHES)) FETCHES,
                MAX(DECODE(MO.BUFFER_GETS, 0, NULL, MO.BUFFER_GETS)) BUFFER_GETS,
                MAX(DECODE(MO.IO_INTER_BYTES, 0, NULL, MO.IO_INTER_BYTES)) IO_INTER_BYTES,
                MAX(DECODE(MO.READ_REQS, 0, NULL, MO.READ_REQS)) READ_REQS,
                MAX(DECODE(MO.READ_BYTES, 0, NULL, MO.READ_BYTES)) READ_BYTES,
                MAX(DECODE(MO.WRITE_REQS, 0, NULL, MO.WRITE_REQS)) WRITE_REQS,
                MAX(DECODE(MO.WRITE_BYTES, 0, NULL, MO.WRITE_BYTES)) WRITE_BYTES,
                MAX(DECODE(MO.IO_BYTES, 0, NULL, MO.IO_BYTES)) IO_BYTES,
                MAX(DECODE(MO.APPLICATION_WAIT_TIME, 0, NULL, MO.APPLICATION_WAIT_TIME)) APPLICATION_WAIT_TIME,
                MAX(DECODE(MO.CONCURRENCY_WAIT_TIME, 0, NULL, MO.CONCURRENCY_WAIT_TIME)) CONCURRENCY_WAIT_TIME,
                MAX(DECODE(MO.CLUSTER_WAIT_TIME, 0, NULL, MO.CLUSTER_WAIT_TIME)) CLUSTER_WAIT_TIME,
                MAX(DECODE(MO.USER_IO_WAIT_TIME, 0, NULL, MO.USER_IO_WAIT_TIME)) USER_IO_WAIT_TIME,
                MAX(DECODE(PLSQL_EXEC_TIME, 0, NULL, PLSQL_EXEC_TIME)) PLSQL_EXEC_TIME,
                MAX(DECODE(MO.JAVA_EXEC_TIME, 0, NULL, MO.JAVA_EXEC_TIME)) JAVA_EXEC_TIME,
                MAX(DECODE(MO.OTHER_WAIT_TIME, 0, NULL, MO.OTHER_WAIT_TIME)) OTHER_WAIT_TIME
              FROM MONITOR_DATA MO,
                (SELECT ASH1.INST_ID,
                  ASH1.SESSION_ID,
                  ASH1.ACTIVITY_TYPE,
                  ASH1.EVENT_NAME,
                  SUM(ASH1.ACTIVITY_COUNT) ACTIVITY_COUNT,
                  SUM(ASH1.WAIT_COUNT) WAIT_COUNT,
                  SUM(ASH1.CPU_COUNT) CPU_COUNT,
                  SUM(ASH1.OTHER_SQL_COUNT)OTHER_SQL_COUNT,
                  MIN(ASH1.ACTIVITY_START) ACTIVITY_START,
                  MAX(ASH1.ACTIVITY_END) ACTIVITY_END
                FROM ASH_DATA ASH1
                GROUP BY ASH1.INST_ID,
                  ASH1.SESSION_ID,
                  ASH1.ACTIVITY_TYPE,
                  ASH1.EVENT_NAME
                ) ASH0
              WHERE MO.INST_ID = ASH0.INST_ID(+)
              AND MO.SID       = ASH0.SESSION_ID(+)
              AND (:B67        = 1
              OR :B66          = 1)
              GROUP BY MO.INST_ID,
                MO.KEY,
                MO.HAS_OTHER_XML,
                MO.PROCESS_NAME,
                MO.SID,
                MO.SESSION_SERIAL#,
                MO.PX_SERVER_GROUP,
                MO.PX_SERVER_SET,
                MO.PX_SERVER#,
                ASH0.ACTIVITY_TYPE,
                ASH0.EVENT_NAME
              ) PI
            WHERE (:B67 = 1)
            GROUP BY PI.INST_ID,
              PI.KEY,
              PI.HAS_OTHER_XML,
              PI.SID,
              PI.PROCESS_NAME,
              PI.SESSION_SERIAL#,
              PI.PX_SERVER_GROUP,
              PI.PX_SERVER_SET,
              PI.PX_SERVER#
            ) PX_SESSION
          ) PX_SESSIONS,
          (SELECT XMLELEMENT( "instances", XMLATTRIBUTES( MAX(PX_INSTANCE.ACTIVITY_COUNT) AS "max_activity_count", MAX(PX_INSTANCE.CPU_COUNT) AS "max_cpu_count", MAX(PX_INSTANCE.WAIT_COUNT) AS "max_wait_count", MAX(PX_INSTANCE.OTHER_SQL_COUNT) AS "max_other_sql_count", MAX(PX_INSTANCE.ELAPSED_TIME) AS "max_elapsed_time", MAX(PX_INSTANCE.BUFFER_GETS) AS "max_buffer_gets", MAX(PX_INSTANCE.IO_REQS) AS "max_io_reqs", MAX(PX_INSTANCE.IO_BYTES) AS "max_io_bytes"), XMLAGG(PX_INSTANCE.PX_INSTANCES_XML
          ORDER BY INST_ID))
          FROM
            (SELECT PI.INST_ID,
              MAX(PI.ELAPSED_TIME) ELAPSED_TIME,
              MAX(PI.IO_REQS) IO_REQS,
              MAX(PI.IO_BYTES) IO_BYTES,
              MAX(PI.BUFFER_GETS) BUFFER_GETS,
              SUM(PI.ACTIVITY_COUNT) ACTIVITY_COUNT,
              SUM(PI.WAIT_COUNT) WAIT_COUNT,
              SUM(PI.CPU_COUNT) CPU_COUNT,
              SUM(PI.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
              XMLELEMENT( "instance", XMLATTRIBUTES( INST_ID AS "inst_id"), XMLELEMENT( "stats", XMLATTRIBUTES( 'monitor' AS "type"), NVL2(MAX(ELAPSED_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), MAX(ELAPSED_TIME)), NULL), NVL2(MAX(QUEUING_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MAX(QUEUING_TIME)), NULL), NVL2(MAX(CPU_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), MAX(CPU_TIME)), NULL), NVL2(MAX(USER_IO_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('user_io_wait_time' AS "name"), MAX(USER_IO_WAIT_TIME)), NULL), NVL2(MAX(APPLICATION_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), MAX(APPLICATION_WAIT_TIME)), NULL), NVL2(MAX(CONCURRENCY_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time' AS "name"), MAX(CONCURRENCY_WAIT_TIME)), NULL), NVL2(MAX(CLUSTER_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), MAX(CLUSTER_WAIT_TIME)), NULL), NVL2(MAX
              (PLSQL_EXEC_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time'      AS "name"), MAX(PLSQL_EXEC_TIME)), NULL), NVL2(MAX(JAVA_EXEC_TIME), XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), MAX(JAVA_EXEC_TIME)), NULL), NVL2(MAX(OTHER_WAIT_TIME), XMLELEMENT( "stat", XMLATTRIBUTES( 'other_wait_time' AS "name"), MAX(OTHER_WAIT_TIME)), NULL), NVL2(MAX(FETCHES), XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS "name"), MAX(FETCHES)), NULL), NVL2(MAX(BUFFER_GETS), XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), MAX(BUFFER_GETS)), NULL), NVL2(MAX(READ_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('disk_reads' AS "name"), MAX(READ_REQS)), NULL), NVL2(MAX(WRITE_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('direct_writes' AS "name"), MAX(WRITE_REQS)), NULL), NVL2(MAX(READ_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), MAX(READ_REQS)), NULL), NVL2(MAX(READ_BYTES), XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), MAX(READ_BYTES)),
              NULL), NVL2(MAX(WRITE_REQS), XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), MAX(WRITE_REQS)), NULL), NVL2(MAX(WRITE_BYTES), XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), MAX(WRITE_BYTES)), NULL),
              CASE
                WHEN MAX(IO_INTER_BYTES) IS NULL
                OR NVL(MAX(IO_BYTES), 0)  = 0
                OR MAX(IO_INTER_BYTES)    = MAX(IO_BYTES)
                THEN NULL
                ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(MAX(IO_BYTES)/ DECODE(MAX(IO_INTER_BYTES), 0, 1, MAX(IO_INTER_BYTES)), 2))
              END),
              CASE
                WHEN :B33                  = 1
                AND SUM(PI.ACTIVITY_COUNT) > 0
                THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( TO_CHAR(MIN(PI.ACTIVITY_START), :B12 ) AS "start_time", TO_CHAR(MAX(PI.ACTIVITY_END), :B12 ) AS "end_time", ROUND((MAX(PI.ACTIVITY_END) - MIN(PI.ACTIVITY_START)) * 3600 * 24) + 1 AS "duration", SUM(PI.ACTIVITY_COUNT) AS "count", SUM(PI.WAIT_COUNT) AS "wait_count", SUM(PI.CPU_COUNT) AS "cpu_count", SUM(PI.OTHER_SQL_COUNT) AS "other_sql_count", :B40 AS "cpu_cores", :B39 AS "hyperthread"), XMLAGG( NVL2(ACTIVITY_TYPE, XMLELEMENT( "activity", XMLATTRIBUTES( PI.ACTIVITY_TYPE AS "class", PI.EVENT_NAME AS "event"), ACTIVITY_COUNT), NULL)
                ORDER BY PI.ACTIVITY_TYPE, PI.EVENT_NAME))
                ELSE NULL
              END) PX_INSTANCES_XML
            FROM
              (SELECT MO.INST_ID,
                ASH.ACTIVITY_TYPE,
                ASH.EVENT_NAME,
                ASH.ACTIVITY_COUNT,
                ASH.WAIT_COUNT,
                ASH.CPU_COUNT,
                ASH.OTHER_SQL_COUNT,
                ASH.ACTIVITY_START,
                ASH.ACTIVITY_END,
                MO.ELAPSED_TIME,
                MO.QUEUING_TIME,
                MO.CPU_TIME,
                MO.APPLICATION_WAIT_TIME,
                MO.CONCURRENCY_WAIT_TIME,
                MO.CLUSTER_WAIT_TIME,
                MO.USER_IO_WAIT_TIME,
                MO.PLSQL_EXEC_TIME,
                MO.JAVA_EXEC_TIME,
                MO.OTHER_WAIT_TIME,
                MO.FETCHES,
                MO.BUFFER_GETS,
                MO.IO_INTER_BYTES,
                MO.IO_BYTES,
                MO.READ_REQS,
                MO.READ_BYTES,
                MO.WRITE_REQS,
                MO.WRITE_BYTES,
                MO.IO_REQS
              FROM
                (SELECT MO0.INST_ID,
                  SUM(MO0.ELAPSED_TIME) ELAPSED_TIME,
                  SUM(MO0.QUEUING_TIME) QUEUING_TIME,
                  SUM(MO0.CPU_TIME) CPU_TIME,
                  SUM(MO0.FETCHES) FETCHES,
                  SUM(MO0.BUFFER_GETS) BUFFER_GETS,
                  SUM(MO0.IO_INTER_BYTES) IO_INTER_BYTES,
                  SUM(MO0.IO_BYTES) IO_BYTES,
                  SUM(MO0.READ_REQS) READ_REQS,
                  SUM(MO0.READ_BYTES) READ_BYTES,
                  SUM(MO0.WRITE_REQS) WRITE_REQS,
                  SUM(MO0.WRITE_BYTES) WRITE_BYTES,
                  SUM(MO0.IO_REQS) IO_REQS,
                  SUM(MO0.APPLICATION_WAIT_TIME) APPLICATION_WAIT_TIME,
                  SUM(MO0.CONCURRENCY_WAIT_TIME) CONCURRENCY_WAIT_TIME,
                  SUM(MO0.CLUSTER_WAIT_TIME) CLUSTER_WAIT_TIME,
                  SUM(MO0.USER_IO_WAIT_TIME) USER_IO_WAIT_TIME,
                  SUM(MO0.PLSQL_EXEC_TIME) PLSQL_EXEC_TIME,
                  SUM(MO0.JAVA_EXEC_TIME) JAVA_EXEC_TIME,
                  SUM(MO0.OTHER_WAIT_TIME) OTHER_WAIT_TIME
                FROM MONITOR_DATA MO0
                GROUP BY MO0.INST_ID
                ) MO,
                (SELECT ASH0.INST_ID,
                  ASH0.ACTIVITY_TYPE,
                  ASH0.EVENT_NAME,
                  SUM(ASH0.ACTIVITY_COUNT) ACTIVITY_COUNT,
                  SUM(ASH0.WAIT_COUNT) WAIT_COUNT,
                  SUM(ASH0.CPU_COUNT) CPU_COUNT,
                  SUM(ASH0.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
                  MIN(ASH0.ACTIVITY_START) ACTIVITY_START,
                  MAX(ASH0.ACTIVITY_END) ACTIVITY_END
                FROM ASH_DATA ASH0
                GROUP BY ASH0.INST_ID,
                  ASH0.ACTIVITY_TYPE,
                  ASH0.EVENT_NAME
                ) ASH,
                MONITOR_AGG
              WHERE MO.INST_ID                = ASH.INST_ID(+)
              AND MONITOR_AGG.DIST_INST_COUNT > 0
              ) PI
            GROUP BY PI.INST_ID
            )PX_INSTANCE
          ) PX_INSTANCES
        FROM MONITOR_AGG
        )
      )
    ELSE NULL
  END, XPLAN_XML,
  CASE
    WHEN :B43 = 1
    THEN
      (SELECT XMLELEMENT( "plan_monitor", XMLATTRIBUTES(MAX(PLI.MAX_LINE_ACTIVITY_COUNT) AS "max_activity_count", MAX(PLI.OVERALL_MAX_IO_REQS) AS "max_io_reqs", MAX(PLI.OVERALL_MAX_IO_BYTES) AS "max_io_bytes", MAX(PLI.MAX_LINE_CPU_COUNT) AS "max_cpu_count", MAX(PLI.MAX_LINE_WAIT_COUNT) AS "max_wait_count", MAX(PLI.MAX_LINE_OTHER_SQL_COUNT) AS "max_other_sql_count"), XMLAGG( XMLELEMENT( "operation", XMLATTRIBUTES( PLI.PLAN_LINE_ID AS "id", PLI.PARENT_ID AS "parent_id", PLI.OPERATION AS "name", PLI.OPTIONS AS "options", PLI.DEPTH AS "depth", PLI.POSITION AS "position", PLI.PX_TYPE AS "px_type"), NVL2(PLI.OBJECT_NAME, XMLELEMENT( "object", XMLATTRIBUTES(PLI.OBJECT_TYPE AS "type"), XMLFOREST(PLI.OBJECT_OWNER AS "owner"), XMLFOREST(PLI.OBJECT_NAME AS "name")), NULL), XMLFOREST(PLI.PARTITION_START AS "partition_start", PLI.PARTITION_STOP AS "partition_stop"),
        CASE
          WHEN PLI.CARDINALITY IS NULL
          AND PLI.BYTES        IS NULL
          AND PLI.COST         IS NULL
          AND PLI.TEMP_SPACE   IS NULL
          AND PLI.TIME         IS NULL
          THEN NULL
          ELSE XMLELEMENT( "optimizer", NULL, NVL2(PLI.CARDINALITY, XMLFOREST(PLI.CARDINALITY AS "cardinality"), NULL), NVL2(PLI.BYTES, XMLFOREST(PLI.BYTES AS "bytes"), NULL), NVL2(PLI.COST, XMLFOREST(PLI.COST AS "cost"), NULL), NVL2(PLI.CPU_COST, XMLFOREST(PLI.CPU_COST AS "cpu_cost"), NULL), NVL2(PLI.IO_COST, XMLFOREST(PLI.IO_COST AS "io_cost"), NULL), NVL2(PLI.TEMP_SPACE, XMLFOREST(PLI.TEMP_SPACE AS "temp"), NULL), NVL2(PLI.TIME, XMLFOREST(PLI.TIME AS "time"), NULL))
        END, XMLELEMENT( "stats", XMLATTRIBUTES('plan_monitor' AS "type"), NVL2(PLI.FIRST_MOVE_TIME, XMLELEMENT( "stat", XMLATTRIBUTES('first_active' AS "name"), TO_CHAR(FIRST_MOVE_TIME, :B12 )), NULL),
        CASE
          WHEN PLI.FIRST_MOVE_TIME != PLI.FIRST_CHANGE_TIME
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('first_row' AS "name"), TO_CHAR(FIRST_CHANGE_TIME, :B12 ))
          ELSE NULL
        END, NVL2(PLI.LAST_MOVE_TIME, XMLELEMENT( "stat", XMLATTRIBUTES('last_active' AS "name"), TO_CHAR(LAST_MOVE_TIME, :B12 )), NULL),
        CASE
          WHEN (PLI.FIRST_MOVE_TIME IS NULL
          OR PLI.LAST_MOVE_TIME     IS NULL)
          THEN NULL
          ELSE XMLELEMENT( "stat", XMLATTRIBUTES('duration' AS "name"), ROUND((LAST_MOVE_TIME - FIRST_MOVE_TIME) * 3600 * 24)+1)
        END,
        CASE
          WHEN (PLI.OVERALL_LAST_MOVE_TIME IS NULL
          OR PLI.LAST_MOVE_TIME            IS NULL)
          THEN NULL
          ELSE XMLELEMENT( "stat", XMLATTRIBUTES('from_most_recent' AS "name"), ROUND((PLI.OVERALL_LAST_MOVE_TIME                  - PLI.LAST_MOVE_TIME) * 3600 * 24))
        END, NVL2(PLI.LAST_MOVE_TIME, XMLELEMENT( "stat", XMLATTRIBUTES( 'from_sql_exec_start' AS "name"), ROUND( (FIRST_MOVE_TIME - :B8 ) * 3600*24)), NULL), NVL2(PLI.PERCENT_COMPLETE, XMLELEMENT( "stat", XMLATTRIBUTES('percent_complete' AS "name"), PLI.PERCENT_COMPLETE), NULL), NVL2(PLI.TIME_REMAINING, XMLELEMENT( "stat", XMLATTRIBUTES('time_left' AS "name"), PLI.TIME_REMAINING), NULL),
        CASE
          WHEN PLI.HAS_EXECUTED = 1
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('starts' AS "name"), PLI.STARTS)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP         > 0
          AND PLI.HAS_EXECUTED = 1
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_starts' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MAX_STARTS/1000000), 10000), NULL) AS "iid", MOD(MAX_STARTS, 1000000) AS "sid"), TRUNC(PLI.MAX_STARTS/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP         > 0
          AND PLI.HAS_EXECUTED = 1
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('dop' AS "name"), PLI.DOP)
          ELSE NULL
        END,
        CASE
          WHEN NEED_ROWS          IS NOT NULL
          AND PLI.FIRST_MOVE_TIME IS NOT NULL
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('cardinality' AS "name"), PLI.OUTPUT_ROWS)
          ELSE NULL
        END,
        CASE
          WHEN PLI.NEED_ROWS       IS NOT NULL
          AND PLI.DOP               > 0
          AND PLI.MAX_OUTPUT_ROWS  IS NOT NULL
          AND (PLI.FIRST_MOVE_TIME IS NOT NULL)
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_card' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MAX_OUTPUT_ROWS/1000000), 10000), NULL) AS "iid", MOD(MAX_OUTPUT_ROWS, 1000000) AS "sid"), TRUNC(PLI.MAX_OUTPUT_ROWS/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.MEM > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('memory' AS "name"), PLI.MEM)
          ELSE NULL
        END,
        CASE
          WHEN PLI.MAX_MEM > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('max_memory' AS "name"), PLI.MAX_MEM)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP         > 0
          AND PLI.MIN_MAX_MEM IS NOT NULL
          AND PLI.MAX_MEM      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'min_max_mem' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MIN_MAX_MEM/1000000), 10000), NULL) AS "iid", MOD(MIN_MAX_MEM, 1000000) AS "sid"), TRUNC(PLI.MIN_MAX_MEM/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.TEMP > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('temp' AS "name"), PLI.TEMP)
          ELSE NULL
        END,
        CASE
          WHEN PLI.MAX_TEMP > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('max_temp' AS "name"), PLI.MAX_TEMP)
          ELSE NULL
        END,
        CASE
          WHEN PLI.MAX_TEMP > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('spill_count' AS "name"), PLI.SPILL_COUNT)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP          > 0
          AND PLI.MAX_MAX_TEMP IS NOT NULL
          AND PLI.MAX_TEMP      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_max_temp' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MAX_MAX_TEMP/1000000), 10000), NULL) AS "iid", MOD(MAX_MAX_TEMP, 1000000) AS "sid"), TRUNC(PLI.MAX_MAX_TEMP/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.READ_REQS > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), PLI.READ_REQS)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP           > 0
          AND PLI.MAX_READ_REQS IS NOT NULL
          AND PLI.READ_REQS      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_read_reqs' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(PLI.MAX_READ_REQS/1000000), 10000), NULL) AS "iid", MOD(PLI.MAX_READ_REQS, 1000000) AS "sid"), TRUNC(PLI.MAX_READ_REQS/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.READ_BYTES > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), PLI.READ_BYTES)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP            > 0
          AND PLI.MAX_READ_BYTES IS NOT NULL
          AND PLI.READ_BYTES      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_read_bytes' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(PLI.MAX_READ_BYTES/1000000), 10000), NULL) AS "iid", MOD(PLI.MAX_READ_BYTES, 1000000) AS "sid"), TRUNC(PLI.MAX_READ_BYTES/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.WRITE_REQS > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), PLI.WRITE_REQS)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP            > 0
          AND PLI.MAX_WRITE_REQS IS NOT NULL
          AND PLI.WRITE_REQS      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_write_reqs' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(PLI.MAX_WRITE_REQS/1000000), 10000), NULL) AS "iid", MOD(PLI.MAX_WRITE_REQS, 1000000) AS "sid"), TRUNC(PLI.MAX_WRITE_REQS/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.WRITE_BYTES > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), PLI.WRITE_BYTES)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP             > 0
          AND PLI.MAX_WRITE_BYTES IS NOT NULL
          AND PLI.WRITE_BYTES      > 0
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_write_bytes' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(PLI.MAX_WRITE_BYTES/1000000), 10000), NULL) AS "iid", MOD(PLI.MAX_WRITE_BYTES, 1000000) AS "sid"), TRUNC(PLI.MAX_WRITE_BYTES/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.IO_INTER_BYTES IS NOT NULL
          AND PLI.IO_BYTES         > 0
          AND PLI.IO_BYTES        != PLI.IO_INTER_BYTES
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('io_inter_bytes' AS "name"), PLI.IO_INTER_BYTES)
          ELSE NULL
        END,
        CASE
          WHEN PLI.DOP                > 0
          AND PLI.MAX_IO_INTER_BYTES IS NOT NULL
          AND PLI.IO_BYTES            > 0
          AND PLI.IO_BYTES           != PLI.IO_INTER_BYTES
          THEN XMLELEMENT( "stat", XMLATTRIBUTES( 'max_io_inter_bytes' AS "name", DECODE(:B65 , 'Y', MOD(TRUNC(MAX_IO_INTER_BYTES/1000000), 10000), NULL) AS "iid", MOD(MAX_IO_INTER_BYTES,1000000) AS "sid"), TRUNC(PLI.MAX_IO_INTER_BYTES/10000000000))
          ELSE NULL
        END,
        CASE
          WHEN PLI.IO_INTER_BYTES IS NOT NULL
          AND PLI.IO_BYTES         > 0
          AND PLI.IO_BYTES        != PLI.IO_INTER_BYTES
          THEN XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(PLI.IO_BYTES / DECODE(PLI.IO_INTER_BYTES, 0, 1, PLI.IO_INTER_BYTES), 2))
          ELSE NULL
        END), NVL2(STAT_GID, XMLELEMENT( "rwsstats", XMLATTRIBUTES( PLI.STAT_GID AS "group_id"), DECODE(GID_ROWNUM, 1,
        (SELECT XMLELEMENT( "metadata", NULL, XMLAGG( XMLELEMENT( "stat", XMLATTRIBUTES( ROWNUM AS "id", NAME AS "name", DESCRIPTION AS "desc", TYPE AS "type", DECODE(FLAGS, 0, NULL, FLAGS) AS "flags"), NULL)
        ORDER BY ID))
        FROM V$SQL_MONITOR_STATNAME
        WHERE GROUP_ID = PLI.STAT_GID
        ), NULL), NVL2(STAT1_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(1 AS "id"), STAT1_VALUE), NULL), NVL2(STAT2_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(2 AS "id"), STAT2_VALUE), NULL), NVL2(STAT3_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(3 AS "id"), STAT3_VALUE), NULL), NVL2(STAT4_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(4 AS "id"), STAT4_VALUE), NULL), NVL2(STAT5_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(5 AS "id"), STAT5_VALUE), NULL), NVL2(STAT6_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(6 AS "id"), STAT6_VALUE), NULL), NVL2(STAT7_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(7 AS "id"), STAT7_VALUE), NULL), NVL2(STAT8_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(8 AS "id"), STAT8_VALUE), NULL), NVL2(STAT9_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(9 AS "id"), STAT9_VALUE), NULL), NVL2(STAT10_VALUE, XMLELEMENT( "stat", XMLATTRIBUTES(10 AS "id"), STAT10_VALUE), NULL)), NULL),
        CASE
          WHEN PLI.LINE_ACTIVITY_COUNT > 0
          AND :B33                     = 1
          THEN XMLELEMENT( "activity_sampled", XMLATTRIBUTES( TO_CHAR(PLI.LINE_ACTIVITY_START, :B12 ) AS "start_time", TO_CHAR(PLI.LINE_ACTIVITY_END, :B12 ) AS "end_time", ROUND((PLI.LINE_ACTIVITY_END - PLI.LINE_ACTIVITY_START) * 3600*24) + 1 AS "duration", PLI.LINE_ACTIVITY_COUNT AS "count", PLI.LINE_WAIT_COUNT AS "wait_count", PLI.LINE_CPU_COUNT AS "cpu_count", PLI.LINE_OTHER_SQL_COUNT AS "other_sql_count", :B40 AS "cpu_cores", :B39 AS "hyperthread"), PLI.ACTIVITY_TOTAL, PLI.PLAN_ACTIVITY_HISTO)
          ELSE NULL
        END)
      ORDER BY PLI.PLAN_LINE_ID) )
      FROM
        (SELECT AT.MAX_LINE_ACTIVITY_COUNT,
          PM.OVERALL_MAX_IO_REQS,
          PM.OVERALL_MAX_IO_BYTES,
          AT.MAX_LINE_CPU_COUNT,
          AT.MAX_LINE_WAIT_COUNT,
          AT.LINE_OTHER_SQL_COUNT,
          AT.MAX_LINE_OTHER_SQL_COUNT,
          PM.PLAN_LINE_ID,
          PM.PARENT_ID,
          PM.OPERATION,
          PM.OPTIONS,
          PM.DEPTH,
          PM.POSITION,
          CASE
            WHEN PM.OPERATION      = 'PX COORDINATOR'
            AND :B23               = 'Y'
            AND (PM.PX_SERVER_SET IS NOT NULL
            OR AH.PX_SERVER_SET   IS NOT NULL)
            THEN 'QC'
            WHEN PM.PX_SERVER_SET IS NOT NULL
            THEN TO_CHAR(PM.PX_SERVER_SET)
            WHEN AH.PX_SERVER_SET IS NOT NULL
            THEN TO_CHAR(AH.PX_SERVER_SET)
            WHEN (:B23                = 'N'
            OR (PM.LAST_CHANGE_TIME  IS NULL
            AND AT.LINE_ACTIVITY_END IS NULL))
            THEN NULL
            ELSE 'QC'
          END PX_TYPE,
          PM.FIRST_CHANGE_TIME,
          AT.LINE_ACTIVITY_START,
          PM.LAST_CHANGE_TIME,
          PM.OVERALL_LAST_CHANGE_TIME,
          AT.LINE_ACTIVITY_END,
          AT.OVERALL_LINE_ACTIVITY_END,
          LEAST(NVL(AT.LINE_ACTIVITY_START, PM.FIRST_CHANGE_TIME), NVL(PM.FIRST_CHANGE_TIME, AT.LINE_ACTIVITY_START)) FIRST_MOVE_TIME,
          GREATEST(NVL(AT.LINE_ACTIVITY_END, PM.LAST_CHANGE_TIME), NVL(PM.LAST_CHANGE_TIME, AT.LINE_ACTIVITY_END)) LAST_MOVE_TIME,
          GREATEST(NVL(AT.OVERALL_LINE_ACTIVITY_END, PM.OVERALL_LAST_CHANGE_TIME), NVL(PM.OVERALL_LAST_CHANGE_TIME, AT.OVERALL_LINE_ACTIVITY_END)) OVERALL_LAST_MOVE_TIME,
          CASE
            WHEN PM.STARTS IS NOT NULL
            AND PM.STARTS   > 0
            THEN 1
            ELSE 0
          END HAS_EXECUTED,
          PM.OBJECT_NAME,
          PM.OBJECT_TYPE,
          PM.OBJECT_OWNER,
          PM.PARTITION_START,
          PM.PARTITION_STOP,
          PM.CARDINALITY,
          PM.BYTES,
          PM.COST,
          PM.TEMP_SPACE,
          PM.TIME,
          PM.CPU_COST,
          PM.IO_COST,
          LO.PERCENT_COMPLETE,
          LO.TIME_REMAINING,
          PM.STARTS,
          PM.DOP,
          PM.MAX_STARTS,
          PM.OUTPUT_ROWS,
          PM.NEED_ROWS,
          PM.MAX_OUTPUT_ROWS,
          PM.MEM,
          PM.MAX_MEM,
          PM.MIN_MAX_MEM,
          PM.TEMP,
          PM.MAX_TEMP,
          PM.SPILL_COUNT,
          PM.MAX_MAX_TEMP,
          PM.READ_REQS,
          PM.MAX_READ_REQS,
          PM.READ_BYTES,
          PM.MAX_READ_BYTES,
          PM.WRITE_REQS,
          PM.MAX_WRITE_REQS,
          PM.WRITE_BYTES,
          PM.MAX_WRITE_BYTES,
          PM.IO_INTER_BYTES,
          PM.IO_BYTES,
          PM.MAX_IO_INTER_BYTES,
          AT.LINE_ACTIVITY_COUNT,
          AT.LINE_WAIT_COUNT,
          AT.LINE_CPU_COUNT,
          AT.ACTIVITY_TOTAL,
          AH.PLAN_ACTIVITY_HISTO,
          PM.STAT_GID,
          PM.GID_ROWNUM,
          PM.STAT1_VALUE,
          PM.STAT2_VALUE,
          PM.STAT3_VALUE,
          PM.STAT4_VALUE,
          PM.STAT5_VALUE,
          PM.STAT6_VALUE,
          PM.STAT7_VALUE,
          PM.STAT8_VALUE,
          PM.STAT9_VALUE,
          PM.STAT10_VALUE
        FROM
          (SELECT AT0.*,
            MAX(LINE_ACTIVITY_END) OVER() OVERALL_LINE_ACTIVITY_END,
            MAX(LINE_ACTIVITY_COUNT) OVER() MAX_LINE_ACTIVITY_COUNT,
            MAX(LINE_CPU_COUNT) OVER() MAX_LINE_CPU_COUNT,
            MAX(LINE_WAIT_COUNT) OVER() MAX_LINE_WAIT_COUNT,
            MAX(LINE_OTHER_SQL_COUNT) OVER() MAX_LINE_OTHER_SQL_COUNT
          FROM
            (SELECT AD1.PLAN_LINE_ID,
              MIN(AD1.LINE_ACTIVITY_START) LINE_ACTIVITY_START,
              MAX(AD1.LINE_ACTIVITY_END) LINE_ACTIVITY_END,
              SUM(AD1.ACTIVITY_COUNT) LINE_ACTIVITY_COUNT,
              SUM(AD1.WAIT_COUNT) LINE_WAIT_COUNT,
              SUM(AD1.OTHER_SQL_COUNT) LINE_OTHER_SQL_COUNT,
              SUM(AD1.CPU_COUNT) LINE_CPU_COUNT,
              SUBSTR(MAX(LPAD(AD1.ACTIVITY_COUNT,10)
              || AD1.ACTIVITY_TYPE), 11) MOST_ACTIVE,
              XMLAGG(XMLELEMENT( "activity", XMLATTRIBUTES( AD1.ACTIVITY_TYPE AS "class", AD1.EVENT_NAME AS "event"), AD1.ACTIVITY_COUNT)
            ORDER BY AD1.ACTIVITY_TYPE, AD1.EVENT_NAME) ACTIVITY_TOTAL
            FROM
              (SELECT AD0.PLAN_LINE_ID,
                AD0.ACTIVITY_TYPE,
                AD0.EVENT_NAME,
                MIN(AD0.ACTIVITY_START) LINE_ACTIVITY_START,
                MAX(AD0.ACTIVITY_END) LINE_ACTIVITY_END,
                SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT,
                SUM(AD0.WAIT_COUNT) WAIT_COUNT,
                SUM(AD0.CPU_COUNT) CPU_COUNT,
                SUM(AD0.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
                MAX(AD0.DFO_MOST_ACTIVE_IID) DFO_MOST_ACTIVE_IID,
                MAX(AD0.DFO_MOST_ACTIVE_SID) DFO_MOST_ACTIVE_SID,
                SUM(AD0.DFO_MOST_ACTIVE_COUNT) DFO_MOST_ACTIVE_COUNT
              FROM ASH_DATA AD0
              WHERE AD0.PLAN_LINE_ID IS NOT NULL
              GROUP BY AD0.PLAN_LINE_ID,
                AD0.ACTIVITY_TYPE,
                AD0.EVENT_NAME
              ) AD1
            GROUP BY AD1.PLAN_LINE_ID
            ) AT0
          ) AT,
          (SELECT AD2.PLAN_LINE_ID,
            MIN(AD2.PX_SERVER_SET) PX_SERVER_SET,
            MIN(AD2.LINE_ACTIVITY_START) LINE_ACTIVITY_START,
            MAX(AD2.LINE_ACTIVITY_END) LINE_ACTIVITY_END,
            SUM(AD2.ACTIVITY_COUNT) ACTIVITY_COUNT,
            SUM(AD2.WAIT_COUNT) WAIT_COUNT,
            SUM(AD2.CPU_COUNT) CPU_COUNT,
            SUM(AD2.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
            CASE
              WHEN :B29                   = 1
              AND SUM(AD2.ACTIVITY_COUNT) > 0
              THEN XMLELEMENT( "activity_histogram", XMLATTRIBUTES( :B26 AS "bucket_interval", :B27 AS "bucket_count", TO_CHAR( :B20 , :B12 ) AS "start_time", TO_CHAR(:B22 , :B12 ) AS "end_time", ROUND((:B22 -:B20 ) *3600*24) + 1 AS "duration"), XMLAGG(XMLELEMENT( "bucket", XMLATTRIBUTES( AD2.BUCKET_NUM AS "number"), AD2.ACTIVITY_BUCKET)
              ORDER BY AD2.BUCKET_NUM))
              ELSE NULL
            END PLAN_ACTIVITY_HISTO
          FROM
            (SELECT AD1.PLAN_LINE_ID,
              AD1.BUCKET_NUM,
              MIN(AD1.PX_SERVER_SET) PX_SERVER_SET,
              MIN(AD1.LINE_ACTIVITY_START) LINE_ACTIVITY_START,
              MAX(AD1.LINE_ACTIVITY_END) LINE_ACTIVITY_END,
              MIN(AD1.BUCKET_ACTIVITY_START) BUCKET_ACTIVITY_START,
              MAX(AD1.BUCKET_ACTIVITY_END) BUCKET_ACTIVITY_END,
              SUM(AD1.ACTIVITY_COUNT) ACTIVITY_COUNT,
              SUM(AD1.WAIT_COUNT) WAIT_COUNT,
              SUM(AD1.CPU_COUNT) CPU_COUNT,
              SUM(AD1.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
              SUBSTR(MAX(LPAD(AD1.ACTIVITY_COUNT,10)
              || AD1.ACTIVITY_TYPE), 11) MOST_ACTIVE,
              XMLAGG(NVL2(AD1.ACTIVITY_TYPE, XMLELEMENT( "activity", XMLATTRIBUTES( AD1.ACTIVITY_TYPE AS "class", AD1.EVENT_NAME AS "event"), AD1.ACTIVITY_COUNT), NULL)
            ORDER BY AD1.ACTIVITY_TYPE, AD1.EVENT_NAME) ACTIVITY_BUCKET
            FROM
              (SELECT AD0.PLAN_LINE_ID,
                AD0.PLAN_ACTIVITY_BUCKET_NUM BUCKET_NUM,
                AD0.ACTIVITY_TYPE,
                AD0.EVENT_NAME,
                MIN(NVL2(AD0.ACTIVITY_START, AD0.PX_SERVER_SET, NULL)) PX_SERVER_SET,
                MIN(AD0.ACTIVITY_START) LINE_ACTIVITY_START,
                MAX(AD0.ACTIVITY_END) LINE_ACTIVITY_END,
                MIN(AD0.BUCKET_ACTIVITY_START) BUCKET_ACTIVITY_START,
                MAX(AD0.BUCKET_ACTIVITY_END) BUCKET_ACTIVITY_END,
                SUM(AD0.CPU_COUNT) CPU_COUNT,
                SUM(AD0.WAIT_COUNT) WAIT_COUNT,
                SUM(AD0.OTHER_SQL_COUNT) OTHER_SQL_COUNT,
                SUM(AD0.ACTIVITY_COUNT) ACTIVITY_COUNT
              FROM ASH_DATA AD0
              GROUP BY AD0.PLAN_LINE_ID,
                AD0.PLAN_ACTIVITY_BUCKET_NUM,
                AD0.ACTIVITY_TYPE,
                AD0.EVENT_NAME
              ) AD1
            GROUP BY AD1.PLAN_LINE_ID,
              AD1.BUCKET_NUM
            ) AD2
          GROUP BY AD2.PLAN_LINE_ID
          ) AH,
          (SELECT LO.SQL_PLAN_LINE_ID PLAN_LINE_ID,
            DECODE(SUM(LO.TOTALWORK), 0, NULL, ROUND(SUM(LO.SOFAR)*100/SUM(LO.TOTALWORK))) PERCENT_COMPLETE,
            MAX(LO.TIME_REMAINING) TIME_REMAINING
          FROM GV$SESSION_LONGOPS LO,
            MONITOR_DATA MO
          WHERE (:B49           = 'Y'
          OR :B68               = 'DONE (ERROR)')
          AND LO.SQL_ID         = :B9
          AND LO.SQL_EXEC_START = :B8
          AND LO.SQL_EXEC_ID    = :B7
          AND LO.INST_ID        = MO.INST_ID
          AND LO.SID            = MO.SID
          GROUP BY LO.SQL_PLAN_LINE_ID
          ) LO,
          (SELECT PM0.*,
            CASE
              WHEN PM0.STARTS    IS NULL
              OR PM0.STARTS       = 0
              OR PM0.OUTPUT_ROWS IS NULL
              THEN NULL
              ELSE 1
            END NEED_ROWS,
            ROW_NUMBER() OVER(PARTITION BY PM0.STAT_GID ORDER BY PM0.PLAN_LINE_ID ) GID_ROWNUM,
            MAX(LAST_CHANGE_TIME) OVER() OVERALL_LAST_CHANGE_TIME,
            MAX(MAX_IO_REQS) OVER() OVERALL_MAX_IO_REQS,
            MAX(MAX_IO_BYTES) OVER() OVERALL_MAX_IO_BYTES
          FROM
            (SELECT
              /*+ leading(mo) use_hash(plm) */
              PLM.PLAN_LINE_ID PLAN_LINE_ID,
              PLM.PLAN_OPERATION OPERATION,
              PLM.PLAN_OPTIONS OPTIONS,
              MAX(PLM.PLAN_PARENT_ID) PARENT_ID,
              MAX(PLM.PLAN_DEPTH) DEPTH,
              MAX(PLM.PLAN_POSITION) POSITION,
              MAX(PLM.PLAN_OBJECT_OWNER) OBJECT_OWNER,
              MAX(PLM.PLAN_OBJECT_NAME) OBJECT_NAME,
              MAX(PLM.PLAN_OBJECT_TYPE) OBJECT_TYPE,
              MAX(PLM.PLAN_COST) COST,
              MAX(PLM.PLAN_CARDINALITY) CARDINALITY,
              MAX(PLM.PLAN_BYTES) BYTES,
              MAX(PLM.PLAN_CPU_COST) CPU_COST,
              MAX(PLM.PLAN_IO_COST) IO_COST,
              MAX(PLM.PLAN_TEMP_SPACE) TEMP_SPACE,
              MAX(PLM.PLAN_TIME) TIME,
              MAX(PLM.PLAN_PARTITION_START) PARTITION_START,
              MAX(PLM.PLAN_PARTITION_STOP) PARTITION_STOP,
              MIN(PLM.FIRST_CHANGE_TIME) FIRST_CHANGE_TIME,
              MAX(PLM.LAST_CHANGE_TIME) LAST_CHANGE_TIME,
              MIN(PLM.LAST_CHANGE_TIME) MIN_LAST_CHANGE_TIME,
              MIN(NVL2(PLM.FIRST_CHANGE_TIME, MO.PX_SERVER_SET, NULL)) PX_SERVER_SET,
              COUNT(
              CASE
                WHEN PLM.PAR           IS NOT NULL
                AND PLM.STARTS         IS NOT NULL
                AND PLM.STARTS          > 0
                AND PLM.PLAN_LINE_ID   != 0
                AND PLM.PLAN_OPERATION != 'PX COORDINATOR'
                THEN 1
                ELSE NULL
              END) DOP,
              SUM(PLM.STARTS) STARTS,
              MAX(NVL2(PAR, PLM.STARTS * 10000000000 + PLM.ES, NULL)) MAX_STARTS,
              SUM(PLM.OUTPUT_ROWS) OUTPUT_ROWS,
              MAX(NVL2(PAR, PLM.OUTPUT_ROWS * 10000000000 +PLM.ES, NULL)) MAX_OUTPUT_ROWS,
              SUM(PLM.WORKAREA_MEM) MEM,
              SUM(PLM.WORKAREA_MAX_MEM) MAX_MEM,
              MIN(NVL2(PAR, PLM.WORKAREA_MAX_MEM * 10000000000 + PLM.ES, NULL)) MIN_MAX_MEM,
              SUM(PLM.WORKAREA_TEMPSEG) TEMP,
              SUM(PLM.WORKAREA_MAX_TEMPSEG) MAX_TEMP,
              MAX(NVL2(PAR, PLM.WORKAREA_MAX_TEMPSEG * 10000000000 + PLM.ES, NULL)) MAX_MAX_TEMP,
              COUNT(PLM.WORKAREA_MAX_TEMPSEG) SPILL_COUNT,
              SUM(PLM.PHYSICAL_READ_REQUESTS) READ_REQS,
              MAX(NVL2(PAR, PLM.PHYSICAL_READ_REQUESTS * 10000000000 + PLM.ES, NULL)) MAX_READ_REQS,
              SUM(PLM.PHYSICAL_READ_BYTES) READ_BYTES,
              MAX(NVL2(PAR, PLM.PHYSICAL_READ_BYTES * 10000000000 + PLM.ES, NULL)) MAX_READ_BYTES,
              SUM(PLM.PHYSICAL_WRITE_REQUESTS) WRITE_REQS,
              MAX(NVL2(PAR, PLM.PHYSICAL_WRITE_REQUESTS * 10000000000 + PLM.ES, NULL)) MAX_WRITE_REQS,
              SUM(PLM.PHYSICAL_WRITE_BYTES) WRITE_BYTES,
              MAX(NVL2(PAR, PLM.PHYSICAL_WRITE_BYTES * 10000000000 + PLM.ES, NULL)) MAX_WRITE_BYTES,
              NVL(SUM(PLM.PHYSICAL_READ_BYTES), 0)   + NVL(SUM(PLM.PHYSICAL_WRITE_BYTES), 0) IO_BYTES,
              SUM(NVL(PLM.PHYSICAL_READ_REQUESTS, 0) + NVL(PLM.PHYSICAL_WRITE_REQUESTS, 0)) MAX_IO_REQS,
              SUM(NVL(PLM.PHYSICAL_READ_BYTES, 0)    + NVL(PLM.PHYSICAL_WRITE_BYTES, 0)) MAX_IO_BYTES,
              SUM(PLM.IO_INTERCONNECT_BYTES) IO_INTER_BYTES,
              MAX(NVL2(PAR, PLM.IO_INTERCONNECT_BYTES * 10000000000 + PLM.ES, NULL)) MAX_IO_INTER_BYTES,
              MAX(OTHERSTAT_GROUP_ID) STAT_GID,
              NVL(DECODE(MAX(OTHERSTAT_1_TYPE), 3, MAX(OTHERSTAT_1_VALUE), 4, MAX(OTHERSTAT_1_VALUE), 6, MIN(OTHERSTAT_1_VALUE), 7, MIN(OTHERSTAT_1_VALUE), NULL), SUM(DECODE(OTHERSTAT_1_TYPE, 1, OTHERSTAT_1_VALUE, 2, OTHERSTAT_1_VALUE, NULL))) STAT1_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_2_TYPE), 3, MAX(OTHERSTAT_2_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_2_VALUE), 7, MIN(RMAX1 + OTHERSTAT_2_VALUE), NULL), 6, MIN(OTHERSTAT_2_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_2_TYPE, 1, OTHERSTAT_2_VALUE, 2, OTHERSTAT_2_VALUE, NULL))) STAT2_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_3_TYPE), 3, MAX(OTHERSTAT_3_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_3_VALUE), 7, MIN(RMAX1 + OTHERSTAT_3_VALUE), NULL), 6, MIN(OTHERSTAT_3_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_3_TYPE, 1, OTHERSTAT_3_VALUE, 2, OTHERSTAT_3_VALUE, NULL))) STAT3_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_4_TYPE), 3, MAX(OTHERSTAT_4_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_4_VALUE), 7, MIN(RMAX1 + OTHERSTAT_4_VALUE), NULL), 6, MIN(OTHERSTAT_4_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_4_TYPE, 1, OTHERSTAT_4_VALUE, 2, OTHERSTAT_4_VALUE, NULL))) STAT4_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_5_TYPE), 3, MAX(OTHERSTAT_5_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_5_VALUE), 7, MIN(RMAX1 + OTHERSTAT_5_VALUE), NULL), 6, MIN(OTHERSTAT_5_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_5_TYPE, 1, OTHERSTAT_5_VALUE, 2, OTHERSTAT_5_VALUE, NULL))) STAT5_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_6_TYPE), 3, MAX(OTHERSTAT_6_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_6_VALUE), 7, MIN(RMAX1 + OTHERSTAT_6_VALUE), NULL), 6, MIN(OTHERSTAT_6_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_6_TYPE, 1, OTHERSTAT_6_VALUE, 2, OTHERSTAT_6_VALUE, NULL))) STAT6_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_7_TYPE), 3, MAX(OTHERSTAT_7_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_7_VALUE), 7, MIN(RMAX1 + OTHERSTAT_7_VALUE), NULL), 6, MIN(OTHERSTAT_7_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_7_TYPE, 1, OTHERSTAT_7_VALUE, 2, OTHERSTAT_7_VALUE, NULL))) STAT7_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_8_TYPE), 3, MAX(OTHERSTAT_8_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_8_VALUE), 7, MIN(RMAX1 + OTHERSTAT_8_VALUE), NULL), 6, MIN(OTHERSTAT_8_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_8_TYPE, 1, OTHERSTAT_8_VALUE, 2, OTHERSTAT_8_VALUE, NULL))) STAT8_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_9_TYPE), 3, MAX(OTHERSTAT_9_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1   + OTHERSTAT_9_VALUE), 7, MIN(RMAX1 + OTHERSTAT_9_VALUE), NULL), 6, MIN(OTHERSTAT_9_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_9_TYPE, 1, OTHERSTAT_9_VALUE, 2, OTHERSTAT_9_VALUE, NULL))) STAT9_VALUE,
              NVL(MOD((DECODE(MAX(OTHERSTAT_10_TYPE), 3, MAX(OTHERSTAT_10_VALUE), 5, DECODE(MAX(OTHERSTAT_1_TYPE), 4, MAX(RMAX1 + OTHERSTAT_10_VALUE), 7, MIN(RMAX1 + OTHERSTAT_10_VALUE), NULL), 6, MIN(OTHERSTAT_10_VALUE), NULL)), 10000000000000000), SUM(DECODE(OTHERSTAT_10_TYPE, 1, OTHERSTAT_10_VALUE, 2, OTHERSTAT_10_VALUE, NULL))) STAT10_VALUE
            FROM
              (SELECT A.*,
                OTHERSTAT_1_VALUE * 10000000000000000 RMAX1,
                A.INST_ID         * 1000000 + A.SID ES,
                DECODE(A.PROCESS_NAME, 'ora', NULL, 1) PAR
              FROM GV$SQL_PLAN_MONITOR A
              ) PLM,
              MONITOR_DATA MO
            WHERE PLM.SQL_ID       = :B9
            AND PLM.SQL_EXEC_START = :B8
            AND PLM.SQL_EXEC_ID    = :B7
            AND PLM.INST_ID        = MO.INST_ID
            AND PLM.INST_ID BETWEEN :B11 AND :B10
            AND PLM.KEY = MO.KEY
            GROUP BY PLM.PLAN_LINE_ID,
              PLM.PLAN_OPERATION,
              PLM.PLAN_OPTIONS
            ) PM0
          ) PM
        WHERE AH.PLAN_LINE_ID(+) = PM.PLAN_LINE_ID
        AND AT.PLAN_LINE_ID(+)   = PM.PLAN_LINE_ID
        AND LO.PLAN_LINE_ID(+)   = PM.PLAN_LINE_ID
        AND (:B21               IS NULL
        OR PM.PLAN_LINE_ID       = :B21 )
        ) PLI
      )
    ELSE NULL
  END,
  CASE
    WHEN :B42 = 1
    THEN DBMS_SQLTUNE.BUILD_STASH_XML( SESSION_ID=>:B19 , SESSION_SERIAL=>:B18 , SESSION_INST_ID=>:B17 , PX_MODE=>'yes', START_TIME=>:B20 , END_TIME=>:B22 , MISSING_SECONDS=> :B41 , INSTANCE_LOW_FILTER=>:B11 , INSTANCE_HIGH_FILTER=>:B10 , BUCKET_MAX_COUNT=>NULL, BUCKET_INTERVAL=>:B26 , REPORT_LEVEL=>'typical', CPU_CORES=>:B40 , IS_HYPER=>:B39 )
    ELSE NULL
  END),
  (
  CASE
    WHEN :B38 = 1
    THEN
      (SELECT XMLELEMENT( "skewed_sessions", XMLATTRIBUTES( DECODE(MIN(INST_ID), NULL, :B17 , MIN(INST_ID)) AS "min_iid", DECODE(MAX(INST_ID), NULL, :B17 , MAX(INST_ID)) AS "max_iid"), XMLAGG( XMLELEMENT( "s", XMLATTRIBUTES( INST_ID AS "i"), SESSION_ID)
      ORDER BY INST_ID, SESSION_ID))
      FROM
        (SELECT SESS.*
        FROM
          (SELECT DECODE(AD.DFO_MOST_ACTIVE_IID, :B17 , NULL, AD.DFO_MOST_ACTIVE_IID) INST_ID,
            AD.DFO_MOST_ACTIVE_SID SESSION_ID
          FROM ASH_DATA AD
          WHERE AD.DFO_MOST_ACTIVE_COUNT IS NOT NULL
          GROUP BY AD.DFO_MOST_ACTIVE_IID,
            AD.DFO_MOST_ACTIVE_SID
          ORDER BY MAX(AD.DFO_MOST_ACTIVE_COUNT) DESC
          ) SESS
        WHERE ROWNUM <= 100
        )
      )
    ELSE NULL
  END),
  (
  CASE
    WHEN :B37 = 1
    THEN
      (SELECT XMLELEMENT( "report_repository_summary",
        CASE
          WHEN MA.MAX_DBOP_NAME IS NOT NULL
          THEN XMLELEMENT( "dbop", XMLATTRIBUTES('F' AS "detail", MA.MAX_DBOP_NAME AS "dbop_name", TO_CHAR(MA.MIN_FIRST_REFRESH_TIME, :B12 ) AS "dbop_exec_start", MA.MAX_DBOP_EXEC_ID AS "dbop_exec_id"), XMLFOREST( MA.MAX_STATUS AS "status", TO_CHAR(NVL(MA.MAX_SQL_EXEC_START, MA.MIN_FIRST_REFRESH_TIME), :B12 )AS "first_refresh_time", TO_CHAR(MA.MAX_LAST_REFRESH_TIME, :B12 )AS "last_refresh_time", MA.SUM_REFRESH_COUNT AS "refresh_count", MA.MAX_INST_ID AS "inst_id", MA.MAX_SESSION_ID AS "session_id", MA.MAX_SESSION_SERIAL AS "session_serial", MA.MAX_USERID AS "user_id", MA.MAX_USERNAME AS "user", MA.MAX_CON_ID AS "con_id", MA.MAX_CON_NAME AS "con_name", MA.MAX_MODULE AS "module", MA.MAX_ACTION AS "action", MA.MAX_SERVICE_NAME AS "service", MA.MAX_CLIENT_ID AS "client_id", MA.MAX_CLIENT_INFO AS "client_info", MA.MAX_PROGRAM AS "program", MA.MAX_PL_ENTRY_OID AS "plsql_entry_object_id", MA.MAX_PL_ENTRY_PROGID AS "plsql_entry_subprogram_id", MA.MAX_PL_OID AS "plsql_object_id",
            MA.MAX_PL_PROGID                         AS "plsql_subprogram_id", MA.MAX_PX_IS_CROSS_INSTANCE AS "is_cross_instance", MA.MAX_PX_DOP AS "dop", MA.MAX_PX_DOP_INSTANCES AS "instances"),
            CASE
              WHEN MA.MAX_ERROR_NUMBER IS NULL
              THEN NULL
              ELSE XMLELEMENT( "error", XMLATTRIBUTES(MA.MAX_ERROR_NUMBER AS "number", MA.MAX_ERROR_FACILITY AS "facility"), MA.MAX_ERROR_MESSAGE)
            END, XMLELEMENT( "stats", XMLATTRIBUTES('monitor'             AS "type"), XMLELEMENT( "stat", XMLATTRIBUTES('duration' AS "name"), GREATEST(ROUND((MA.MAX_LAST_REFRESH_TIME- NVL(MA.MAX_SQL_EXEC_START, MA.MIN_FIRST_REFRESH_TIME))*86400), LEAST(MA.SUM_ELAPSED_TIME/1000000, 1), CEIL(MA.MAX_QUEUING_TIME/1000000))), DECODE(MA.SUM_ELAPSED_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), MA.SUM_ELAPSED_TIME)), DECODE(MA.MAX_QUEUING_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MA.MAX_QUEUING_TIME)), DECODE(MA.SUM_CPU_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), MA.SUM_CPU_TIME)), DECODE(MA.SUM_USER_IO_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_io_wait_time' AS "name"), MA.SUM_USER_IO_WAIT_TIME)), DECODE(MA.SUM_APPLICATION_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), MA.SUM_APPLICATION_WAIT_TIME)), DECODE(MA.SUM_CONCURRENCY_WAIT_TIME, 0,
            NULL, XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time'            AS "name"), MA.SUM_CONCURRENCY_WAIT_TIME)), DECODE(MA.SUM_CLUSTER_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), MA.SUM_CLUSTER_WAIT_TIME)), DECODE(MA.SUM_PLSQL_EXEC_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time' AS "name"), MA.SUM_PLSQL_EXEC_TIME)), DECODE(MA.SUM_JAVA_EXEC_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), MA.SUM_JAVA_EXEC_TIME)), DECODE(MA.SUM_OTHER_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('other_wait_time' AS "name"), MA.SUM_OTHER_WAIT_TIME)), DECODE(MA.SUM_FETCHES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS "name"), MA.SUM_FETCHES)), DECODE(MA.SUM_BUFFER_GETS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), MA.SUM_BUFFER_GETS)), DECODE(MA.SUM_READ_REQS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), MA.SUM_READ_REQS)), DECODE(
            MA.SUM_READ_BYTES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), MA.SUM_READ_BYTES)), DECODE(MA.SUM_WRITE_REQS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), MA.SUM_WRITE_REQS)), DECODE(MA.SUM_WRITE_BYTES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), MA.SUM_WRITE_BYTES)),
            CASE
              WHEN MA.SUM_IO_INTER_BYTES IS NULL
              OR MA.SUM_IO_INTER_BYTES    = MA.SUM_IO_BYTES
              OR MA.SUM_IO_BYTES          = 0
              THEN NULL
              ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(MA.SUM_IO_BYTES / DECODE(MA.SUM_IO_INTER_BYTES, 0, 1, MA.SUM_IO_INTER_BYTES), 2))
            END) )
          ELSE XMLELEMENT( "sql", XMLATTRIBUTES( MA.MAX_SQL_ID AS "sql_id", TO_CHAR(MA.MAX_SQL_EXEC_START, :B12 ) AS "sql_exec_start", MA.MAX_SQL_EXEC_ID AS "sql_exec_id"), XMLFOREST(MA.MAX_STATUS AS "status", SUBSTR(MA.SQLMON_TEXT, 1, 100) AS "sql_text", TO_CHAR(MA.MIN_FIRST_REFRESH_TIME, :B12 ) AS "first_refresh_time", TO_CHAR(MA.MAX_LAST_REFRESH_TIME, :B12 ) AS "last_refresh_time", MA.SUM_REFRESH_COUNT AS "refresh_count", MA.MAX_INST_ID AS "inst_id", MA.MAX_SESSION_ID AS "session_id", MA.MAX_SESSION_SERIAL AS "session_serial", MA.MAX_USERID AS "user_id", MA.MAX_USERNAME AS "user", MA.MAX_CON_ID AS "con_id", MA.MAX_CON_NAME AS "con_name", MA.MAX_MODULE AS "module", MA.MAX_ACTION AS "action", MA.MAX_SERVICE_NAME AS "service", MA.MAX_CLIENT_ID AS "client_id", MA.MAX_CLIENT_INFO AS "client_info", MA.MAX_PROGRAM AS "program", MA.MAX_PLAN_HASH_VALUE AS "plan_hash", MA.MAX_PL_ENTRY_OID AS "plsql_entry_object_id", MA.MAX_PL_ENTRY_PROGID AS "plsql_entry_subprogram_id", MA.MAX_PL_OID AS
            "plsql_object_id", MA.MAX_PL_PROGID                AS "plsql_subprogram_id", MA.MAX_PX_IS_CROSS_INSTANCE AS "is_cross_instance", MA.MAX_PX_DOP AS "dop", MA.MAX_PX_DOP_INSTANCES AS "instances", MA.SUM_SERVERS_REQUESTED AS "px_servers_requested", MA.SUM_SERVERS_ALLOCATED AS "px_servers_allocated"), XMLELEMENT( "stats", XMLATTRIBUTES('monitor' AS "type"), XMLELEMENT( "stat", XMLATTRIBUTES('duration' AS "name"), GREATEST(ROUND((MA.MAX_LAST_REFRESH_TIME- MA.MAX_SQL_EXEC_START)*86400), LEAST(MA.SUM_ELAPSED_TIME/1000000, 1), CEIL(MA.MAX_QUEUING_TIME/1000000))), DECODE(MA.SUM_ELAPSED_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('elapsed_time' AS "name"), MA.SUM_ELAPSED_TIME)), DECODE(MA.MAX_QUEUING_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('queuing_time' AS "name"), MA.MAX_QUEUING_TIME)), DECODE(MA.SUM_CPU_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cpu_time' AS "name"), MA.SUM_CPU_TIME)), DECODE(MA.SUM_USER_IO_WAIT_TIME, 0, NULL, XMLELEMENT( "stat",
            XMLATTRIBUTES('user_io_wait_time'                                                                              AS "name"), MA.SUM_USER_IO_WAIT_TIME)), DECODE(MA.SUM_APPLICATION_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('application_wait_time' AS "name"), MA.SUM_APPLICATION_WAIT_TIME)), DECODE(MA.SUM_CONCURRENCY_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('concurrency_wait_time' AS "name"), MA.SUM_CONCURRENCY_WAIT_TIME)), DECODE(MA.SUM_CLUSTER_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('cluster_wait_time' AS "name"), MA.SUM_CLUSTER_WAIT_TIME)), DECODE(MA.SUM_PLSQL_EXEC_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('plsql_exec_time' AS "name"), MA.SUM_PLSQL_EXEC_TIME)), DECODE(MA.SUM_JAVA_EXEC_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('java_exec_time' AS "name"), MA.SUM_JAVA_EXEC_TIME)), DECODE(MA.SUM_OTHER_WAIT_TIME, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('other_wait_time' AS "name"), MA.SUM_OTHER_WAIT_TIME)), DECODE(MA.SUM_FETCHES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('user_fetch_count' AS
            "name"), MA.SUM_FETCHES)), DECODE(MA.SUM_BUFFER_GETS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('buffer_gets' AS "name"), MA.SUM_BUFFER_GETS)), DECODE(MA.SUM_READ_REQS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_reqs' AS "name"), MA.SUM_READ_REQS)), DECODE(MA.SUM_READ_BYTES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('read_bytes' AS "name"), MA.SUM_READ_BYTES)), DECODE(MA.SUM_WRITE_REQS, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_reqs' AS "name"), MA.SUM_WRITE_REQS)), DECODE(MA.SUM_WRITE_BYTES, 0, NULL, XMLELEMENT( "stat", XMLATTRIBUTES('write_bytes' AS "name"), MA.SUM_WRITE_BYTES)),
            CASE
              WHEN MA.SUM_IO_INTER_BYTES IS NULL
              OR MA.SUM_IO_INTER_BYTES    = MA.SUM_IO_BYTES
              OR MA.SUM_IO_BYTES          = 0
              THEN NULL
              ELSE XMLELEMENT( "stat", XMLATTRIBUTES('cell_offload_efficiency' AS "name"), ROUND(MA.SUM_IO_BYTES / DECODE(MA.SUM_IO_INTER_BYTES, 0, 1, MA.SUM_IO_INTER_BYTES), 2))
            END) )
        END)
      FROM MONITOR_AGG MA
      )
    ELSE NULL
  END)
FROM
  (SELECT
    CASE
      WHEN V1.XPLAN_XML                   IS NULL
      OR V1.XPLAN_XML.EXISTSNODE('/error') > 0
      THEN NULL
      ELSE V1.XPLAN_XML
    END XPLAN_XML
  FROM
    (SELECT
      CASE
        WHEN :B36 = 1
        THEN DBMS_XPLAN.BUILD_PLAN_XML(TABLE_NAME=>'gv$sql_plan', PLAN_TAG=>'plan', FILTER_PREDS=>:B35 , FORMAT=>'+PROJECTION +ALIAS')
        ELSE NULL
      END XPLAN_XML
    FROM DUAL
    ) V1
  ) CONST_VIEW;


  CREATE OR REPLACE PACKAGE BODY CUSTOMERACCOUNT AS

	TYPE REVERSED_INTEREST_CURSOR IS REF CURSOR RETURN "AccountEntries"%ROWTYPE;

	AE_COLUMN_VALIDATION_DATE CONSTANT STRING(30) := 'ValidationDate';
	AE_COLUMN_ACCOUNTING_DATE CONSTANT STRING(30) := 'AccountingDate';

/*******************************************************************************/  
	-- internal function to get a lock handle
	-- (private for use by request_lock and release_lock)
	FUNCTION "GetHandle" (lock_name IN VARCHAR2) RETURN VARCHAR2 IS
		lock_handle VARCHAR2(128);
	BEGIN
		DBMS_LOCK.ALLOCATE_UNIQUE (
			lockname => lock_name,
			lockhandle => lock_handle,
			expiration_secs => 864000); -- 10 days
		RETURN lock_handle;
	END "GetHandle";

/*******************************************************************************/	
	-- wrapper function to Request a lock; returns a lock handle
	PROCEDURE "RequestLock"(lock_name IN VARCHAR2) IS
		lock_status NUMBER;
	BEGIN
		lock_status := DBMS_LOCK.REQUEST(
		lockhandle => "GetHandle"(lock_name),
		lockmode => DBMS_LOCK.X_MODE, -- eXclusive
		timeout => DBMS_LOCK.MAXWAIT, -- wait forever
		release_on_commit => FALSE);
	CASE lock_status
		WHEN 0 THEN NULL;
		WHEN 2 THEN CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('LockDeadlockDetected', null);
		WHEN 4 THEN CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('LockAlreadyObtained', null);
		ELSE CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('LockRequestFailed', lock_status);
	END CASE;
	END "RequestLock";

/*******************************************************************************/
	-- wrapper to release a lock; call with the lock handle obtained previously
	PROCEDURE "ReleaseLock" (lock_name IN VARCHAR2) IS
		lock_status NUMBER;
	BEGIN
		lock_status := DBMS_LOCK.RELEASE(
		lockhandle => "GetHandle"(lock_name));
	IF lock_status > 0 THEN
	 CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('LockReleaseFailed', lock_status);
	END IF;

	END "ReleaseLock";

/*******************************************************************************/
	FUNCTION "GenerateNewStatementNumber" (ACCOUNT "Accounts"%ROWTYPE)
		RETURN VARCHAR2 IS NEW_STATEMENT_NUMBER VARCHAR2(20);
	BEGIN
		RETURN STATEMENTNUMBER_SEQ.NEXTVAL;
	END;

/*******************************************************************************/
	PROCEDURE "CancelStatements" (ACCOUNT_ID IN NUMBER, DATE_TO IN DATE)
	AS
		ACCOUNTED_EXPECTATION_COUNT NUMBER := 0;
		CANCELLED_STATEMENS$ T_NUMBER_ARRAY;
	BEGIN
		
		IF DATE_TO <= TRUNC(SYSTEMTIME) THEN
			CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('StatementWithDueDayCancel', NULL);
		END IF;      

		SELECT COUNT(*) INTO ACCOUNTED_EXPECTATION_COUNT
		FROM "Statements" 
		JOIN "Expectations" ON "Statements"."Id" = "Expectations"."Statement_Id" 
		WHERE
			"Statements"."Account_Id" = ACCOUNT_ID
			AND "Statements"."AccountingPeriodEndDate" > TRUNC(DATE_TO)
			AND "Expectations"."Status" =  APPLICATIONVALUES.ES_ACCOUNTED;

		IF ACCOUNTED_EXPECTATION_COUNT > 0 THEN
			CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('StatementAlreadyAccounted', NULL);
		END IF;

		UPDATE "Statements" SET "Status" = APPLICATIONVALUES.SS_CANCELLED 
		WHERE "Account_Id" = ACCOUNT_ID AND "AccountingPeriodEndDate" >= TRUNC(DATE_TO)
		RETURNING "Id" 
		BULK COLLECT INTO CANCELLED_STATEMENS$;
		
		IF CANCELLED_STATEMENS$ IS NOT NULL AND CANCELLED_STATEMENS$.COUNT > 0 THEN

			UPDATE "Expectations" SET "Status" = APPLICATIONVALUES.ES_CREATED, "Statement_Id" = NULL
			WHERE "Statement_Id" IN (SELECT COLUMN_VALUE FROM TABLE(CANCELLED_STATEMENS$))
				AND "Status" IN (APPLICATIONVALUES.ES_STATED);

			UPDATE "AccountEntries" SET "Status" = APPLICATIONVALUES.AES_CREATED, "Statement_Id" = NULL
			WHERE "Statement_Id" IN (SELECT COLUMN_VALUE FROM TABLE(CANCELLED_STATEMENS$));

		END IF;

	END;

/*******************************************************************************/
	FUNCTION "GetDateFromDueDay"(DUE_DAY IN INTEGER, MONTH_DATE DATE)
		RETURN DATE IS RESULT_DATE DATE;
		FIRST_DATE_IN_MONTH DATE := TRUNC(MONTH_DATE, 'MONTH');
		MONTH_LAST_DAY INTEGER;
		VALID_DUE_DAY INTEGER := DUE_DAY;
	BEGIN

		MONTH_LAST_DAY := EXTRACT(DAY FROM LAST_DAY(FIRST_DATE_IN_MONTH));

		IF VALID_DUE_DAY > MONTH_LAST_DAY THEN
			VALID_DUE_DAY := MONTH_LAST_DAY;
		END IF;

		RESULT_DATE := (FIRST_DATE_IN_MONTH-1) + VALID_DUE_DAY;
		RETURN RESULT_DATE;
	END;

/*******************************************************************************/
	FUNCTION "CorrectToBusinessDayDown" (SEARCH_DATE IN DATE) RETURN DATE 
	IS
		BUSINESS_DAY DATE;
		TYPE T_DATES IS TABLE OF DATE NOT NULL;
		HOLIDAY_COLLECTION$ T_DATES := T_DATES();
	BEGIN

		SELECT DISTINCT "Day" BULK COLLECT INTO HOLIDAY_COLLECTION$ 
		FROM
		(
			SELECT TRUNC(TO_DATE(TO_CHAR("Day", '00') || TO_CHAR("Month", '00') || EXTRACT(YEAR FROM SYSTEMTIME), 'DDMMYYYY')) "Day" FROM "RecurringCalendars"
			UNION
			SELECT TRUNC(TO_DATE(TO_CHAR("Day", '00') || TO_CHAR("Month", '00') || EXTRACT(YEAR FROM SEARCH_DATE), 'DDMMYYYY')) "Day" FROM "RecurringCalendars"
			UNION
			SELECT TRUNC("Day") "Day" FROM "IndividualCalendars"
		)
		WHERE "Day" >= SYSTEMTIME AND "Day" <= SEARCH_DATE
		ORDER BY "Day" DESC;

		BUSINESS_DAY := SEARCH_DATE;
		WHILE (
			(BUSINESS_DAY MEMBER OF HOLIDAY_COLLECTION$) -- date is not part of holiday collection
			OR 
			TO_CHAR (BUSINESS_DAY, 'DY', 'NLS_DATE_LANGUAGE=ENGLISH') IN ('SAT', 'SUN') -- date is not weekend
		)
		LOOP
			BUSINESS_DAY := BUSINESS_DAY - 1;

			IF (TRUNC(BUSINESS_DAY) = TRUNC(SYSTEMTIME)) THEN
				RETURN TRUNC(SYSTEMTIME);
			END IF;
		END LOOP;

		RETURN BUSINESS_DAY; 
	END;

/*******************************************************************************/
	FUNCTION "CorrectToBusinessDayUp" (SEARCH_DATE IN DATE) RETURN DATE 
	IS
		BUSINESS_DAY DATE;
		CURRENT_YEAR INT := EXTRACT(YEAR FROM SEARCH_DATE);
		
		TYPE T_DATES IS TABLE OF DATE NOT NULL;
		HOLIDAY_COLLECTION$ T_DATES;
	BEGIN
		SELECT DISTINCT "Day" BULK COLLECT INTO HOLIDAY_COLLECTION$ FROM
		(
			SELECT TRUNC(TO_DATE(TO_CHAR("Day", '00') || TO_CHAR("Month", '00') || CURRENT_YEAR, 'DDMMYYYY')) "Day" FROM "RecurringCalendars"
			UNION
			SELECT TRUNC("Day") "Day" FROM "IndividualCalendars"
		)
		
		WHERE "Day" >= SEARCH_DATE
		ORDER BY "Day";
		
		BUSINESS_DAY := SEARCH_DATE;
		WHILE ( 
			(BUSINESS_DAY MEMBER OF HOLIDAY_COLLECTION$) -- date is not part of holiday collection
			OR 
			TO_CHAR (BUSINESS_DAY, 'DY', 'NLS_DATE_LANGUAGE=ENGLISH') IN ('SAT', 'SUN') -- date is not weekend
		)
		LOOP
			BUSINESS_DAY := BUSINESS_DAY + 1;
			
			IF (CURRENT_YEAR <> EXTRACT(YEAR FROM BUSINESS_DAY)) THEN
				RETURN "CorrectToBusinessDayUp" (BUSINESS_DAY);
			END IF;
		END LOOP;
		
		RETURN BUSINESS_DAY; 
	END;

/*******************************************************************************/
	FUNCTION "GetStatementMinimumPayment" (ACCOUNT_ID NUMBER, PERIOD_DATE DATE, EXTRA_AMOUNT NUMBER, PLANNED_PAYMENT NUMBER)
	RETURN NUMBER IS MINIMUM_PAYMENT NUMBER := 0;
		TEMPLATE "Templates"%ROWTYPE;
		ACCOUNT_BALANCE NUMBER;
		EXPECTED_BALANCE NUMBER;
		EXPECTED_MINIMUM_PAYMENT NUMBER := 0;
	BEGIN
	
		TEMPLATE := "GetRelatedTemplate"(ACCOUNT_ID, PERIOD_DATE);
		
		BEGIN
			SELECT "Balance" INTO ACCOUNT_BALANCE FROM (SELECT "Balance" FROM "AccountEntries" WHERE "Account_Id" = ACCOUNT_ID ORDER BY "Id" DESC) 
			WHERE ROWNUM = 1;
			
			EXCEPTION WHEN NO_DATA_FOUND THEN
				ACCOUNT_BALANCE := 0;
		END;
		
		EXPECTED_BALANCE := ACCOUNT_BALANCE + EXTRA_AMOUNT;

		-- UsePaymentPlan criteria
		IF (TEMPLATE."UsePaymentPlan" = 1) THEN
			IF PLANNED_PAYMENT IS NULL THEN
				CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('NoPaymentPlanAmountFound', NULL);
			END IF;

			MINIMUM_PAYMENT := PLANNED_PAYMENT;
			--IF EXPECTED_BALANCE < 0 THEN 
			--  MINIMUM_PAYMENT := PLANNED_PAYMENT;
			--END IF;
		END IF;

		-- MinimumPositiveAmount criteria
		-- IF UsePaymentPlan = 0 (do not use PaymentPlan) AND EXPECTED_BALANCE > MinimumPositiveAmount => min.payment = 0
		IF (TEMPLATE."MinimumPositiveAmount" IS NOT NULL AND EXPECTED_BALANCE > TEMPLATE."MinimumPositiveAmount") THEN
			RETURN ROUND(MINIMUM_PAYMENT); 
		END IF;

		-- MinimumPercentPayment criteria
		IF (TEMPLATE."MinimumPercentPayment" IS NOT NULL) THEN
			IF EXPECTED_BALANCE < 0 AND TEMPLATE."MinimumPercentPayment" > 0 THEN
				EXPECTED_MINIMUM_PAYMENT := -EXPECTED_BALANCE / 100 * TEMPLATE."MinimumPercentPayment";
			END IF;
		END IF;

		-- MinimumPositiveAmount criteria
		IF (TEMPLATE."MinimumPositiveAmount" IS NOT NULL) THEN 
			IF (EXPECTED_BALANCE < TEMPLATE."MinimumPositiveAmount") THEN
				EXPECTED_MINIMUM_PAYMENT := TEMPLATE."MinimumPositiveAmount" - EXPECTED_BALANCE;
			END IF;
		END IF;

		-- CreditLimit criteria
		IF (TEMPLATE."CreditLimit" IS NOT NULL) THEN 
			IF ((-EXPECTED_BALANCE - EXPECTED_MINIMUM_PAYMENT) > TEMPLATE."CreditLimit") THEN
				EXPECTED_MINIMUM_PAYMENT := -(EXPECTED_BALANCE + TEMPLATE."CreditLimit");
			END IF;
		END IF;

		-- apply criteria 
		IF (TEMPLATE."UsePaymentPlan" = 0) THEN 
			MINIMUM_PAYMENT := EXPECTED_MINIMUM_PAYMENT;
		END IF;

		IF (TEMPLATE."UsePaymentPlan" = 1 AND EXPECTED_MINIMUM_PAYMENT > MINIMUM_PAYMENT) THEN 
				MINIMUM_PAYMENT := EXPECTED_MINIMUM_PAYMENT;
		END IF;

		RETURN ROUND(MINIMUM_PAYMENT);
	END;

/*******************************************************************************/ 
	FUNCTION "GetPlannedPayment" (ACCOUNT_ID NUMBER, PERIOD_DATE DATE)
		RETURN NUMBER IS PLANNED_PAYMENT NUMBER;
		TRUNCATED_DATE DATE := TRUNC(PERIOD_DATE);
		CURRENT_MONTH INTEGER := EXTRACT (MONTH FROM TRUNCATED_DATE); 
	BEGIN
		SELECT
			CASE
				WHEN CURRENT_MONTH = 1 THEN PP."January"
				WHEN CURRENT_MONTH = 2 THEN PP."February"
				WHEN CURRENT_MONTH = 3 THEN PP."March"
				WHEN CURRENT_MONTH = 4 THEN PP."April"
				WHEN CURRENT_MONTH = 5 THEN PP."May"
				WHEN CURRENT_MONTH = 6 THEN PP."June"
				WHEN CURRENT_MONTH = 7 THEN PP."July"
				WHEN CURRENT_MONTH = 8 THEN PP."August"
				WHEN CURRENT_MONTH = 9 THEN PP."September"
				WHEN CURRENT_MONTH = 10 THEN PP."October"
				WHEN CURRENT_MONTH = 11 THEN PP."November"
				WHEN CURRENT_MONTH = 12 THEN PP."December"
			END "Amount" 
		INTO PLANNED_PAYMENT 
		FROM "PaymentPlans" PP
		WHERE PP."Account_Id" = ACCOUNT_ID 
			AND PP."TimeValidity_ValidFrom" <= TRUNCATED_DATE 
			AND (PP."TimeValidity_ValidTo" >= TRUNCATED_DATE OR PP."TimeValidity_ValidTo" IS NULL);

		RETURN PLANNED_PAYMENT;

		EXCEPTION WHEN NO_DATA_FOUND THEN
			RETURN NULL;

	END "GetPlannedPayment";

/*******************************************************************************/ 
	FUNCTION "GetRelatedTemplate" (ACCOUNT_ID NUMBER, PERIOD_DATE DATE)
	RETURN "Templates"%ROWTYPE IS TEMPLATE "Templates"%ROWTYPE;
	BEGIN
		SELECT T.* INTO TEMPLATE 
		FROM "Templates" T 
		INNER JOIN "AccountTemplates" AT ON T."Id" = AT."Template_Id"
		WHERE AT."Account_Id" = ACCOUNT_ID 
			AND AT."TimeValidity_ValidFrom" <= PERIOD_DATE 
			AND (AT."TimeValidity_ValidTo" >= PERIOD_DATE OR AT."TimeValidity_ValidTo" IS NULL);

		RETURN TEMPLATE;

		EXCEPTION WHEN NO_DATA_FOUND THEN
			CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('AccountTemplateNotFound', '(Account ID: ' || ACCOUNT_ID || '; Date: ' || PERIOD_DATE || '). ');

	END "GetRelatedTemplate";

/*******************************************************************************/
	PROCEDURE "SearchEntriesToReverse"(ACCOUNT_ID IN NUMBER, TARGET_DATE IN DATE, TARGET_BALANCE IN NUMBER, RETURNED_ENTRIES OUT T_OUT_CURSOR)
	AS
		USED_TARGET_DATE DATE := TARGET_DATE;
		USED_TARGET_BALANCE NUMBER := TARGET_BALANCE;
	BEGIN
		IF (TARGET_DATE IS NULL AND TARGET_BALANCE IS NULL) OR
					 (TARGET_DATE IS NOT NULL AND TARGET_BALANCE IS NOT NULL) THEN
			 CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('InvalidParameterValue', NULL);
		END IF;

/*
				There are used two ways how to find out entries: by TARGET_DATE and by TARGET_BALANCE			
				One of those parameters should be null, in this case is set to value which doesnt influence WHERE condition below.
*/
		IF TARGET_DATE IS NULL THEN
			USED_TARGET_DATE := TO_DATE('00010101', 'YYYYMMDD');
		END IF;

		IF TARGET_BALANCE IS NULL THEN
			USED_TARGET_BALANCE := 9999999999999999999.99;
		END IF;

		OPEN RETURNED_ENTRIES FOR
		SELECT
			AEV."Id", 
			AEV."TransactionType", 
			AEV."Created", 
			AEV."CreatedBy", 
			AEV."ValidFrom", 
			AEV."ValidTo", 
			AEV."Amount", 
			AEV."Visibility", 
			AEV."Status",
			AEV."Balance", 
			AEV."InterestPercent", 
			AEV."AccountingDate", 
			AEV."ValidationDate", 
			AEV."Statement_Id", 
			AEV."Account_Id", 
			AEV."OriginalEntry_Id", 
			AEV."LastChange_ChangedBy", 
			AEV."LastChange_Changed"
		FROM "AccountEntryView" AEV
		WHERE "Account_Id" = ACCOUNT_ID
			AND "AccountingDate" >= USED_TARGET_DATE
			AND ("MaximumBalanceAfterReversal" < USED_TARGET_BALANCE OR "MaximumBalanceAfterReversal" IS NULL);
	END;

/*******************************************************************************/
	PROCEDURE "CreateHistoryChangeEntry"(TABLE_NAME IN VARCHAR2, COLUMN_NAME IN VARCHAR2, RECORD_ID IN VARCHAR2, NUMERIC_VALUE IN NUMBER, STRING_VALUE IN VARCHAR2, DATE_VALUE IN TIMESTAMP,
		RESPONSIBLE IN VARCHAR2, MODIFICATION_DATE IN TIMESTAMP, USER_CHANGE IN INTEGER, STRING_CODE IN VARCHAR2, LOG_MESSAGE_PRIORITY IN INTEGER)
	AS
		BEGIN
		INSERT INTO "HistoricalChanges" ("Id", "TableName", "ColumnName", "RecordId", "NumericValue", "StringValue", "DateValue", "ModificationTimestamp", "Timestamp", "TransactionId", "CreatedBy", "Responsible", "UserChange", "StringCode", "LogMessagePriority")
		VALUES (HISTORICALCHANGES_SEQ.NEXTVAL, TABLE_NAME, COLUMN_NAME, RECORD_ID, NUMERIC_VALUE, STRING_VALUE, DATE_VALUE, MODIFICATION_DATE, SYSTEMTIME, DBMS_TRANSACTION.LOCAL_TRANSACTION_ID, CURRENTUSER, RESPONSIBLE, USER_CHANGE, STRING_CODE, LOG_MESSAGE_PRIORITY);
	END;

/*******************************************************************************/
	PROCEDURE "CreateStatement" (INVOICE_DATE IN DATE, ACCOUNT "Accounts"%ROWTYPE, IS_PREVIEW IN NUMBER, NEW_STATEMENT_ID OUT NUMBER, IS_FULL_STATEMENT OUT NUMBER)
	AS
		PREVIOUS_STATEMENT "Statements"%ROWTYPE;
		PREVIOUS_EVENT_DATE DATE := TRUNC(ACCOUNT."TimeValidity_ValidFrom");
		LAST_STATEMENT_DUE_DATE DATE := ACCOUNT."TimeValidity_ValidFrom" - 1; -- Only entries accounted before this date can be stated.

		TYPE T_ACCOUNTING_RECORD IS RECORD (ENTRY_ID NUMBER, EXPECTATION_ID NUMBER, TRANSACTION_TYPE INTEGER, ACCOUNTING_DATE DATE, AMOUNT NUMBER, BALANCE NUMBER);
		TYPE T_ACCOUNTING_RECORDS IS TABLE OF T_ACCOUNTING_RECORD INDEX BY BINARY_INTEGER;
		ENTRY_COLLECTION$ T_ACCOUNTING_RECORDS; -- processed collection of entries
		EXPECTATION_COLLECTION$ T_ACCOUNTING_RECORDS; -- processed collection of entries

		TYPE T_RESOURCE IS RECORD (CODE INTEGER, TEXT NVARCHAR2(2000));
		TYPE T_RESOURCES IS TABLE OF T_RESOURCE INDEX BY BINARY_INTEGER;
		RESOURCES_RAW$ T_RESOURCES;
		RESOURCES$ T_RESOURCES;  -- collection of resources

		TYPE T_SECTIONS IS TABLE OF STATEMENT_SECTION_TYPE INDEX BY BINARY_INTEGER;
		STATEMENT_SECTIONS$ T_SECTIONS;  -- section data

		TYPE T_STATEMENT_ROWS IS TABLE OF STATEMENT_ROW_TYPE INDEX BY BINARY_INTEGER;
		STATEMENT_ROWS$ T_STATEMENT_ROWS;  -- statement row data

		STATEMENT_STATUS INTEGER := APPLICATIONVALUES.SS_APPROVED; -- Approved
		ENTRY_STATUS INTEGER := APPLICATIONVALUES.AES_STATEDONHISTORY; -- StatedOnHistory
		EXPECTATION_STATUS INTEGER := APPLICATIONVALUES.ES_STATED; -- Stated

		STATEMENT_MESSAGE_CODE NVARCHAR2(50);
		STATEMENT_NUMBER VARCHAR2(20);
		SECTION_ID RAW(16) := SYS_GUID();
		NEXT_PERIOD_START_DATE DATE;
		CURRENT_PERIOD_START_DATE DATE;
		STATEMENT_DUE_DATE DATE;
		LAST_HISTORY_BALANCE NUMBER := 0;
		LAST_EXPECTATION_BALANCE NUMBER;
		MINIMUM_PAYMENT NUMBER := 0;
		PLANNED_PAYMENT NUMBER;
		PREVIOUS_DEBT NUMBER := 0;
		PREVIOUS_STATEMENT_INCOME NUMBER := 0;
		CURRENT_STATEMENT "Statements"%ROWTYPE;
		MINIMUM_PAYMENT_SETTINGS NUMBER;
		SECTION_TITLE CLOB;

	BEGIN

		-- account exists
		IF ACCOUNT."Id" IS NULL THEN
			CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('AccountDoesntExist', NULL);
		END IF;

		-- account has right status
		IF ACCOUNT."Status" NOT IN (APPLICATIONVALUES.AS_ACTIVE, APPLICATIONVALUES.AS_CLOSED, APPLICATIONVALUES.AS_INACTIVE) THEN
			MAINTENANCE."LogWarn"('The account ''' || ACCOUNT."Id" || ''' is not active nor closed therefore statement will not be created. ');
			IS_FULL_STATEMENT := APPLICATIONVALUES.FST_SNC_WRONGACCSTATUS;
			RETURN;
		END IF;

		DBMS_OUTPUT.PUT_LINE('Account language: ' || ACCOUNT."Culture_LanguageCode");

		-- TODO: check resources for language

		-- preview only
		IF IS_PREVIEW <> 0 THEN
			STATEMENT_STATUS := APPLICATIONVALUES.SS_PREVIEW; -- Preview
			ENTRY_STATUS := APPLICATIONVALUES.AES_CREATED; -- created
			EXPECTATION_STATUS := APPLICATIONVALUES.ES_CREATED; -- created
		END IF;

		-- try to find current (open) statement
		BEGIN
			SELECT * INTO CURRENT_STATEMENT FROM
				(SELECT * FROM "Statements" WHERE "Account_Id" = ACCOUNT."Id" AND "Status" IN (APPLICATIONVALUES.SS_APPROVED, APPLICATIONVALUES.SS_PAID) AND "AccountingPeriodEndDate" >= TRUNC(SYSTEMTIME) ORDER BY "Created") WHERE ROWNUM = 1;
			EXCEPTION WHEN NO_DATA_FOUND THEN NULL;
		END;

		-- no open statement
		IF CURRENT_STATEMENT."Id" IS NULL THEN

			--PREVIOUS_STATEMENT := "GetPreviousStatement"(ACCOUNT."Id", INVOICE_DATE);
			PREVIOUS_STATEMENT := "GetPreviousStatement"(ACCOUNT."Id", TRUNC(SYSTEMTIME));

			-- previous statement exists
			IF PREVIOUS_STATEMENT."Id" IS NOT NULL THEN

				LAST_STATEMENT_DUE_DATE := PREVIOUS_STATEMENT."AccountingPeriodEndDate";

				IF LAST_STATEMENT_DUE_DATE = ACCOUNT."TimeValidity_ValidTo" THEN
					RETURN;
				END IF;

				PREVIOUS_EVENT_DATE := PREVIOUS_STATEMENT."Created";
			END IF;

			-- last statements after account final closure
			IF ACCOUNT."TimeValidity_ValidTo" IS NOT NULL AND ACCOUNT."TimeValidity_ValidTo" < TRUNC(SYSTEMTIME) THEN

				IS_FULL_STATEMENT := APPLICATIONVALUES.FST_SC_FinalStatement;
				STATEMENT_DUE_DATE := ACCOUNT."TimeValidity_ValidTo";

			-- first statement in period
			ELSE
				IS_FULL_STATEMENT := APPLICATIONVALUES.FST_SC_RegularStatement;
				STATEMENT_DUE_DATE := "GetNewStatementDueDate"(ACCOUNT);
			END IF;

			DBMS_OUTPUT.PUT_LINE('Statement due date: ' || STATEMENT_DUE_DATE);
			DBMS_OUTPUT.PUT_LINE('Last stated date: ' || LAST_STATEMENT_DUE_DATE);

		-- next statement in month -> will be stated next month
		ELSE
			MAINTENANCE."LogInfo"('Statement already exists, any new incoming invoice will be stated on next statement. ');
			IS_FULL_STATEMENT := APPLICATIONVALUES.FST_SNC_NextStExists;
		END IF;

		-- create statement
		IF STATEMENT_DUE_DATE IS NOT NULL THEN

			-- Select entries to be stated into a collection
			SELECT "Id", NULL, "TransactionType", "AccountingDate", "Amount", "Balance" BULK COLLECT INTO ENTRY_COLLECTION$ 
			FROM "AccountEntries"
			WHERE "Status" IN (APPLICATIONVALUES.AES_CREATED, APPLICATIONVALUES.AES_STATEDONEXPECTATION) AND "Account_Id" = ACCOUNT."Id" AND "Visibility" = APPLICATIONVALUES.AEV_Visible /*Visible*/
				AND ("AccountingDate" <= PREVIOUS_STATEMENT."AccountingPeriodEndDate" OR IS_FULL_STATEMENT = APPLICATIONVALUES.FST_SC_FinalStatement /*Closing statement*/)
			ORDER BY "AccountingDate", "Id";

			DBMS_OUTPUT.PUT_LINE(ENTRY_COLLECTION$.COUNT || ' entries selected. ');

			-- Select expectations to be stated into a collection
			IF (IS_FULL_STATEMENT != APPLICATIONVALUES.FST_SC_FinalStatement) THEN
				SELECT * BULK COLLECT INTO EXPECTATION_COLLECTION$ 
				FROM (
					SELECT ENTRY_ID, EXPECTATION_ID, "TransactionType", ACCOUNTING_DATE, "Amount", "Balance"  
					FROM 
					( 
						SELECT "Id" ENTRY_ID, NULL EXPECTATION_ID, "TransactionType", "AccountingDate" ACCOUNTING_DATE, "Created" CREATED_DATE, "Amount", "Balance" 
						FROM "AccountEntries"
						WHERE "Status" IN (APPLICATIONVALUES.AES_CREATED) AND "Account_Id" = ACCOUNT."Id" AND "AccountingDate" > LAST_STATEMENT_DUE_DATE AND "Visibility" = APPLICATIONVALUES.AEV_Visible /*Visible*/
						UNION ALL
						SELECT NULL ENTRY_ID, E."Id" EXPECTATION_ID, E."TransactionType", /*E."Created"*/ STATEMENT_DUE_DATE ACCOUNTING_DATE, "Created" CREATED_DATE, E."Amount", 0 
						FROM "Expectations" E
						WHERE "Status" IN (APPLICATIONVALUES.ES_CREATED) AND "Account_Id" = ACCOUNT."Id" AND TRUNC("Created") <= STATEMENT_DUE_DATE
					)
					ORDER BY TRUNC(ACCOUNTING_DATE), TRUNC(CREATED_DATE), ENTRY_ID, EXPECTATION_ID
				);
			END IF;

			-- count expected closing balance
			FOR I IN 1..EXPECTATION_COLLECTION$.COUNT LOOP
				IF EXPECTATION_COLLECTION$(I).EXPECTATION_ID IS NOT NULL THEN
					MINIMUM_PAYMENT := MINIMUM_PAYMENT + EXPECTATION_COLLECTION$(I).AMOUNT;
				END IF;
			END LOOP;
			
			-- count expected closing balance
			--FOR I IN 1..EXPECTATION_COLLECTION$.COUNT LOOP
			--	MINIMUM_PAYMENT := MINIMUM_PAYMENT + EXPECTATION_COLLECTION$(I).AMOUNT;
			--END LOOP;

			-- get Minimum statement payment amount from SystemSetting table
			MINIMUM_PAYMENT_SETTINGS := "GetSystemSettingsNumberValue"('MinimumStatementPaymentAmount');

			-- TODO: Determine what header text should be stated.

			-- find out minimum payment
			PLANNED_PAYMENT := "GetPlannedPayment" (ACCOUNT."Id", SYSTEMTIME);
			STATEMENT_NUMBER := "GenerateNewStatementNumber"(ACCOUNT);
			MINIMUM_PAYMENT := "GetStatementMinimumPayment"(ACCOUNT."Id", SYSTEMTIME, MINIMUM_PAYMENT, PLANNED_PAYMENT);
			IF (MINIMUM_PAYMENT > 0 AND MINIMUM_PAYMENT < MINIMUM_PAYMENT_SETTINGS) THEN
				MINIMUM_PAYMENT := MINIMUM_PAYMENT_SETTINGS;
			END IF;
			--
			CURRENT_PERIOD_START_DATE := PREVIOUS_STATEMENT."AccountingPeriodEndDate" + 1;

			-- find out current period start date
			IF CURRENT_PERIOD_START_DATE IS NULL THEN
				CURRENT_PERIOD_START_DATE := ACCOUNT."TimeValidity_ValidFrom";
			END IF;

			-- add debt from previous statement
			IF PREVIOUS_STATEMENT."Id" IS NOT NULL AND PREVIOUS_STATEMENT."Status" <> APPLICATIONVALUES.SS_PAID THEN

				PREVIOUS_STATEMENT_INCOME := "CalculateIncome"(ACCOUNT."Id",TRUNC(PREVIOUS_STATEMENT."Created"), SYSTEMTIME);
				
				-- TODO: do we need include previous debt of previous statement?
				PREVIOUS_DEBT := PREVIOUS_STATEMENT."MinimumPayment" /*+ PREVIOUS_STATEMENT."PreviousDebt"*/ - PREVIOUS_STATEMENT_INCOME;
				IF PREVIOUS_DEBT < 0 THEN 
					PREVIOUS_DEBT := 0;
				END IF;
			END IF;

			-- set statement status
			IF (STATEMENT_STATUS = APPLICATIONVALUES.SS_APPROVED AND MINIMUM_PAYMENT = 0) THEN  
				STATEMENT_STATUS := APPLICATIONVALUES.SS_PAID;
			END IF;

			-- Create statement record
			STATEMENT_MESSAGE_CODE := 'Header_StatementCaption'; -- header code
			INSERT INTO "Statements" ("Status", "Account_Id", "DueDate", "AccountingPeriodStartDate", "AccountingPeriodEndDate", "StatementNumber", "MinimumPayment", "LastChange_ChangedBy", "PreviousDebt", "PlannedPayment", "EnableReminders", "Text")
				VALUES (STATEMENT_STATUS, ACCOUNT."Id", STATEMENT_DUE_DATE, CURRENT_PERIOD_START_DATE, STATEMENT_DUE_DATE, STATEMENT_NUMBER, MINIMUM_PAYMENT, CURRENTUSER, PREVIOUS_DEBT, PLANNED_PAYMENT, 1 /*Enabled*/, 
				(SELECT R."Text" FROM "Resources" R WHERE "StringCode" = STATEMENT_MESSAGE_CODE AND lower(R."LanguageCode") = lower(ACCOUNT."Culture_LanguageCode") AND "Domain" = 'Statement'))
			RETURNING "Id" INTO NEW_STATEMENT_ID; -- The statement ID.

			-- Load resources
			SELECT "NumericCode", "Text" BULK COLLECT INTO RESOURCES_RAW$ FROM "Resources"
			WHERE "Domain" = 'TransactionType' AND lower("LanguageCode") = lower(ACCOUNT."Culture_LanguageCode");
			FOR I IN 1..RESOURCES_RAW$.COUNT LOOP
				RESOURCES$(RESOURCES_RAW$(I).CODE) := RESOURCES_RAW$(I);
			END LOOP;
		END IF;

		-- create history section
		IF ENTRY_COLLECTION$.COUNT > 0 THEN

			-- Create statement row records
			SELECT "Text" 
			INTO SECTION_TITLE 
			FROM "Resources" 
			WHERE "Domain" = 'Statement'
				AND "StringCode" = 'Header_AccountHistory'
				AND "LanguageCode" = ACCOUNT."Culture_LanguageCode";

			-- previous statement does exist
			IF PREVIOUS_STATEMENT."Id" IS NOT NULL THEN

				IF PREVIOUS_STATEMENT."AccountingPeriodStartDate" > ENTRY_COLLECTION$(1).ACCOUNTING_DATE THEN
					PREVIOUS_STATEMENT := "GetRelatedStatement"(ACCOUNT, ENTRY_COLLECTION$(1).ACCOUNTING_DATE);
				END IF;

				CURRENT_PERIOD_START_DATE := PREVIOUS_STATEMENT."AccountingPeriodStartDate";
				NEXT_PERIOD_START_DATE := PREVIOUS_STATEMENT."AccountingPeriodEndDate" + 1;

			-- previous statement does not exist
			ELSE
				CURRENT_PERIOD_START_DATE := ACCOUNT."TimeValidity_ValidFrom";
				NEXT_PERIOD_START_DATE := STATEMENT_DUE_DATE + 1;
			END IF;

			FOR I IN 1..ENTRY_COLLECTION$.COUNT LOOP

				-- TODO: Optimize nested method calling when they query the database

				IF I = 1 OR ENTRY_COLLECTION$(I).ACCOUNTING_DATE >= NEXT_PERIOD_START_DATE THEN
					SECTION_ID := SYS_GUID();

					IF I > 1 THEN
						CURRENT_PERIOD_START_DATE := NEXT_PERIOD_START_DATE;
						NEXT_PERIOD_START_DATE := "GetRelatedStatement"(ACCOUNT, ENTRY_COLLECTION$(I).ACCOUNTING_DATE)."AccountingPeriodEndDate" + 1;
						STATEMENT_SECTIONS$(STATEMENT_SECTIONS$.COUNT).CLOSING_BALANCE := ENTRY_COLLECTION$(I - 1).BALANCE;
					END IF;

					-- TODO: Add proper section description

					STATEMENT_SECTIONS$(STATEMENT_SECTIONS$.COUNT + 1) := STATEMENT_SECTION_TYPE(SECTION_ID, SECTION_TITLE, CURRENT_PERIOD_START_DATE, NEXT_PERIOD_START_DATE - 1, ENTRY_COLLECTION$(I).BALANCE - ENTRY_COLLECTION$(I).AMOUNT, 0);

				END IF;

				STATEMENT_ROWS$(I) := STATEMENT_ROW_TYPE(I, RESOURCES$(ENTRY_COLLECTION$(I).TRANSACTION_TYPE).TEXT, ENTRY_COLLECTION$(I).ENTRY_ID, NULL, SECTION_ID);
			END LOOP;

			LAST_HISTORY_BALANCE := ENTRY_COLLECTION$(ENTRY_COLLECTION$.COUNT).BALANCE;
			STATEMENT_SECTIONS$(STATEMENT_SECTIONS$.COUNT).CLOSING_BALANCE := LAST_HISTORY_BALANCE;

			IF IS_FULL_STATEMENT = APPLICATIONVALUES.FST_SC_FinalStatement THEN
				STATEMENT_SECTIONS$(STATEMENT_SECTIONS$.COUNT).END_DATE := ACCOUNT."TimeValidity_ValidTo";
			END IF;

			FORALL ROW_NUMBER IN 1..STATEMENT_SECTIONS$.COUNT
				INSERT INTO "StatementSections" ("Id", "Text", "Statement_Id", "StartDate", "EndDate", "SectionType", "OpeningBalance", "ClosingBalance")
				VALUES (STATEMENT_SECTIONS$(ROW_NUMBER).SECTION_ID, STATEMENT_SECTIONS$(ROW_NUMBER).DESCRIPTION, NEW_STATEMENT_ID, STATEMENT_SECTIONS$(ROW_NUMBER).START_DATE, STATEMENT_SECTIONS$(ROW_NUMBER).END_DATE, 1, STATEMENT_SECTIONS$(ROW_NUMBER).OPENING_BALANCE, STATEMENT_SECTIONS$(ROW_NUMBER).CLOSING_BALANCE); -- Section type 'History'

			FORALL ROW_NUMBER IN 1..ENTRY_COLLECTION$.COUNT
				INSERT INTO "StatementRows" ("Id", "Description", "AccountEntry_Id", "StatementSection_Id", "RowNumber")
				VALUES (SYS_GUID(), STATEMENT_ROWS$(ROW_NUMBER).DESCRIPTION, STATEMENT_ROWS$(ROW_NUMBER).ENTRY_ID, STATEMENT_ROWS$(ROW_NUMBER).SECTION_ID, STATEMENT_ROWS$(ROW_NUMBER).ROW_NUMBER);

			-- Update entries which have status 1 (Created), set statement ID and status 'StatedOnHistory'.
			UPDATE "AccountEntries" SET "Statement_Id" = NEW_STATEMENT_ID, "Status" = ENTRY_STATUS, "LastChange_Changed" = SYSTEMTIME, "LastChange_ChangedBy" = CURRENTUSER
			WHERE "Status" = APPLICATIONVALUES.AES_CREATED /*Created*/ AND "Account_Id" = ACCOUNT."Id" AND "AccountingDate" <= PREVIOUS_STATEMENT."AccountingPeriodEndDate" AND "Visibility" = APPLICATIONVALUES.AEV_Visible /*Visible*/;

			-- Update entries which have status 2 (StatedOnExpectation), set status'StatedOnHistory'.
			UPDATE "AccountEntries" SET "Status" = ENTRY_STATUS, "LastChange_Changed" = SYSTEMTIME, "LastChange_ChangedBy" = CURRENTUSER
			WHERE "Status" = APPLICATIONVALUES.AES_STATEDONEXPECTATION /*StatedOnExpectation*/ AND "Account_Id" = ACCOUNT."Id" AND "AccountingDate" <= PREVIOUS_STATEMENT."AccountingPeriodEndDate" AND "Visibility" = APPLICATIONVALUES.AEV_Visible /*Visible*/;

		END IF; /*history section*/

		DBMS_OUTPUT.PUT_LINE(EXPECTATION_COLLECTION$.COUNT || ' expectations selected. ');

		-- expectation section
		IF EXPECTATION_COLLECTION$.COUNT > 0 THEN

			SECTION_ID := SYS_GUID();
			LAST_EXPECTATION_BALANCE := LAST_HISTORY_BALANCE;

			FOR I IN 1..EXPECTATION_COLLECTION$.COUNT LOOP
				STATEMENT_ROWS$(I) := STATEMENT_ROW_TYPE(I, RESOURCES$(EXPECTATION_COLLECTION$(I).TRANSACTION_TYPE).TEXT, EXPECTATION_COLLECTION$(I).ENTRY_ID, EXPECTATION_COLLECTION$(I).EXPECTATION_ID, SECTION_ID);
				LAST_EXPECTATION_BALANCE := LAST_EXPECTATION_BALANCE + EXPECTATION_COLLECTION$(I).AMOUNT;
			END LOOP;

			INSERT INTO "StatementSections" ("Id", "Statement_Id", "StartDate", "EndDate", "SectionType", "OpeningBalance", "ClosingBalance", "Text")
			VALUES (SECTION_ID, NEW_STATEMENT_ID, LAST_STATEMENT_DUE_DATE + 1, STATEMENT_DUE_DATE, APPLICATIONVALUES.SST_EXPECTATION /*Expectations*/, LAST_HISTORY_BALANCE, LAST_EXPECTATION_BALANCE,
					(SELECT "Text" FROM "Resources" WHERE "Domain" = 'Statement' AND "StringCode" = 'Header_Expectations' AND "LanguageCode" = ACCOUNT."Culture_LanguageCode"));

			FORALL ROW_NUMBER IN 1..EXPECTATION_COLLECTION$.COUNT
				INSERT INTO "StatementRows" ("Id", "Description", "AccountEntry_Id", "Expectation_Id", "StatementSection_Id", "RowNumber")
				VALUES (SYS_GUID(), STATEMENT_ROWS$(ROW_NUMBER).DESCRIPTION, STATEMENT_ROWS$(ROW_NUMBER).ENTRY_ID, STATEMENT_ROWS$(ROW_NUMBER).EXPECTATION_ID, STATEMENT_ROWS$(ROW_NUMBER).SECTION_ID, STATEMENT_ROWS$(ROW_NUMBER).ROW_NUMBER);

			-- Update expectations with statement ID, due date and to 'Stated'.
			UPDATE "Expectations" SET "Statement_Id" = NEW_STATEMENT_ID, "Status" = EXPECTATION_STATUS
			WHERE "Account_Id" = ACCOUNT."Id" 
				AND "Status" IN (APPLICATIONVALUES.ES_CREATED /*Created*/) 
				AND TRUNC("Created") <= STATEMENT_DUE_DATE;

			-- Update account entries with statement ID, due date and to 'Stated'.
			IF (IS_PREVIEW <> 0) THEN ENTRY_STATUS := APPLICATIONVALUES.AES_CREATED /*Created*/;
			ELSE ENTRY_STATUS := APPLICATIONVALUES.AES_STATEDONEXPECTATION /*StatedOnExpectation*/;
			END IF;
 
			UPDATE "AccountEntries" SET "Statement_Id" = NEW_STATEMENT_ID, "Status" = ENTRY_STATUS
			WHERE "Account_Id" = ACCOUNT."Id" 
				AND "Status" = APPLICATIONVALUES.AES_CREATED /*Created*/ 
				AND TRUNC("AccountingDate") >= CURRENT_PERIOD_START_DATE 
				AND TRUNC("AccountingDate") <= STATEMENT_DUE_DATE;

		END IF; /*expectation section*/


		IF NEW_STATEMENT_ID IS NOT NULL THEN

			-- create footer
			INSERT INTO "StatementFooterRows" ("Id", "Statement_Id", "RowNumber", "Description", "Date")
			SELECT SYS_GUID, NEW_STATEMENT_ID, ROWNUM, "Description", "ValidFrom"
			FROM "AccountChangeLog"
			WHERE ("Account_Id" = ACCOUNT."Id" OR "Account_Id" IS NULL) 
				AND "LanguageCode" = ACCOUNT."Culture_LanguageCode" 
				AND "ValidFrom" > PREVIOUS_EVENT_DATE
				AND "ValidFrom" <= SYSTEMTIME
				AND "LogType" = APPLICATIONVALUES.LT_EXTERNAL /* External comment or log */;

			-- Delete old statement preview for the account if exists.
			DELETE FROM "Statements" WHERE "Account_Id" = ACCOUNT."Id" AND "Status" = APPLICATIONVALUES.SS_PREVIEW /*Preview*/ AND "Id" <> NEW_STATEMENT_ID;
		END IF;

	END "CreateStatement";

/*******************************************************************************/
	FUNCTION "CorrectToBusinessDay" (DUE_DATE DATE, CALCULATION_TYPE INT) RETURN DATE 
	AS
	BEGIN
		CASE CALCULATION_TYPE 
			WHEN APPLICATIONVALUES.SDDCM_ONDUEDATE THEN RETURN DUE_DATE;
			WHEN APPLICATIONVALUES.SDDCM_LASTWORKINGBEFORE THEN RETURN "CorrectToBusinessDayDown"(DUE_DATE);
			WHEN APPLICATIONVALUES.SDDCM_FIRSTWORKINGAFTER THEN RETURN "CorrectToBusinessDayUp"(DUE_DATE);
			ELSE CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('NotSupportedDueDateCalcMethod', NULL);
		END CASE;
	END;

/*******************************************************************************/
	FUNCTION "GetNewStatementDueDate" (ACCOUNT "Accounts"%ROWTYPE) RETURN DATE 
	IS
		STATEMENT_DUE_DATE DATE;
		TODAY DATE := TRUNC(SYSTEMTIME);
		BUSINESS_DUE_DATE DATE;
		NEXT_STATEMENT_OFFSET_DAYS INTEGER; -- When the offset between the expectation creation and statement due date is smaller than the offset the expectation will be stated on the next statement.
		COUNTER INT := 1;
		MAX_COUNTER_ATTEMPTS INT := 14;
		StatementDueDateCalcType INTEGER;
	BEGIN

		StatementDueDateCalcType := "GetSystemSettingsNumberValue"('StatementDueDateCalculationMethod');
		STATEMENT_DUE_DATE := "GetDateFromDueDay"(ACCOUNT."DueDay", SYSTEMTIME);
		NEXT_STATEMENT_OFFSET_DAYS := "GetSystemSettingsNumberValue"('NextStatementOffsetDays');

		BUSINESS_DUE_DATE := "CorrectToBusinessDay"(STATEMENT_DUE_DATE, StatementDueDateCalcType);
		WHILE (BUSINESS_DUE_DATE <= TODAY + NEXT_STATEMENT_OFFSET_DAYS) LOOP
			BUSINESS_DUE_DATE := "CorrectToBusinessDay"("GetDateFromDueDay"(ACCOUNT."DueDay", ADD_MONTHS(STATEMENT_DUE_DATE, COUNTER)), StatementDueDateCalcType);
			COUNTER := COUNTER + 1;
			IF (COUNTER = 14) THEN
				CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('NotValidStmDueDateFound', NULL);
			END IF;
		END LOOP;

		RETURN BUSINESS_DUE_DATE;
	END "GetNewStatementDueDate";

/*******************************************************************************/
	FUNCTION "GetPreviousStatement" (ACCOUNT_ID IN NUMBER, FROM_DATE IN DATE)
		RETURN "Statements"%ROWTYPE IS PREVIOUS_STATEMENT "Statements"%ROWTYPE;
	BEGIN
		SELECT * INTO PREVIOUS_STATEMENT 
		FROM (
			SELECT * 
			FROM "Statements" 
			WHERE "AccountingPeriodEndDate" < FROM_DATE 
				AND "Account_Id" = ACCOUNT_ID 
				AND "Status" IN (APPLICATIONVALUES.SS_APPROVED,APPLICATIONVALUES.SS_PAID) 
--			ORDER BY "DueDate" DESC
			ORDER BY "AccountingPeriodEndDate" DESC
		)
		WHERE ROWNUM = 1;

		RETURN PREVIOUS_STATEMENT;

		EXCEPTION WHEN NO_DATA_FOUND THEN
			RETURN NULL;

	END "GetPreviousStatement";

/*******************************************************************************/
	FUNCTION "GetRelatedStatement" (ACCOUNT "Accounts"%ROWTYPE, FROM_DATE DATE)
		RETURN "Statements"%ROWTYPE IS RELATED_STATEMENT "Statements"%ROWTYPE;
	BEGIN
		SELECT * INTO RELATED_STATEMENT 
		FROM
		(
			SELECT * 
			FROM "Statements" 
			WHERE "AccountingPeriodEndDate" >= FROM_DATE 
				AND "Account_Id" = ACCOUNT."Id" 
				AND "Status" IN (APPLICATIONVALUES.SS_APPROVED,APPLICATIONVALUES.SS_PAID) 
			ORDER BY "AccountingPeriodEndDate"
		)
		WHERE ROWNUM = 1;

		RETURN RELATED_STATEMENT;

		EXCEPTION WHEN NO_DATA_FOUND THEN
			RETURN NULL;

	END "GetRelatedStatement";

/*******************************************************************************/
	FUNCTION "GetLastInterestForAccount"(ACCOUNT_ID NUMBER) RETURN DATE AS
		LAST_DATE DATE;
	BEGIN
		SELECT MAX("InterestDate") INTO LAST_DATE
		FROM "Interests"
		WHERE "Account_Id" = ACCOUNT_ID;

		IF (LAST_DATE IS NULL) THEN
			BEGIN
				SELECT "TimeValidity_ValidFrom" - 1 INTO LAST_DATE
				FROM "Accounts" WHERE "Id" = ACCOUNT_ID;
				EXCEPTION WHEN NO_DATA_FOUND THEN 
					CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('AccountStartDateValidity', NULL);
			END;
		END IF;
		
		RETURN LAST_DATE;
	END;

/*******************************************************************************/
	FUNCTION "GetLastBalanceForAccount"(ACCOUNT_ID IN NUMBER, ACCOUNTING_DATE IN DATE) RETURN NUMBER AS
		--LAST_BALANCE NUMBER;
		ACCOUNT_VALID_FROM_DATE DATE;
		--ACCOUNTING_DATE DATE := TRUNC(DATE_FROM);
		PREVIOUS_BALANCE NUMBER := 0;
		DAY_BALANCE NUMBER := 0;
	BEGIN
	
		BEGIN
			SELECT TRUNC("TimeValidity_ValidFrom") INTO ACCOUNT_VALID_FROM_DATE
			FROM "Accounts" WHERE "Id" = ACCOUNT_ID;
			EXCEPTION WHEN NO_DATA_FOUND THEN 
				CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('AccountDoesntExist', NULL);
		END;

		IF (TRUNC(ACCOUNTING_DATE) < ACCOUNT_VALID_FROM_DATE) THEN
			RETURN 0;
		END IF;

		BEGIN
			SELECT "Balance" INTO PREVIOUS_BALANCE
			FROM
			(
				SELECT "Balance"
				FROM "AccountEntryView"
				WHERE 
					"Account_Id" = ACCOUNT_ID 
					AND TRUNC("AccountingDate") < TRUNC(ACCOUNTING_DATE)
				ORDER BY "AccountingDate" DESC, "Id" DESC
			) WHERE ROWNUM = 1;
		EXCEPTION WHEN NO_DATA_FOUND THEN 
			PREVIOUS_BALANCE := 0;
		END;
		
		-- day balance
		SELECT NVL(SUM("Amount"), 0) INTO DAY_BALANCE
		FROM "AccountEntryView"
		WHERE "Account_Id" = ACCOUNT_ID 
			AND TRUNC("AccountingDate") = TRUNC(ACCOUNTING_DATE)
		AND "TransactionType" IN (APPLICATIONVALUES.TT_INCOME, APPLICATIONVALUES.TT_MANUALCORRECTION, APPLICATIONVALUES.TT_REVERSEDPAYMENT);

		--RETURN LAST_BALANCE;
		RETURN PREVIOUS_BALANCE+DAY_BALANCE;
 
	END;  

/*******************************************************************************/
	PROCEDURE "CalculateAccountDailyInterests"(ACCOUNT_ID IN INTEGER, DATE_TO IN DATE ) AS 
		-- 
		lastBalance NUMBER(20,2);
		lastInterestDate DATE;

		INTEREST_COLLECTION$ INTEREST_CALC_TABLE;

	BEGIN
		
		-- last interest date
		lastInterestDate := "GetLastInterestForAccount"(ACCOUNT_ID);

		dbms_output.put_line('LastInterestDate: '||lastInterestDate);
		dbms_output.put_line('DateTo: '||DATE_TO); 

		IF(ROUND(DATE_TO) <= ROUND(lastInterestDate)) THEN
			dbms_output.put_line('DateTo ('||DATE_TO||') is less or equal than last interest date ('||lastInterestDate||')');
			RETURN;
		END IF;

		-- last balance for day
		lastBalance := "GetLastBalanceForAccount"(ACCOUNT_ID, lastInterestDate);
		dbms_output.put_line('Last balance: '||lastBalance);

		lastInterestDate := lastInterestDate+1;

		SELECT INTEREST_CALC_TYPE(BALANCE, AMOUNT, RATE, DAY)
		BULK COLLECT INTO INTEREST_COLLECTION$
		FROM TABLE("CalculateAccountDayInterests"(ACCOUNT_ID, lastInterestDate, DATE_TO, lastBalance, AE_COLUMN_ACCOUNTING_DATE));
		
		-- insert into tables
		IF INTEREST_COLLECTION$ IS NOT NULL AND INTEREST_COLLECTION$.COUNT > 0 THEN 
		
			FORALL ROW_NUMBER IN 1..INTEREST_COLLECTION$.COUNT
			INSERT INTO "Interests" ("Id", "Balance", "Amount", "InterestDate", "InterestRate", "Account_Id")
			VALUES (
				SYS_GUID(), 
				INTEREST_COLLECTION$(ROW_NUMBER).Balance,
				INTEREST_COLLECTION$(ROW_NUMBER).Amount,
				INTEREST_COLLECTION$(ROW_NUMBER).Day, 
				INTEREST_COLLECTION$(ROW_NUMBER).Rate,
				ACCOUNT_ID);
		
		END IF;
	END "CalculateAccountDailyInterests";

/*******************************************************************************/
	PROCEDURE "AccountExpectations"(DATE_TO IN DATE) AS
		expectation "Expectations"%Rowtype;
		PAYMENT_ID NUMBER;
		LOCK_NAME VARCHAR2(20) := 'ACCOUNTING_LOCK';
		
		 CURSOR accountExpCur IS
		 SELECT *
		 FROM (
			SELECT  
				"Expectations"."Id",
				"Expectations"."Amount",
				"Expectations"."Account_Id",
				"Expectations"."Statement_Id",
				"Expectations"."TransactionType",
				"Expectations"."PaymentDate",
				"Expectations"."Amount" + ((
								SELECT NVL(SUM("Amount"), 0) 
								FROM "Expectations" E 
								WHERE E."TransactionType" = APPLICATIONVALUES.TT_OUTCOMECANCELLATION /*Outcome Cancellation*/AND E."OriginalExpectation_Id" = "Expectations"."Id")
				) realAmount,
				CASE WHEN "Statements"."Id" IS NULL THEN "Reminders"."DueDate" 
				ELSE "Statements"."AccountingPeriodEndDate"
				END accountingDate,
				"BlockedTransactions"."Id" "BlockedTransactionId"
			FROM "Expectations"
			LEFT JOIN "Statements" ON "Statements"."Id" = "Expectations"."Statement_Id"
			LEFT JOIN "Reminders" ON "Reminders"."FeeExpectation_Id" = "Expectations"."Id"
			LEFT JOIN "BlockedTransactions" ON "BlockedTransactions"."Expectation_Id" = "Expectations"."Id"
			WHERE 
				"Expectations"."Status" = APPLICATIONVALUES.ES_STATED --Stated
				AND ("Statements"."AccountingPeriodEndDate" < TRUNC(DATE_TO) OR "Reminders"."DueDate" < TRUNC(DATE_TO))
				AND  ("Expectations"."Account_Id" = NVL(CURRENTACCOUNTID, "Expectations"."Account_Id"))
		) ORDER BY accountingDate, "Id";

		CURSOR payExpCur IS
			SELECT *
			FROM (
					SELECT 
						"Companies"."BankAccountNumber",
						"Accounts"."CustomerIdentifier" PayerIdentifier,
						"Accounts"."Currency",
						"Accounts"."Company_Id",
						"Expectations"."Id",
						"Expectations"."Amount",
						"Expectations"."PaymentDate",
						"Expectations"."ReferenceNumber" ExpectationReferenceNumber,
						"Expectations"."Account_Id",
						"Expectations"."Statement_Id",
						"Expectations"."Amount" + ((
								SELECT NVL(SUM("Amount"), 0) 
								FROM "Expectations" E 
								WHERE E."TransactionType" = APPLICATIONVALUES.TT_OUTCOMECANCELLATION /*Outcome Cancelation*/ AND E."OriginalExpectation_Id" = "Expectations"."Id")
						) realAmount,
						"BlockedTransactions"."Id" "BlockedTransactionId",
						"BlockedTransactions"."Payment_Id"
					FROM "Expectations"
					INNER JOIN "Accounts" ON "Expectations"."Account_Id" = "Accounts"."Id"
					INNER JOIN "Companies" ON "Accounts"."Company_Id" = "Companies"."Id"
					LEFT JOIN "BlockedTransactions" ON "BlockedTransactions"."Expectation_Id" = "Expectations"."Id"
					WHERE 
						"Expectations"."PaymentDate" IS NOT NULL 
						AND "Expectations"."TransactionType" = APPLICATIONVALUES.TT_OUTCOME -- outcome
						AND "BlockedTransactions"."Payment_Id" IS NULL
						AND "Expectations"."PaymentDate" <= TRUNC(DATE_TO)
						AND ("Accounts"."Id" = NVL(CURRENTACCOUNTID, "Accounts"."Id"))
			) WHERE realAmount <> 0
			ORDER BY "PaymentDate", PayerIdentifier;

	BEGIN		

		-- lock 
		"RequestLock"(LOCK_NAME);

		-- account expectations
		FOR expectation IN accountExpCur
		LOOP

			BEGIN
				INSERT INTO "AccountEntries" (
					"TransactionType", 
					"ValidFrom", "ValidTo", "AccountingDate", "ValidationDate", 
					"Amount",
					"Visibility",
					"Status",
					"Account_Id",
					"Statement_Id",
					"LastChange_Changed",
					"LastChange_ChangedBy",
					"Expectation_Id")
				VALUES (
					expectation."TransactionType",
					expectation.accountingDate, expectation.accountingDate, expectation.accountingDate, expectation.accountingDate,
					expectation."Amount",
					APPLICATIONVALUES.AEV_VISIBLE , -- visibility = visible
					APPLICATIONVALUES.AES_CREATED, -- status = created
					expectation."Account_Id",
					NULL,
					SYSTEMTIME,
					CURRENTUSER, 
					expectation."Id"
				);

			EXCEPTION
				WHEN OTHERS THEN
					MAINTENANCE."LogError"(SQLERRM);
					CONTINUE;
			END;

			UPDATE "Expectations" SET "Status" = APPLICATIONVALUES.ES_ACCOUNTED -- accounted
			WHERE "Id" = expectation."Id";

			-- insert blocked transaction (paymentID is null, will be updated when expectation is paid to CAB)
			IF (expectation."PaymentDate" > DATE_TO AND expectation."TransactionType" = APPLICATIONVALUES.TT_OUTCOME /*outcome*/ AND expectation."BlockedTransactionId" IS NULL AND expectation.realAmount != 0) THEN
				INSERT INTO "BlockedTransactions" ("Id", "Amount", "LastChange_Changed", "LastChange_ChangedBy", "Account_Id", "Expectation_Id", "Payment_Id")
				VALUES (
					BLOCKEDTRANSACTIONS_SEQ.NEXTVAL,
					expectation.realAmount,
					SYSTEMTIME, -- lastChange_changed
					CURRENTUSER, -- lastChange_changedBy
					expectation."Account_Id",
					expectation."Id",
					NULL -- paymentID
				); 
			END IF;

		END LOOP;
		
		-- pay expectations
		FOR expectation IN payExpCur
		LOOP
			
			-- create payment
			INSERT INTO "Payments" ("Status", "Amount", "ReferenceNumber", "LastChange_Changed", "LastChange_ChangedBy", "BankAccountNumber", "PaymentDate", "PayerIdentifier", "Currency", "PaymentType", "Created", "Company_Id")
			VALUES (
				APPLICATIONVALUES.PS_IMPORTED, --status = Imported
				--expectation."Amount", -- amount
				expectation.realAmount, -- amount
				expectation.ExpectationReferenceNumber,  -- reference number 
				SYSTEMTIME, -- lastChange_changed
				CURRENTUSER, -- lastChange_changedBy
				expectation."BankAccountNumber", -- bankAccountNumber
				expectation."PaymentDate", -- payment date
				expectation.PayerIdentifier, -- payer identifier
				expectation."Currency", -- currency
				APPLICATIONVALUES.PT_OUTCOMINGPAYMENT, -- paymentType = OutcomingPayment
				SYSTEMTIME, -- created
				expectation."Company_Id" -- company_id
			)
			RETURNING "Id" INTO PAYMENT_ID;
				
			-- create blocked transaction (accounting is done later than payment to CAB)
			IF (expectation."BlockedTransactionId" IS NULL) THEN
							
				INSERT INTO "BlockedTransactions" ("Id", "Amount", "LastChange_Changed", "LastChange_ChangedBy", "Account_Id", "Expectation_Id", "Payment_Id")
				VALUES (
					BLOCKEDTRANSACTIONS_SEQ.NEXTVAL,
					--expectation."Amount",
					expectation.realAmount,
					SYSTEMTIME, -- lastChange_changed
					CURRENTUSER, -- lastChange_changedBy
					expectation."Account_Id",
					expectation."Id",
					PAYMENT_ID
				);
				
			-- update blocked transaction (accounting is done before payment to CAB)
			ELSE
				UPDATE "BlockedTransactions" SET "Payment_Id" = PAYMENT_ID, "LastChange_Changed" = SYSTEMTIME, "LastChange_ChangedBy" = CURRENTUSER WHERE "Id" = expectation."BlockedTransactionId";
			END IF;

		END LOOP;

		-- release
		"ReleaseLock"(LOCK_NAME);
		
	END "AccountExpectations"; 

/*******************************************************************************/
	PROCEDURE "AccountInterestsForAccount"(ACCOUNT_ID IN NUMBER, DATE_TO IN DATE, FORCE_ACCOUNTING IN BOOLEAN DEFAULT FALSE) AS
		accountEntryId NUMBER;

		accountValidTo DATE;
		accountStatus INT;
		countInterestsTo DATE;

		POS_BOOK_DATE DATE;
		NEG_BOOK_DATE DATE;
		posBookingMethod INT;
		negBookingMethod INT;
		
		CURSOR interestsCur IS 
			SELECT
				--INTEREST_GROUP,
				 ACCOUNTING_DATE,
				MIN("InterestDate") VALID_FROM,
				MAX("InterestDate") VALID_TO,
				"InterestRate" INTEREST_RATE,
				SUM("Amount") AMOUNT
			FROM (
				SELECT
					SUM (CHANGED) OVER (ORDER BY "InterestDate") CHANGE_GROUP,
					X."InterestDate", 
					X."InterestRate",
					X."Amount",
					X.ACCOUNTING_DATE
				FROM (SELECT 
						someChange.*,
						CASE 
							WHEN (someChange.INTEREST_CHANGED = 1 OR someChange.AMOUNT_SIGN_CHANGED = 1) THEN 1
							ELSE 0
						END CHANGED
						FROM (SELECT
								amountSign.*,
								CASE 
									WHEN NVL (LAG ("InterestRate", 1) OVER (ORDER BY "InterestDate"), "InterestRate") <> "InterestRate" THEN 1
									ELSE 0
								END INTEREST_CHANGED,
								CASE 
									WHEN NVL (LAG (AMOUNT_SIGN, 1) OVER (ORDER BY "InterestDate"), AMOUNT_SIGN) <> AMOUNT_SIGN THEN 1
									ELSE 0
								END AMOUNT_SIGN_CHANGED
								FROM (SELECT 
										CASE 
											WHEN ("Amount" > 0) THEN POS_BOOK_DATE
											WHEN ("Amount" < 0) THEN NEG_BOOK_DATE
											ELSE NULL
										END ACCOUNTING_DATE,
										CASE 
											WHEN ("Amount" > 0) THEN 1
											WHEN ("Amount" < 0) THEN -1
											ELSE 0
										END AMOUNT_SIGN,
										"Interests".*
										FROM "Interests"
										WHERE
											(("InterestDate" <= TRUNC (POS_BOOK_DATE) AND "Amount" > 0) OR ("InterestDate" <= TRUNC (NEG_BOOK_DATE) AND "Amount" < 0) )
											AND "Account_Id" = ACCOUNT_ID
											AND "InterestEntry_Id" IS NULL
										ORDER BY "InterestDate"
										) amountSign
							) someChange
					)X
			) 
			GROUP BY CHANGE_GROUP, "InterestRate", ACCOUNTING_DATE
			--GROUP BY "InterestRate", ACCOUNTING_DATE
			ORDER BY ACCOUNTING_DATE;
			--ORDER BY VALID_FROM;
	BEGIN

		--"CalculateAccountDailyInterests"(ACCOUNT_ID, DATE_TO);

		 BEGIN
			SELECT "TimeValidity_ValidTo", "Status" INTO accountValidTo, accountStatus
			FROM "Accounts" WHERE "Id" = ACCOUNT_ID;
			
			EXCEPTION WHEN NO_DATA_FOUND THEN
				CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('AccountDoesntExist', NULL);
		END;

		BEGIN
			SELECT "PositiveInterestBookingMethod", "NegativeInterestBookingMethod"
			INTO posBookingMethod, negBookingMethod
			FROM "Templates" T
			INNER JOIN "AccountTemplates" AT ON T."Id" = AT."Template_Id"
			WHERE 
				AT."Account_Id" = ACCOUNT_ID
				AND (TRUNC(AT."TimeValidity_ValidFrom") <= TRUNC(DATE_TO) AND (TRUNC(AT."TimeValidity_ValidTo") >= TRUNC(DATE_TO) OR AT."TimeValidity_ValidTo" IS NULL));
			EXCEPTION WHEN NO_DATA_FOUND THEN
				CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('NotValidTemplateForDate', NULL);
		END;
		
		IF FORCE_ACCOUNTING = TRUE THEN
			POS_BOOK_DATE := DATE_TO;
			NEG_BOOK_DATE := DATE_TO;
			countInterestsTo := DATE_TO;
		ELSE
			IF (accountValidTo IS NOT NULL AND accountValidTo <= DATE_TO) THEN
				POS_BOOK_DATE := accountValidTo/*-1*/;
				NEG_BOOK_DATE := accountValidTo/*-1*/;
				countInterestsTo := accountValidTo;
			ELSE
				POS_BOOK_DATE := "GetInterestBookingDate"(ACCOUNT_ID, DATE_TO, posBookingMethod);
				NEG_BOOK_DATE := "GetInterestBookingDate"(ACCOUNT_ID, DATE_TO, negBookingMethod);
				countInterestsTo := DATE_TO;
			END IF;
		END IF;

		-- calculate daily interests
		"CalculateAccountDailyInterests"(ACCOUNT_ID, countInterestsTo);
		
		FOR interest IN interestsCur
		LOOP
			
			INSERT INTO "AccountEntries" (
				"TransactionType", 
				"ValidFrom", 
				"ValidTo", 
				"AccountingDate", 
				"ValidationDate",
				"Amount",
				"Visibility",
				"Status",
				"InterestPercent",
				"Account_Id",
				"LastChange_Changed",
				"LastChange_ChangedBy")
			VALUES(
				APPLICATIONVALUES.TT_INTEREST, -- TransactionType = Interest
				interest.valid_from, 
				interest.valid_to, 
				TRUNC(interest.accounting_date),
				TRUNC(interest.accounting_date),
				interest.amount,
				APPLICATIONVALUES.AEV_VISIBLE, -- Visibility = Visible
				APPLICATIONVALUES.AES_CREATED, -- Status = Created
				interest.interest_rate,
				ACCOUNT_ID,
				SYSTEMTIME,
				CURRENTUSER)
			RETURNING "Id" INTO accountEntryId;
		
			UPDATE "Interests" SET "InterestEntry_Id" = accountEntryId
			WHERE "Account_Id" = ACCOUNT_ID
				AND "InterestDate" >= interest.VALID_FROM
				AND "InterestDate" <= interest.VALID_TO
				AND "InterestRate" = interest.INTEREST_RATE
				AND SIGN("Amount") = SIGN(interest.amount);
 
		END LOOP;
	END "AccountInterestsForAccount";

/*******************************************************************************/
	PROCEDURE "AccountInterests"(DATE_TO IN DATE) AS
		CURSOR accCur IS
			SELECT A."Id"
			FROM "Accounts" A WHERE A."TimeValidity_ValidFrom" <= DATE_TO;
	BEGIN

		IF (CURRENTACCOUNTID IS NOT NULL) THEN 
		"AccountInterestsForAccount"(CURRENTACCOUNTID, DATE_TO);
		ELSE
			FOR acc IN accCur
			LOOP
				 BEGIN
					"AccountInterestsForAccount"(acc."Id", DATE_TO);
				EXCEPTION
				WHEN OTHERS THEN
						MAINTENANCE."LogError"(SQLERRM);
						CONTINUE;
				END;
			END LOOP;
		END IF;

	END "AccountInterests";

/*******************************************************************************/
	PROCEDURE "CreateReminders"(DATE_TO IN DATE, ACCOUNTS_TO_CLOSE OUT T_OUT_CURSOR) AS
		
		reminderDays NUMBER;
		reminderCount NUMBER;
		reminderMinimumPayment NUMBER;

		reminderAmount NUMBER;
		reminderDueDate DATE;
		reminderCreateDate DATE; 
		incomes NUMBER;
		
		expectationId NUMBER;
			
		accountsToClose T_NUMBER_ARRAY := T_NUMBER_ARRAY();

		processedStatementId NUMBER := 0;

		CURSOR statementsCur(dateTo DATE) IS
		SELECT * 
		FROM
		(
			SELECT
				"Statements"."Id" "Statement_Id",
				"Statements"."Account_Id" "Account_Id",
				--"Statements"."Created",
				--"Statements"."Status",
				--"Statements"."DueDate" "Statement_DueDate",
				"Statements"."MinimumPayment",
				--"Statements"."PreviousDebt",
				"Reminders"."Id" "Reminder_Id", 
				NVL("Reminders"."ReminderNumber", 0) "ReminderNumber",
				--"Reminders"."DueDate" "Reminder_DueDate",
				NVL("Reminders"."DueDate", "Statements"."DueDate") "DueDate",
				--Income.Income "Income",
				NVL(Income.Income,0) - "Statements"."MinimumPayment" "Difference",
				TO_NUMBER("SystemSettings"."Value") "ReminderDelay",
				Templates."ReminderFee",
				"Accounts"."ReferenceNumber",
				"Accounts"."Status" "AccountStatus"
			FROM "Statements"
			LEFT JOIN TABLE(customeraccount."Incomes"(TRUNC("Statements"."Created"), TRUNC(dateTo))) Income ON Income.Account_Id = "Statements"."Account_Id"
			LEFT JOIN "Reminders" ON "Statements"."Id" = "Reminders"."Statement_Id"
			INNER JOIN "Accounts" ON "Statements"."Account_Id" = "Accounts"."Id"
			INNER JOIN "SystemSettings" ON "SystemSettings"."Key" = 'ReminderDelay'
			INNER JOIN 
			(
				SELECT 
					T."ReminderFee",
					AT."Account_Id"
				FROM "Templates" T
				INNER JOIN "AccountTemplates" AT ON T."Id" = AT."Template_Id"
				WHERE AT."TimeValidity_ValidFrom" <= TRUNC(dateTo) AND (AT."TimeValidity_ValidTo" >= TRUNC(dateTo) OR AT."TimeValidity_ValidTo" IS NULL)
			) Templates ON "Statements"."Account_Id" = Templates."Account_Id"
			WHERE 
				(("Reminders"."Status" IS NULL) OR ("Reminders"."Status" IN (APPLICATIONVALUES.RS_CREATED, APPLICATIONVALUES.RS_STATED)))
				AND "Statements"."Status" = APPLICATIONVALUES.SS_APPROVED 
				AND "Accounts"."Status" IN(APPLICATIONVALUES.AS_ACTIVE, APPLICATIONVALUES.AS_CLOSING, APPLICATIONVALUES.AS_INACTIVE) 
				AND "Statements"."EnableReminders" = APPLICATIONVALUES.SRS_ENABLED 
				AND ("Statements"."Account_Id" = NVL(CURRENTACCOUNTID, "Statements"."Account_Id"))
		)
		WHERE "DueDate" < dateTo-"ReminderDelay"
			AND "Difference" < 0
				
		ORDER BY "Account_Id", "ReminderNumber" desc
		;
		
	BEGIN

		reminderDays := "GetSystemSettingsNumberValue"('ReminderDays');
		reminderCount := "GetSystemSettingsNumberValue"('ReminderCount');
		reminderMinimumPayment := "GetSystemSettingsNumberValue"('MinimumReminderAmount');

		FOR statement IN statementsCur(date_To)
		LOOP

			-- check, that we process only one reminder for one statement
			IF processedStatementId = statement."Statement_Id" THEN
				MAINTENANCE."LogWarn"('Another reminder for statement (ID=' || statement."Statement_Id" || ') has already been processed. Reminder (ID=' || statement."Reminder_Id" || ') is in wrong status. ' , NULL, statement."Account_Id", MAINTENANCE.SYSTEM_LOG_TYPE_REMINDER);
				CONTINUE;
			END IF;
	
			-- income NOT OK AND last reminder passed
			IF (statement."ReminderNumber" >= reminderCount) THEN
				
				IF (statement."AccountStatus" = APPLICATIONVALUES.AS_ACTIVE) THEN
					IF NOT (statement."Account_Id" MEMBER OF accountsToClose) THEN
						accountsToClose.EXTEND;
						accountsToClose(accountsToClose.LAST) := statement."Account_Id";
					END IF;
				END IF;

				UPDATE "Reminders" SET "Status" = APPLICATIONVALUES.RS_UNPAID 
				WHERE "Id" = statement."Reminder_Id";

			END IF;

			-- income NOT OK AND last reminder not passed -> new reminder is created
			IF (statement."ReminderNumber" < reminderCount AND statement."AccountStatus" IN (APPLICATIONVALUES.AS_ACTIVE, APPLICATIONVALUES.AS_INACTIVE)) THEN
				
				reminderDueDate := DATE_TO + reminderDays;
				reminderDueDate := "CorrectToBusinessDayUp"(reminderDueDate);
				reminderAmount := ABS(statement."Difference");
				
				IF(reminderAmount < reminderMinimumPayment) THEN
					reminderAmount := reminderMinimumPayment;
				END IF;

				-- last reaminder for account has already been processed, account will be set to "Closing" status
				-- no new reminder is created for the account
				IF NOT (statement."Account_Id" MEMBER OF accountsToClose) THEN
				
					-- create reminder fee
					INSERT INTO "Expectations" ("PaymentDate", "Status", "ReferenceNumber", "Amount", "Created", "TransactionType", "LastChange_Changed", "LastChange_ChangedBy", "Account_Id", "Statement_Id")
					VALUES(null, APPLICATIONVALUES.ES_CREATED , statement."ReferenceNumber", -statement."ReminderFee", SYSTEMTIME , APPLICATIONVALUES.TT_REMINDERFEE, SYSTEMTIME, 'reminderBatch', statement."Account_Id", null)
					RETURNING "Id" INTO expectationID; 
						
					-- create reminder
					INSERT INTO "Reminders" ("Id", "DueDate", "Amount", "Created", "ReminderNumber", "Status", "FeeExpectation_Id", "Statement_Id")
					VALUES(REMINDERS_SEQ.NEXTVAL, reminderDueDate, reminderAmount, SYSTEMTIME, statement."ReminderNumber"+1, APPLICATIONVALUES.RS_CREATED, expectationID, statement."Statement_Id");
				
				END IF;

				-- update reminder status (if there is open reminder)
				IF (statement."Reminder_Id" IS NOT NULL) THEN
					UPDATE "Reminders" SET "Status" = APPLICATIONVALUES.RS_UNPAID
					WHERE "Id" = statement."Reminder_Id";
				END IF;

			END IF;

			processedStatementId := statement."Statement_Id";

		END LOOP;

		COMMIT;

		-- open cursor with accounts to close
		IF (accountsToClose.COUNT() > 0) THEN
			OPEN ACCOUNTS_TO_CLOSE FOR  
				SELECT "Accounts".*
				FROM "Accounts"
				WHERE "Accounts"."Id" IN (
										SELECT column_value
										FROM  TABLE(accountsToClose)
									);
		ELSE
			OPEN ACCOUNTS_TO_CLOSE FOR
				SELECT "Accounts".*
				FROM "Accounts"
				WHERE "Id" = -1;
		END IF; 

	END "CreateReminders";

/******************************************************************************/

	FUNCTION "GetInterestBookingDate"(ACCOUNT_ID IN NUMBER, DATE_TO IN DATE, BOOKING_METHOD IN NUMBER)
		RETURN DATE IS BOOKING_DUE_DATE DATE;
	BEGIN
		
		CASE BOOKING_METHOD
		
			-- statement due date
			--WHEN 1 THEN
			WHEN APPLICATIONVALUES.IBM_StatementDueDate THEN
				BOOKING_DUE_DATE := "GetPreviousStatement"(ACCOUNT_ID, DATE_TO)."AccountingPeriodEndDate";
				
			-- monthly
			--WHEN 2 THEN 
			WHEN APPLICATIONVALUES.IBM_Monthly THEN 
				SELECT LAST_DAY(TRUNC(TRUNC(DATE_TO , 'Month')-1 , 'Month')) INTO BOOKING_DUE_DATE
				FROM dual;
				
			-- quarterly
			--WHEN 3 THEN
			WHEN APPLICATIONVALUES.IBM_Quarterly THEN
				SELECT TRUNC(DATE_TO , 'Q')-1 INTO BOOKING_DUE_DATE
				FROM dual;
				
			-- six month
			--WHEN 4 THEN
			WHEN APPLICATIONVALUES.IBM_SixMonths THEN
				SELECT
					CASE MOD(TO_NUMBER(TO_CHAR(DATE_TO, 'Q')), 2)
					WHEN 0 THEN (SELECT TRUNC(prevQuarter , 'Q')-1 FROM (SELECT TRUNC(DATE_TO, 'Q')-1 prevQuarter FROM dual))
					WHEN 1 THEN (SELECT TRUNC(DATE_TO , 'Q')-1 FROM dual)
					ELSE NULL
				END INTO BOOKING_DUE_DATE
				FROM dual;
				
				IF (BOOKING_DUE_DATE IS NULL) THEN
					CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('QuarterNmbInterestBooking', NULL);
				END IF;
				
			-- yearly
			--WHEN 5 THEN
			WHEN APPLICATIONVALUES.IBM_Yearly THEN
				SELECT LAST_DAY(ADD_MONTHS(TRUNC(TRUNC(DATE_TO , 'Year')-1 , 'Year'),11)) INTO BOOKING_DUE_DATE
				FROM dual;

			-- wrong  booking method
			ELSE
				CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('InterestBookingMethod', NULL);
		END CASE;
			
		IF BOOKING_DUE_DATE IS NULL THEN
			BEGIN
				SELECT TRUNC("TimeValidity_ValidFrom") - 1 INTO BOOKING_DUE_DATE
				FROM "Accounts"
				WHERE "Id" = ACCOUNT_ID;
				EXCEPTION WHEN NO_DATA_FOUND THEN
					CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('AccountWithIdDoesntExist', '''' || ACCOUNT_ID || ''' doesn''t exists. ');
			END;
		END IF;
		
		RETURN BOOKING_DUE_DATE;
	END "GetInterestBookingDate";  

/*******************************************************************************/
	FUNCTION "GetBalance"( ACCOUNT_ID IN NUMBER, DATE_TO IN DATE ) RETURN NUMBER AS
		balance NUMBER;
	BEGIN
		SELECT "Balance" 
		INTO balance
		FROM "AccountEntryView"
		WHERE "Id" = (	SELECT MAX("Id") 
						FROM "AccountEntryView"
						WHERE "AccountingDate" = (	SELECT MAX("AccountingDate") 
													FROM "AccountEntryView" 
													WHERE "Account_Id" = ACCOUNT_ID AND "AccountingDate" <= TRUNC(DATE_TO)
												 ) 
						AND "Account_Id" = ACCOUNT_ID
					 );  
	RETURN balance;
	END "GetBalance";

/*******************************************************************************/
	PROCEDURE "UpdateTemplate"(OLD_TEMPLATE_CODE IN VARCHAR2, NEW_TEMPLATE_CODE IN VARCHAR2)
	AS
		OLD_TEMPLATE_ID NUMBER;
		NEW_TEMPLATE_ID NUMBER;
		OLD_TEMPLATE_VALID_FROM DATE;
	BEGIN
		SELECT "Id" INTO OLD_TEMPLATE_ID FROM "Templates" WHERE "Code" = OLD_TEMPLATE_CODE;
		SELECT "Id" INTO NEW_TEMPLATE_ID FROM "Templates" WHERE "Code" = NEW_TEMPLATE_CODE;

		UPDATE "AccountTemplates" SET "TimeValidity_ValidTo" = TRUNC(SYSTEMTIME) + 1 - 1/86400 WHERE "Template_Id" = OLD_TEMPLATE_ID AND "TimeValidity_ValidFrom" <= TRUNC(SYSTEMTIME);
		UPDATE "Templates" SET "Status" = APPLICATIONVALUES.TS_OBSOLETE /*Obsolete*/ WHERE "Id" = OLD_TEMPLATE_ID;
		UPDATE "CustomerSegments" SET "Template_Id" = NEW_TEMPLATE_ID WHERE "Template_Id" = OLD_TEMPLATE_ID;	   
		
		INSERT INTO "AccountTemplates" ("Id", "TimeValidity_ValidFrom", "TimeValidity_ValidTo", "LastChange_Changed", "LastChange_ChangedBy", "Account_Id", "Template_Id") 
			SELECT ACCOUNTTEMPLATES_SEQ.NEXTVAL, TRUNC("TimeValidity_ValidTo") + 1, null, "LastChange_Changed", "LastChange_ChangedBy", "Account_Id", NEW_TEMPLATE_ID
			FROM "AccountTemplates"
			WHERE "Template_Id" = OLD_TEMPLATE_ID AND "TimeValidity_ValidFrom" <= TRUNC(SYSTEMTIME);

		UPDATE "AccountTemplates" SET "Template_Id" = NEW_TEMPLATE_ID WHERE "Template_Id" = OLD_TEMPLATE_ID AND "TimeValidity_ValidFrom" > TRUNC(SYSTEMTIME);

	END "UpdateTemplate";

/*******************************************************************************/
	PROCEDURE "GetXmlReminders"(XML_REMINDERS OUT T_OUT_CURSOR)
	AS
	BEGIN
		OPEN XML_REMINDERS FOR
			SELECT TO_NCLOB(XMLELEMENT("Reminder", (XMLFOREST(R."Created", R."DueDate", R."ReminderNumber", E."Amount", S."StatementNumber", S."DueDate", S."MinimumPayment")))) "ReminderData"
			FROM "Reminders" R LEFT JOIN "Expectations" E ON R."FeeExpectation_Id" = E."Id" JOIN "Statements" S ON R."Statement_Id" = S."Id"
			WHERE R."Status" = APPLICATIONVALUES.RS_CREATED /*Created*/;

	END "GetXmlReminders";

/*******************************************************************************/
	PROCEDURE "MatchPayments"(MATCHED_PAYMENT_COUNT OUT INTEGER)
	AS
		CURSOR MATCHED_PAYMENTT_CURSOR IS
		SELECT
			MATCHED_PAYMENTS.*,

			CASE WHEN ACCOUNT_STATUS = APPLICATIONVALUES.AS_WAITINGFORREVERSEDPAYMENTS /*Waiting For Reversed Payments*/ THEN APPLICATIONVALUES.TT_REVERSEDPAYMENT /*Reversed Payment*/
			ELSE APPLICATIONVALUES.TT_INCOME /*Income*/
			END TRANSACTION_TYPE,

			CASE WHEN ACCOUNT_STATUS = APPLICATIONVALUES.AS_WAITINGFORREVERSEDPAYMENTS /*Waiting For Reversed Payments*/ THEN ACCOUNT_CLOSING_DATE
			ELSE MATCHED_PAYMENTS."PaymentDate"
			END PAYMENT_DATE,

			CASE WHEN ACCOUNT_START_DATE IS NOT NULL AND MATCHED_PAYMENTS."PaymentDate" < ACCOUNT_START_DATE THEN 'Y'
			ELSE 'N'
			END IS_BEFORE_ACCOUNT_VALIDITY,

			CASE WHEN ACCOUNT_REFERENCE IS NOT NULL THEN 'Y'
			ELSE 'N'
			END IS_REFERENCE_MATCH,

			CASE WHEN PAYMENT_CURRENCY = ACCOUNT_CURRENCY THEN 'Y'
			ELSE 'N'
			END IS_CURRENCY_MATCH,

			/*CASE WHEN ACCOUNT_DEBTOR = PAYMENT_ACCOUNT_DEBTOR OR PAYMENT_DEBTOR IS NULL THEN 'Y'
			ELSE 'N'
			END*/
			'Y' IS_DEBTOR_MATCH,

			CASE WHEN ACCOUNT_REFERENCE IS NOT NULL AND PAYMENT_CURRENCY = ACCOUNT_CURRENCY AND ACCOUNT_STATUS <> APPLICATIONVALUES.AS_CLOSED /*Closed*/ AND ACCOUNT_START_DATE <= MATCHED_PAYMENTS."PaymentDate"
			/*AND (ACCOUNT_DEBTOR = PAYMENT_ACCOUNT_DEBTOR OR PAYMENT_DEBTOR IS NULL) */ THEN 'Y'
			ELSE 'N'
			END IS_MATCH
		FROM 
		(
			SELECT
				P."Amount",
				P."PaymentDate",
				P."Id" PAYMENT_ID,
				P."Currency" PAYMENT_CURRENCY,
				--P."Status" PAYMENT_STATUS,
				P."ReferenceNumber" PAYMENT_REFERENCE,
				P."PayerIdentifier" PAYMENT_DEBTOR,
				NVL(PAYMENT_ACCOUNT."Id", INVOICE_ACCOUNT."Id") ACCOUNT_ID,
				NVL(PAYMENT_ACCOUNT."Status", INVOICE_ACCOUNT."Status") ACCOUNT_STATUS,
				NVL(PAYMENT_ACCOUNT."TimeValidity_ValidTo", INVOICE_ACCOUNT."TimeValidity_ValidTo") ACCOUNT_CLOSING_DATE,
				NVL(PAYMENT_ACCOUNT."TimeValidity_ValidFrom", INVOICE_ACCOUNT."TimeValidity_ValidFrom") ACCOUNT_START_DATE,
				NVL(PAYMENT_ACCOUNT."ReferenceNumber", INVOICE_ACCOUNT."ReferenceNumber") ACCOUNT_REFERENCE,
				NVL(PAYMENT_ACCOUNT."Currency", INVOICE_ACCOUNT."Currency") ACCOUNT_CURRENCY,
				NVL(PAYMENT_ACCOUNT."CustomerIdentifier", INVOICE_ACCOUNT."CustomerIdentifier") ACCOUNT_DEBTOR,
				CASE 	WHEN E."ReferenceNumber" IS NOT NULL THEN 'Y'
						ELSE 'N'
				END IS_INVOICE_MATCH
			FROM "Payments" P 
			LEFT JOIN "Expectations" E ON P."ReferenceNumber" = E."ReferenceNumber" AND E."TransactionType" = APPLICATIONVALUES.TT_OUTCOME /*Outcome*/
			LEFT JOIN "Accounts" PAYMENT_ACCOUNT ON P."ReferenceNumber" = PAYMENT_ACCOUNT."ReferenceNumber"
			LEFT JOIN "Accounts" INVOICE_ACCOUNT ON E."Account_Id" = INVOICE_ACCOUNT."Id"
			--LEFT JOIN "Accounts" DEBTOR_ACCOUNT ON P."PayerIdentifier" = DEBTOR_ACCOUNT."CustomerIdentifier"
			WHERE P."Status" = APPLICATIONVALUES.PS_IMPORTED /*Imported*/ 
				AND P."PaymentType" = APPLICATIONVALUES.PT_INCOMINGPAYMENT /*Incoming payment*/
		) MATCHED_PAYMENTS
		WHERE ACCOUNT_ID = NVL(CURRENTACCOUNTID, ACCOUNT_ID) OR (ACCOUNT_ID IS NULL AND NVL(CURRENTACCOUNTID, ACCOUNT_ID) IS NULL)

		
		ORDER BY "PaymentDate";

		LOG_MESSAGE CLOB;
		ENTRY_ID NUMBER;
		ACCOUNT_BALANCE NUMBER;
		REQUIRED_DEPOSIT NUMBER;
		
		--AccountEntrySequenceCorrupted EXCEPTION;
		--PRAGMA EXCEPTION_INIT(AccountEntrySequenceCorrupted, -20013); 
	BEGIN

		MATCHED_PAYMENT_COUNT := 0;

		FOR MATCHED_PAYMENT IN MATCHED_PAYMENTT_CURSOR
		LOOP
			IF MATCHED_PAYMENT.IS_MATCH = 'Y' THEN
				BEGIN

					INSERT INTO "AccountEntries" ("TransactionType", "ValidFrom", "ValidTo", "AccountingDate",  "ValidationDate", "Amount", "Visibility", "Status", "Account_Id", "Statement_Id", "LastChange_Changed", "LastChange_ChangedBy")
					VALUES (MATCHED_PAYMENT.TRANSACTION_TYPE, MATCHED_PAYMENT.PAYMENT_DATE, MATCHED_PAYMENT.PAYMENT_DATE,  MATCHED_PAYMENT.PAYMENT_DATE, MATCHED_PAYMENT.PAYMENT_DATE, MATCHED_PAYMENT."Amount", APPLICATIONVALUES.AEV_VISIBLE /*Visible*/,
						APPLICATIONVALUES.AES_CREATED /*Created*/, MATCHED_PAYMENT.ACCOUNT_ID, NULL, SYSTEMTIME, CURRENTUSER) RETURNING "Id" INTO ENTRY_ID;

				EXCEPTION

					WHEN CUSTOM_ORACLE_EXCEPTIONS.AccountEntrySqcCorrupted12 OR CUSTOM_ORACLE_EXCEPTIONS.AccountEntrySqcCorrupted13 OR CUSTOM_ORACLE_EXCEPTIONS.AccountEntrySqcCorrupted14 THEN 
						UPDATE "Payments" SET "Status" = APPLICATIONVALUES.PS_AESequenceCorrupted /*AccountEntrySequenceCorrupted*/ WHERE "Id" = MATCHED_PAYMENT.PAYMENT_ID;
						MAINTENANCE."LogError"(SQLERRM, NULL, MATCHED_PAYMENT.PAYMENT_ID, MAINTENANCE.SYSTEM_LOG_TYPE_PAYMENT);
						CONTINUE;

					WHEN OTHERS THEN
						UPDATE "Payments" SET "Status" = APPLICATIONVALUES.PS_FAILED /*Failed*/ WHERE "Id" = MATCHED_PAYMENT.PAYMENT_ID;
						MAINTENANCE."LogError"(SQLERRM, NULL, MATCHED_PAYMENT.PAYMENT_ID, MAINTENANCE.SYSTEM_LOG_TYPE_PAYMENT);
						CONTINUE;
				END;

				IF MATCHED_PAYMENT.IS_INVOICE_MATCH = 'Y' THEN
					MAINTENANCE."LogInfo"('Payment (Reference number: ''' || MATCHED_PAYMENT.PAYMENT_REFERENCE || ''') is matched by an expectaction reference number. ');
				ELSE
					MAINTENANCE."LogInfo"('Payment (Reference number: ''' || MATCHED_PAYMENT.PAYMENT_REFERENCE || '''; Customer ID: ''' || MATCHED_PAYMENT.ACCOUNT_DEBTOR || ''') processed successfully. ');
				END IF;

				UPDATE "Payments" SET "Status" = APPLICATIONVALUES.PS_PROCESSED /*Processed*/, "AccountEntry_Id" = ENTRY_ID WHERE "Id" = MATCHED_PAYMENT.PAYMENT_ID;

				MATCHED_PAYMENT_COUNT := MATCHED_PAYMENT_COUNT + 1;

				IF MATCHED_PAYMENT.ACCOUNT_STATUS = APPLICATIONVALUES.AS_WAITINGFORDEPOSIT /*Waiting for deposit*/ THEN
					SELECT T."RequiredDeposit" INTO REQUIRED_DEPOSIT
					FROM "AccountTemplates" AT
					JOIN "Templates" T ON AT."Template_Id" = T."Id"
					WHERE AT."Account_Id" = MATCHED_PAYMENT.ACCOUNT_ID
						AND AT."TimeValidity_ValidFrom" <= SYSTEMTIME 
						AND (AT."TimeValidity_ValidTo" >= TRUNC(SYSTEMTIME) OR AT."TimeValidity_ValidTo" IS NULL);

					SELECT "Balance" INTO ACCOUNT_BALANCE 
					FROM "AccountEntries" 
					WHERE "Id" = ENTRY_ID;

					IF ACCOUNT_BALANCE >= REQUIRED_DEPOSIT THEN
						UPDATE "Accounts" SET "Status" =  APPLICATIONVALUES.AS_ACTIVE /*Active*/ WHERE "Id" = MATCHED_PAYMENT.ACCOUNT_ID;
						MAINTENANCE."LogInfo"('Account (Reference number: ''' || MATCHED_PAYMENT.ACCOUNT_REFERENCE || ''') has been activated. ');
					END IF;
				END IF;

			ELSIF MATCHED_PAYMENT.IS_REFERENCE_MATCH = 'N' THEN 
				MAINTENANCE."LogError"('Payment (Reference number: ''' || MATCHED_PAYMENT.PAYMENT_REFERENCE || ''') cannot be matched because no account with the same reference number was found. ', NULL, MATCHED_PAYMENT.PAYMENT_ID, MAINTENANCE.SYSTEM_LOG_TYPE_PAYMENT);
				UPDATE "Payments" SET "Status" = APPLICATIONVALUES.PS_FAILED WHERE "Id" = MATCHED_PAYMENT.PAYMENT_ID;
			
			ELSIF MATCHED_PAYMENT.IS_REFERENCE_MATCH = 'Y' AND MATCHED_PAYMENT.IS_CURRENCY_MATCH = 'N' THEN
				MAINTENANCE."LogError"('Payment (Reference number: ''' || MATCHED_PAYMENT.PAYMENT_REFERENCE || '''; Customer ID: ''' || MATCHED_PAYMENT.ACCOUNT_DEBTOR || ''') cannot be matched because the payment currency (' || MATCHED_PAYMENT.PAYMENT_CURRENCY || ') differs from account currency (' || MATCHED_PAYMENT.ACCOUNT_CURRENCY || '). ', NULL,  MATCHED_PAYMENT.PAYMENT_ID, MAINTENANCE.SYSTEM_LOG_TYPE_PAYMENT);
				UPDATE "Payments" SET "Status" = APPLICATIONVALUES.PS_FAILED WHERE "Id" = MATCHED_PAYMENT.PAYMENT_ID;
			
			ELSIF MATCHED_PAYMENT.ACCOUNT_STATUS = APPLICATIONVALUES.AS_CLOSED THEN
				MAINTENANCE."LogError"('Payment (Reference number: ''' || MATCHED_PAYMENT.PAYMENT_REFERENCE || '''; Customer ID: ''' || MATCHED_PAYMENT.ACCOUNT_DEBTOR || ''') cannot be matched because the account is closed. ', NULL, MATCHED_PAYMENT.PAYMENT_ID, MAINTENANCE.SYSTEM_LOG_TYPE_PAYMENT);
				UPDATE "Payments" SET "Status" = APPLICATIONVALUES.PS_FAILED WHERE "Id" = MATCHED_PAYMENT.PAYMENT_ID;

			ELSIF MATCHED_PAYMENT.IS_BEFORE_ACCOUNT_VALIDITY = 'Y' THEN
				MAINTENANCE."LogError"('Payment (Reference number: ''' || MATCHED_PAYMENT.PAYMENT_REFERENCE || '''; Customer ID: ''' || MATCHED_PAYMENT.ACCOUNT_DEBTOR || ''') cannot be matched because the payment date is before account start date. ', NULL, MATCHED_PAYMENT.PAYMENT_ID, MAINTENANCE.SYSTEM_LOG_TYPE_PAYMENT);
				UPDATE "Payments" SET "Status" = APPLICATIONVALUES.PS_FAILED WHERE "Id" = MATCHED_PAYMENT.PAYMENT_ID;

			END IF;
		END LOOP;

		"PayStatements"(SYSTEMTIME);
	END "MatchPayments";

/*******************************************************************************/
		PROCEDURE "GetXmlAnnualStatement"(ACCOUNT_ID IN NUMBER, YEAR IN NUMBER, XML_ANNUAL_STATEMENT OUT T_OUT_CURSOR)
	AS
	BEGIN
		OPEN XML_ANNUAL_STATEMENT FOR
			SELECT TO_NCLOB(XMLELEMENT("AccountEntry", (XMLFOREST(e."AccountingDate", e."ValidFrom", e."ValidTo", e."Amount", e."Balance", e."InterestPercent", s."StatementNumber")))) "StatementData"
			FROM "AccountEntries" e 
			LEFT JOIN "Statements" s ON s."Id" = e."Statement_Id"
			WHERE e."Account_Id" = ACCOUNT_ID
				AND e."Visibility" = APPLICATIONVALUES.AEV_Visible
				AND EXTRACT(YEAR FROM e."AccountingDate") = YEAR
			ORDER BY e."AccountingDate", e."Id";
	END "GetXmlAnnualStatement";

/*******************************************************************************/
	PROCEDURE "CreateIncomeStatements"(REPORTING_YEAR NUMBER) 
	AS
		 now DATE;
	BEGIN

		now := systemtime;		 

		MERGE INTO "IncomeStatements" ist
		USING 
		(
			SELECT
				"Account_Id",
				"Type",
				SUM("Amount") "TotalAmount"
			FROM
			(
				SELECT
					AE."Account_Id",
					AE."Amount",
					CASE
						WHEN ((AE."Amount" > 0 AND AE."OriginalEntry_Id" IS NULL) OR (AE."Amount" < 0 AND AE."OriginalEntry_Id" IS NOT NULL)) THEN APPLICATIONVALUES.IST_PositiveInterest 
						ELSE APPLICATIONVALUES.IST_NegativeInterest
					END "Type"
				FROM "AccountEntries" AE
				LEFT JOIN "AccountEntries" RAE ON AE."Id" = RAE."OriginalEntry_Id"
				WHERE AE."TransactionType" = APPLICATIONVALUES.TT_Interest
					AND EXTRACT(YEAR FROM AE."AccountingDate") = REPORTING_YEAR
			)
			GROUP BY "Account_Id", "Type"
		) ae
		ON (ist."Account_Id" = ae."Account_Id" AND ist."Type" = ae."Type")
		WHEN MATCHED THEN
			UPDATE SET 
				ist."Amount" = ae."TotalAmount", 
				ist."Changed" = now,
				ist."Status" = CASE WHEN ae."TotalAmount" = 0 THEN APPLICATIONVALUES.ISS_Deleted ELSE APPLICATIONVALUES.ISS_Changed END
			 WHERE ist."Amount" <> ae."TotalAmount"
		WHEN NOT MATCHED THEN
			INSERT ("Id", "Amount", "Type", "Year", "Created", "Changed", "Account_Id", "Status", "SpecificationNumber")
			VALUES (INCOMESTATEMENTS_SEQ.nextval, ae."TotalAmount", ae."Type", REPORTING_YEAR, now, now, ae."Account_Id", APPLICATIONVALUES.ISS_Created, SPECIFICATIONNUMBER_SEQ.nextval);

	END;

/*******************************************************************************/
	PROCEDURE "GetXmlIncomeStatements"(REPORTING_YEAR NUMBER, XML_INCOME_STATEMENTS OUT T_OUT_CURSOR) AS
	BEGIN

		OPEN XML_INCOME_STATEMENTS FOR
		SELECT 
			
			-- companies
			XMLELEMENT("UGNR", XMLATTRIBUTES(com."Identifier" "Number"),
			
				-- income statements
				(

					-- customer element
					SELECT /*SYS_*/XMLAGG(
						XMLELEMENT("Customer",

							/*Personal Info*/
							xmlelement("PersonalInfo", XMLATTRIBUTES(acc."Id", acc."ReferenceNumber" "PersonNr")),

							/*Positive Interests*/ 
							XMLAGG(
								CASE WHEN ins."Type" = APPLICATIONVALUES.IST_POSITIVEINTEREST THEN
									XMLELEMENT ("PositiveInterest", 
										XMLATTRIBUTES(ins."Amount" "Value", ins."SpecificationNumber" "SpecificationNumber", ins."Type" "Type", ins."Status" "Status", to_char(ins."Created", 'YYYY-MM-DD') "Created", to_char(ins."Changed", 'YYYY-MM-DD') "Changed"))
								END 
							),

							/*Negative Interests*/
							XMLAGG(
								CASE WHEN ins."Type" = APPLICATIONVALUES.IST_NEGATIVEINTEREST THEN
									XMLELEMENT ("NegativeInterest", 
										XMLATTRIBUTES(ABS(ins."Amount") "Value", ins."SpecificationNumber" "SpecificationNumber", ins."Type" "Type", ins."Status" "Status", to_char(ins."Created", 'YYYY-MM-DD')  "Created", to_char(ins."Changed", 'YYYY-MM-DD') "Changed"))
								END
							)
						)/*, XMLFORMAT('Customers')*/
						order by acc."Id"
					)
					
					FROM "Accounts" acc
					JOIN "IncomeStatements" ins ON acc."Id" = ins."Account_Id"
					--WHERE ins."Status" = APPLICATIONVALUES.ISS_CREATED OR ins."Status" = APPLICATIONVALUES.ISS_CHANGED
					WHERE ins."Status" <> APPLICATIONVALUES.ISS_Stated AND ins."Year" = REPORTING_YEAR
					GROUP BY acc."ReferenceNumber", acc."Id"
				) "Accounts" 
			).GETCLOBVAL() "IncomeStatementsData"
		FROM
		"Companies" com;
	END;

/*******************************************************************************/
	FUNCTION "GetSystemSettingsNumberValue"(SYSTEM_SETTINGS_KEY VARCHAR2) RETURN NUMBER AS
		numberValue NUMBER;
		stringValue VARCHAR2(2000);
	BEGIN
		stringValue := "GetSystemSettingsStringValue"(SYSTEM_SETTINGS_KEY);
		numberValue := to_number(stringValue);
		RETURN numberValue;
	END;
	
/*******************************************************************************/
	FUNCTION "GetSystemSettingsStringValue"(SYSTEM_SETTINGS_KEY VARCHAR2) RETURN VARCHAR2 AS	
	stringValue VARCHAR2(2000);
	BEGIN
		BEGIN
			SELECT "Value" INTO stringValue FROM "SystemSettings"  WHERE "Key" = SYSTEM_SETTINGS_KEY;
			EXCEPTION WHEN NO_DATA_FOUND 
				THEN CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('NoSystemSettingsKeyFound', SYSTEM_SETTINGS_KEY);
		END;
		RETURN stringValue;
	END;

/*******************************************************************************/
	PROCEDURE "GetGlExportShipmentNumber" (SHIPMENT_NUMBER OUT INTEGER) IS
	BEGIN
		SELECT GLSHIPMENTEXPORTNUMBER_SEQ.nextval INTO SHIPMENT_NUMBER FROM dual;
	END;
	
/*******************************************************************************/
	FUNCTION "CalculateIncome"(ACCOUNT_ID IN NUMBER, DATE_FROM DATE, DATE_TO DATE) RETURN NUMBER AS
	accountIncome NUMBER;
	BEGIN

		BEGIN
			SELECT incomeTable.Income INTO accountIncome
			FROM TABLE(customeraccount."Incomes"(DATE_FROM, DATE_TO)) incomeTable
			WHERE incomeTable.Account_Id = "CalculateIncome".ACCOUNT_ID;

			EXCEPTION WHEN NO_DATA_FOUND THEN accountIncome := 0;
		END;

		IF (accountIncome IS NULL) THEN accountIncome := 0;
		END IF;
		
		RETURN accountIncome;
	END;

/*******************************************************************************/
	PROCEDURE "PayStatements"(DATE_TO IN DATE) IS
		
		CURSOR statementsCur(dateTo DATE) IS
			SELECT "Statements"."Id" "Id" --statement_id,
			FROM "Statements"
			JOIN "Accounts" ON "Statements"."Account_Id" = "Accounts"."Id"
			JOIN TABLE(CUSTOMERACCOUNT."Incomes"("Statements"."Created", dateTo)) Income ON Income.Account_Id = "Statements"."Account_Id"
			WHERE "Statements"."Status" = APPLICATIONVALUES.SS_APPROVED
				AND Income.Income >= "Statements"."MinimumPayment"
				AND "Accounts"."Status" IN (APPLICATIONVALUES.AS_ACTIVE, APPLICATIONVALUES.AS_CLOSING, APPLICATIONVALUES.AS_INACTIVE)
				AND ("Statements"."Account_Id" = NVL(CURRENTACCOUNTID, "Statements"."Account_Id"))
			ORDER BY "Statements"."Account_Id", "Statements"."Created" DESC;

	BEGIN
	
		FOR statement IN statementsCur(DATE_TO)
		LOOP 
			UPDATE "Statements" SET "Status" = APPLICATIONVALUES.SS_PAID 
			WHERE "Id" = statement."Id";

			UPDATE "Reminders" SET "Status" = APPLICATIONVALUES.RS_PAID 
			WHERE "Statement_Id" = statement."Id"
				AND "Status" IN (APPLICATIONVALUES.RS_CREATED, APPLICATIONVALUES.RS_STATED);
		END LOOP;
	 
	END;

/*******************************************************************************/
	FUNCTION "Incomes"(DATE_FROM DATE, DATE_TO DATE) RETURN ACCOUNT_INCOME_TABLE PIPELINED AS
		TYPE INCOME_RECORD IS RECORD (ACCOUNT_ID NUMBER, INCOME NUMBER);
		TYPE INCOME_RECORDS IS TABLE OF INCOME_RECORD INDEX BY BINARY_INTEGER;
		INCOME_COLLECTION$ INCOME_RECORDS; 
	BEGIN
		SELECT "Account_Id", SUM("Amount") BULK COLLECT INTO INCOME_COLLECTION$
		FROM "AccountEntries"
		WHERE "Visibility" = APPLICATIONVALUES.AEV_VISIBLE
			AND TRUNC("ValidationDate") >= TRUNC(DATE_FROM)
			AND TRUNC("ValidationDate") <= TRUNC(DATE_TO)
			AND 
				(
					("TransactionType" = APPLICATIONVALUES.TT_INCOME)
					OR 
					("TransactionType" = APPLICATIONVALUES.TT_REVERSEDPAYMENT)
					OR
					("TransactionType" = APPLICATIONVALUES.TT_MANUALCORRECTION)
					OR
					("TransactionType" = APPLICATIONVALUES.TT_REFUND)
					OR
					("TransactionType" = APPLICATIONVALUES.TT_OUTCOME AND "Amount" > 0)
--				OR 
--				("TransactionType" = APPLICATIONVALUES.TT_INTEREST AND "Amount" > 0)
				)
		GROUP BY "Account_Id";
		
		FOR i IN 1..INCOME_COLLECTION$.COUNT
		LOOP 
			PIPE ROW (ACCOUNT_INCOME_TYPE(INCOME_COLLECTION$(i).Account_Id, INCOME_COLLECTION$(i).income));
		END LOOP;
	
		RETURN;      
	END;

	/*******************************************************************************/	
	FUNCTION "GetInterestAccountingDates"(ACCOUNT_ID IN NUMBER, DATE_FROM IN DATE, DATE_TO IN DATE) RETURN SYS_REFCURSOR AS
		CUR SYS_REFCURSOR;
	BEGIN
		OPEN CUR FOR 
			SELECT *
			FROM
			(
				WITH interestDates AS
				(
					SELECT "Positive", "Negative" 
					FROM 
					(
						SELECT
							CUSTOMERACCOUNT."GetInterestBookingDate"(ACCOUNT_ID, DAY, PIBM) "Positive",
							CUSTOMERACCOUNT."GetInterestBookingDate"(ACCOUNT_ID, DAY, NIBM) "Negative"
						FROM
						(
							SELECT 
								DAYS.*,
								"PositiveInterestBookingMethod" PIBM,
								"NegativeInterestBookingMethod" NIBM
							FROM
							(
								--SELECT
								--	ACCOUNT_ID ACCOUNT_ID, 
								--	(TRUNC(DATE_FROM) + LEVEL)-1 DAY 
								--FROM DUAL CONNECT BY LEVEL < (SELECT TRUNC(DATE_TO) - TRUNC(DATE_FROM) FROM DUAL)
								SELECT ACCOUNT_ID ACCOUNT_ID,	COLUMN_VALUE DAY
								FROM TABLE(CUSTOMERACCOUNT."GenerateDays"(TRUNC(DATE_FROM), TRUNC(DATE_TO)+1))
							) DAYS
							JOIN "AccountTemplates" AT ON AT."Account_Id" = DAYS.ACCOUNT_ID 
							JOIN "Templates" T ON AT."Template_Id" = T."Id"
							WHERE
								TRUNC(AT."TimeValidity_ValidFrom") <= DAYS.DAY 
								AND (TRUNC(AT."TimeValidity_ValidTo") >= DAYS.DAY OR AT."TimeValidity_ValidTo" IS NULL)
						) BOOKING
					)
				)
				SELECT DISTINCT "Positive" BOOK_DATE, SIGN(1) BOOK_TYPE FROM interestDates
				UNION 
				SELECT DISTINCT "Negative", SIGN(-1) FROM interestDates
			)
			WHERE BOOK_DATE >= DATE_FROM AND BOOK_DATE <= DATE_TO
			ORDER BY BOOK_DATE;

			RETURN CUR;
	END;

/*******************************************************************************/
	PROCEDURE "ReverseEntry"(ENTRY_ID NUMBER) AS
		ENTRY_ROW "AccountEntries"%RowType;
	BEGIN
		SELECT * INTO ENTRY_ROW FROM "AccountEntries" WHERE "Id" = ENTRY_ID;
			
		INSERT INTO "AccountEntries" ("TransactionType", "ValidFrom", "ValidTo", "AccountingDate", "ValidationDate", "Amount", "Visibility", 
			"Status", "Account_Id", "Statement_Id", "Expectation_Id", "OriginalEntry_Id", "LastChange_Changed", "LastChange_ChangedBy")
		VALUES (ENTRY_ROW."TransactionType", TRUNC(SYSTEMTIME), TRUNC(SYSTEMTIME), TRUNC(SYSTEMTIME), TRUNC(ENTRY_ROW."AccountingDate"), (-1)*(ENTRY_ROW."Amount"), APPLICATIONVALUES.AEV_VISIBLE,
			APPLICATIONVALUES.AES_CREATED, ENTRY_ROW."Account_Id", NULL, NULL, ENTRY_ROW."Id", SYSTEMTIME, CURRENTUSER);
	END;
	
/*******************************************************************************/
	PROCEDURE "PayStatement" (STATEMENT_ID IN NUMBER) AS
		TYPE T_REMINDER_RECORD IS RECORD (ID NUMBER, MINIMUM_PAYMENT NUMBER, INCOME_TILL_CREATE NUMBER, INCOME_TILL_DUE_DATE NUMBER, FEE_EXPECTATION_ID NUMBER, FEE_ENTRY_ID NUMBER);
		TYPE T_REMINDERS_RECORDS IS TABLE OF T_REMINDER_RECORD INDEX BY BINARY_INTEGER;
		REMINDERS$ T_REMINDERS_RECORDS;
				 
	BEGIN
	
		-- pay statement 
		UPDATE "Statements" SET "Status" = APPLICATIONVALUES.SS_PAID
		WHERE "Id" = STATEMENT_ID;
		
		-- get statement reminders
		SELECT
			R."Id",
			S."MinimumPayment",
			CUSTOMERACCOUNT."CalculateIncome"(S."Account_Id", S."Created", R."Created") "IncomeTillCreate",
			CUSTOMERACCOUNT."CalculateIncome"(S."Account_Id", S."Created", R."DueDate" + TO_NUMBER(SS."Value")) "IncomeTillDueDate",
			R."FeeExpectation_Id",
			AE."Id"
		BULK COLLECT INTO REMINDERS$
		FROM "Reminders" R
		JOIN "Statements" S ON R."Statement_Id" = S."Id" AND S."Id" = STATEMENT_ID
		JOIN "SystemSettings" SS ON SS."Key" = 'ReminderDelay'
		JOIN "Expectations" E ON R."FeeExpectation_Id" = E."Id"
		LEFT JOIN "AccountEntries" AE ON E."Id" = AE."Expectation_Id"
		ORDER BY R."Id";
		
		IF REMINDERS$.COUNT > 0 THEN
			FOR I IN REMINDERS$.FIRST .. REMINDERS$.LAST
			LOOP

				-- cancel reminder
				IF (REMINDERS$(I).INCOME_TILL_CREATE >= REMINDERS$(I).MINIMUM_PAYMENT) THEN
					UPDATE "Reminders" SET "Status" = APPLICATIONVALUES.RS_CANCELLED WHERE "Id" = REMINDERS$(I).ID;
					
					-- cancel fee expectation, which is not accounted yet
					IF (REMINDERS$(I).FEE_ENTRY_ID IS NULL) THEN
						UPDATE "Expectations" SET "Status" = APPLICATIONVALUES.ES_CANCELLED
						WHERE "Id" = REMINDERS$(I).FEE_EXPECTATION_ID;
						
					-- reverse accounted fee
					ELSE
						"ReverseEntry"(REMINDERS$(I).FEE_ENTRY_ID);
					END IF;

					CONTINUE;
						
				END IF;
				
				-- pay reminder
				IF (REMINDERS$(I).INCOME_TILL_DUE_DATE >= REMINDERS$(I).MINIMUM_PAYMENT) THEN
					UPDATE "Reminders" SET "Status" = APPLICATIONVALUES.RS_PAID WHERE "Id" = REMINDERS$(I).ID;
				END IF;
				
			END LOOP;
		END IF;
		
	END;

/*******************************************************************************/
	--PROCEDURE "ReverseAccountInterests"(ACCOUNT_ID IN NUMBER, DATE_FROM IN DATE) AS
	FUNCTION "ReverseAccountInterests"(ACCOUNT_ID IN NUMBER, DATE_FROM IN DATE) RETURN DATE AS
		--ACCOUNTED_INTERESTS$ T_NUMBER_ARRAY;
		--REVERSED_INTEREST_CURSOR T_OUT_CURSOR;
		FIRST_REVERSED_DATE DATE := DATE_FROM;
		TYPE T_INTEREST IS RECORD(ENTRY_ID NUMBER, VALID_FROM DATE);
		TYPE T_INTERESTS IS TABLE OF T_INTEREST;
		ACCOUNTED_INTERESTS$ T_INTERESTS;
	BEGIN
		
		-- get accounted interests
		SELECT AE."Id", AE."ValidFrom"
		BULK COLLECT INTO ACCOUNTED_INTERESTS$
		FROM "AccountEntries" AE
		LEFT OUTER JOIN "AccountEntries" REVERSED_AE ON AE."Id" = REVERSED_AE."OriginalEntry_Id"
		WHERE AE."Account_Id" = ACCOUNT_ID
			AND AE."OriginalEntry_Id" IS NULL 
			AND REVERSED_AE."Id" IS NULL
			AND AE."TransactionType" = APPLICATIONVALUES.TT_INTEREST
			AND TRUNC(AE."AccountingDate") >= TRUNC(DATE_FROM)
		ORDER BY AE."Id";
			
		-- reverse accounted interests
		IF ACCOUNTED_INTERESTS$.COUNT > 0 THEN
			FOR I IN ACCOUNTED_INTERESTS$.FIRST .. ACCOUNTED_INTERESTS$.LAST
			LOOP
				"ReverseEntry"(ACCOUNTED_INTERESTS$(I).ENTRY_ID);
				IF (ACCOUNTED_INTERESTS$(I).VALID_FROM < FIRST_REVERSED_DATE) THEN
					FIRST_REVERSED_DATE := ACCOUNTED_INTERESTS$(I).VALID_FROM;
				END IF;
			END LOOP;
		END IF;

		-- open ref cursor
		--OPEN REVERSED_INTEREST_CURSOR FOR
		--	SELECT COLUMN_VALUE AS "Id" FROM TABLE (ACCOUNTED_INTERESTS$);

		RETURN FIRST_REVERSED_DATE;

	END;

/*******************************************************************************/
	PROCEDURE "CancelAccountStatements"(ACCOUNT_ID IN NUMBER, DATE_FROM IN DATE) AS
		CANCELLED_STATEMENS$ T_NUMBER_ARRAY;
		CANCELLED_REMINDER_FEES$ T_NUMBER_ARRAY;
		ACCOUNTED_REMINDER_FEES$ T_NUMBER_ARRAY;
	BEGIN
		
		-- cancell statements, which has been created later than DATE_FROM
		UPDATE "Statements" SET "Status" = APPLICATIONVALUES.SS_CANCELLED
		WHERE "Account_Id" = ACCOUNT_ID
			AND TRUNC("Created") >= TRUNC(DATE_FROM)
			AND "Status" IN (APPLICATIONVALUES.SS_APPROVED, APPLICATIONVALUES.SS_PAID)
		RETURNING "Id" 
		BULK COLLECT INTO CANCELLED_STATEMENS$;

		-- change status of expectations and account entries
		IF CANCELLED_STATEMENS$ IS NOT NULL AND CANCELLED_STATEMENS$.COUNT > 0 THEN

			UPDATE "Expectations" SET "Status" = APPLICATIONVALUES.ES_CREATED, "Statement_Id" = NULL
			WHERE "Statement_Id" IN (SELECT COLUMN_VALUE FROM TABLE(CANCELLED_STATEMENS$))
				AND "Status" IN (APPLICATIONVALUES.ES_STATED);

			UPDATE "AccountEntries" SET "Status" = APPLICATIONVALUES.AES_CREATED, "Statement_Id" = NULL
			WHERE "Statement_Id" IN (SELECT COLUMN_VALUE FROM TABLE(CANCELLED_STATEMENS$));

		END IF;
		
		-- cancell reminders of cancelled statements
		IF CANCELLED_STATEMENS$ IS NOT NULL AND CANCELLED_STATEMENS$.COUNT > 0 THEN
			UPDATE "Reminders" SET "Status" = APPLICATIONVALUES.RS_CANCELLED
			WHERE "Statement_Id" IN (SELECT COLUMN_VALUE FROM TABLE(CANCELLED_STATEMENS$))
			RETURNING "FeeExpectation_Id" BULK COLLECT INTO CANCELLED_REMINDER_FEES$;
		END IF;

		-- cancell not accounted reminder fees
		IF CANCELLED_REMINDER_FEES$ IS NOT NULL AND CANCELLED_REMINDER_FEES$.COUNT > 0 THEN
			UPDATE "Expectations" SET "Status" = APPLICATIONVALUES.ES_CANCELLED
			WHERE "Id" IN (SELECT COLUMN_VALUE FROM TABLE(CANCELLED_REMINDER_FEES$))
				AND "Status" IN (APPLICATIONVALUES.ES_CREATED, APPLICATIONVALUES.ES_STATED);
		END IF;
			
		-- get already accounted fees
		IF CANCELLED_REMINDER_FEES$ IS NOT NULL AND CANCELLED_REMINDER_FEES$.COUNT > 0 THEN
			SELECT "Id" 
			BULK COLLECT INTO ACCOUNTED_REMINDER_FEES$
			FROM "AccountEntries" AE
			WHERE "Expectation_Id" IN ((SELECT COLUMN_VALUE FROM TABLE(CANCELLED_REMINDER_FEES$)));
		END IF;

		-- reverse accounted fees
		IF ACCOUNTED_REMINDER_FEES$ IS NOT NULL AND ACCOUNTED_REMINDER_FEES$.COUNT > 0 THEN
			FOR I IN ACCOUNTED_REMINDER_FEES$.FIRST .. ACCOUNTED_REMINDER_FEES$.LAST
			LOOP
				"ReverseEntry"(ACCOUNTED_REMINDER_FEES$(I));
			END LOOP;
		END IF;

		-- reverse interests
		--"ReverseAccountInterests"(ACCOUNT_ID, DATE_FROM);

	END;

/*******************************************************************************/
	PROCEDURE "HandleUnpaidStatements"(ACCOUNT_ID IN NUMBER, DATE_FROM DATE) AS

		TYPE T_STATEMENT_RECORD IS RECORD (ID NUMBER, MINIMUM_PAYMENT NUMBER, INCOME NUMBER);
		TYPE T_STATEMENT_RECORDS IS TABLE OF T_STATEMENT_RECORD INDEX BY BINARY_INTEGER;
		UNPAID_STATEMENTS$ T_STATEMENT_RECORDS;

		CANCELLED_STATEMENS$ T_NUMBER_ARRAY;
		CANCELLED_REMINDER_FEES$ T_NUMBER_ARRAY;
	BEGIN

		"CancelAccountStatements"(ACCOUNT_ID, DATE_FROM);

		-- get unpaid statements
		SELECT *
		BULK COLLECT INTO UNPAID_STATEMENTS$
		FROM
		(
			SELECT 
				S."Id", 
				S."MinimumPayment", 
				CUSTOMERACCOUNT."CalculateIncome"(S."Account_Id", S."AccountingPeriodStartDate", SYSTEMTIME) "Income"
			FROM "Statements" S
			WHERE S."Account_Id" = ACCOUNT_ID
				AND S."Status" IN (APPLICATIONVALUES.SS_APPROVED/*, APPLICATIONVALUES.SS_PAID*/)
			ORDER BY S."Created"
		)
		WHERE "Income" >= "MinimumPayment";

		-- go through unpaid statements and pay them
		IF (UNPAID_STATEMENTS$.COUNT > 0) THEN
			FOR I IN UNPAID_STATEMENTS$.FIRST .. UNPAID_STATEMENTS$.LAST 
			LOOP
				"PayStatement"(UNPAID_STATEMENTS$(I).ID);
			END LOOP;
		END IF;
		
	END;

/*******************************************************************************/  
	FUNCTION "CalculateInterestCompBalance"(ACCOUNT_ID IN NUMBER, LAST_BALANCE IN NUMBER, DATE_FROM IN DATE, DATE_TO IN DATE) RETURN NUMBER
	AS
		AMOUNT_SUM NUMBER;
	BEGIN
		SELECT NVL(SUM("Amount"), 0)  INTO AMOUNT_SUM
		FROM "AccountEntries"
		WHERE "Account_Id" = ACCOUNT_ID 
			AND "ValidationDate" >= TRUNC(DATE_FROM)
			AND "ValidationDate" < TRUNC(DATE_TO);
			
		RETURN LAST_BALANCE+AMOUNT_SUM;
	END;

/*******************************************************************************/  
	FUNCTION "CalculateInterestCompensation"(ACCOUNT_ID IN NUMBER, DATE_FROM IN DATE, DATE_TO IN DATE, LAST_BALANCE IN NUMBER) RETURN INTEREST_CALC_TABLE PIPELINED AS
		INTEREST_COLLECTION$ INTEREST_CALC_TABLE;
		--LAST_BALANCE NUMBER;
	BEGIN

		SELECT INTEREST_CALC_TYPE
		(
			MAXIMUM_DAY_BALANCE,
			(MAXIMUM_DAY_BALANCE*INTEREST)/(100*YEAR_LENGTH),
			INTEREST,
			VALIDATION_DATE
		)
		BULK COLLECT INTO INTEREST_COLLECTION$
		FROM
		(
			SELECT
				ACCOUNT_ID,
				VALIDATION_DATE,
				DAY_AMOUNT,
				DAY_BALANCE,
				CASE
					WHEN T."MaximumInterestBasedAmount" < ACCOUNTING_VALUES.Day_Balance THEN T."MaximumInterestBasedAmount"
					ELSE ACCOUNTING_VALUES.Day_Balance
				END MAXIMUM_DAY_BALANCE,
				CASE
					WHEN DAY_BALANCE IS NULL THEN NULL
					WHEN ACCOUNTING_VALUES.DAY_BALANCE = 0 THEN 0
					WHEN ACCOUNTING_VALUES.DAY_BALANCE > 0 THEN T."PositiveInterestRate"+BI."Value"
					ELSE T."NegativeInterestRate"+BI."Value"
				END INTEREST,
				TO_NUMBER((TRUNC (ACCOUNTING_VALUES.VALIDATION_DATE,'yyyy')+ INTERVAL '1' YEAR-1)- (TRUNC(ACCOUNTING_VALUES.VALIDATION_DATE,'yyyy')))+1 YEAR_LENGTH
			FROM
				(
					SELECT
						ACCOUNT_ID,
						VALIDATION_DATE,
						DAY_AMOUNT,
						SUM (DAY_AMOUNT + CASE WHEN TRUNC(VALIDATION_DATE) = TRUNC(DATE_FROM) THEN LAST_BALANCE ELSE 0 END) OVER (ORDER BY VALIDATION_DATE) DAY_BALANCE
					FROM
					(
						SELECT
							ACCOUNT_ID,
							TRUNC(DAY) VALIDATION_DATE,
							NVL(SUM("Amount"), 0) DAY_AMOUNT
						FROM
						(
							SELECT 
								ACCOUNT_ID,
								DAY
							FROM
							(
								SELECT
									ACCOUNT_ID ACCOUNT_ID, -- AccountId parameter
									TRUNC(DATE_FROM-1) + LEVEL DAY -- last entry accounting date - 1 parameter
								FROM DUAL CONNECT BY LEVEL <= (SELECT TRUNC(DATE_TO) - TRUNC(DATE_FROM) FROM DUAL)
							) 
							WHERE rownum <= TRUNC(DATE_TO) - TRUNC(DATE_FROM)
						) -- days to generate parameter
					
						LEFT JOIN (
								SELECT 	"Account_Id",
										"Amount",
										"ValidationDate" + CASE -- other than income amount must be effectively postponed by one day
												WHEN "TransactionType" = APPLICATIONVALUES.TT_INTEREST THEN 1
												ELSE 0
										END "ValidDate"
								FROM "AccountEntries"
								WHERE "Account_Id" = ACCOUNT_ID 						
									AND TRUNC("ValidationDate") >= TRUNC(DATE_FROM)
							) AE ON ACCOUNT_ID = AE."Account_Id" AND DAY = AE."ValidDate"
						GROUP BY ACCOUNT_ID, DAY
					)
				) ACCOUNTING_VALUES,
			
				-- other tables
				"BaseInterests" BI,
				"AccountTemplates" AT,
				"Templates" T
			WHERE
			
				-- link base interests
				ACCOUNTING_VALUES.VALIDATION_DATE >= BI."TimeValidity_ValidFrom" AND (ACCOUNTING_VALUES.VALIDATION_DATE <= BI."TimeValidity_ValidTo" OR BI."TimeValidity_ValidTo" IS NULL)
			
				-- link account templates
				AND ACCOUNTING_VALUES.ACCOUNT_ID = AT."Account_Id"
				AND ACCOUNTING_VALUES.VALIDATION_DATE >= AT."TimeValidity_ValidFrom" AND (ACCOUNTING_VALUES.VALIDATION_DATE <= AT."TimeValidity_ValidTo" OR AT."TimeValidity_ValidTo" IS NULL)
			
				-- link templates
				AND AT."Template_Id" = T."Id"
			ORDER BY VALIDATION_DATE
		);
		
		FOR i IN 1..INTEREST_COLLECTION$.COUNT
		LOOP 
				PIPE ROW (INTEREST_CALC_TYPE(INTEREST_COLLECTION$(i).BALANCE, INTEREST_COLLECTION$(i).AMOUNT, INTEREST_COLLECTION$(i).RATE, INTEREST_COLLECTION$(i).DAY));
		END LOOP;
			 
		RETURN;
	END; 

/*******************************************************************************/
	PROCEDURE "CreateInterestCompensation"(ACCOUNT_DATA IN "Accounts"%ROWTYPE, DATE_FROM IN DATE, INTEREST_ACCOUNTING_DAYS IN SYS_REFCURSOR) AS
		ACCOUNT_ID NUMBER := ACCOUNT_DATA."Id";
		COMPENSATION NUMBER := 0;
--		LAST_INTEREST_DATE DATE;
		INTEREST_COLLECTION$ INTEREST_CALC_TABLE;
		INSERTED_INTERESTS$ T_NUMBER_ARRAY;
		COMPENSATION_ENTRY_ID NUMBER;

		TYPE T_INTEREST_ACCOUNTING_DAY IS RECORD (ACCOUNTING_DAY DATE, INTEREST_SIGN INT);
--		INTEREST_ACCOUNTING_DAYS SYS_REFCURSOR;
		INTEREST_ACCOUNTING_DAY T_INTEREST_ACCOUNTING_DAY;

		CALCULATE_COMPENSATION_FROM DATE := DATE_FROM;
		PREVIOUS_ACCOUNTING_DATE DATE := NULL;

		--/* DEBUG

		TYPE T_XX IS RECORD (InterestDate DATE, Balance NUMBER(20,5), Amount NUMBER(20,5));
		TYPE T_XXT IS TABLE OF T_XX INDEX BY BINARY_INTEGER;
		--TYPE T_XXT IS TABLE OF INTEREST_CALC_TYPE INDEX BY BINARY_INTEGER;
		XXT T_XXT;

		--*/
		
		LAST_BALANCE_BEFORE_CALC NUMBER := 0;
		LAST_BALANCE NUMBER := 0;

		CALCULATE_FROM DATE := DATE_FROM;
		LAST_POS_ACC_DATE DATE := DATE_FROM;
		LAST_NEG_ACC_DATE DATE := DATE_FROM;
	BEGIN
		LAST_BALANCE_BEFORE_CALC := "GetLastBalanceForAccount"(ACCOUNT_ID, DATE_FROM-1);
		
		LOOP 
    FETCH INTEREST_ACCOUNTING_DAYS
    INTO  INTEREST_ACCOUNTING_DAY;
    EXIT WHEN INTEREST_ACCOUNTING_DAYS%NOTFOUND; 

			IF (INTEREST_ACCOUNTING_DAY.INTEREST_SIGN = -1) THEN CALCULATE_COMPENSATION_FROM := LAST_NEG_ACC_DATE;
			ELSE CALCULATE_COMPENSATION_FROM := LAST_POS_ACC_DATE;
			END IF;
			
			LAST_BALANCE := "CalculateInterestCompBalance"(ACCOUNT_ID, LAST_BALANCE_BEFORE_CALC, DATE_FROM, CALCULATE_COMPENSATION_FROM-1);
			
			SELECT INTEREST_CALC_TYPE(BALANCE, AMOUNT, RATE, DAY)
			BULK COLLECT INTO INTEREST_COLLECTION$
			FROM TABLE("CalculateAccountDayInterests"(ACCOUNT_ID, CALCULATE_COMPENSATION_FROM, INTEREST_ACCOUNTING_DAY.ACCOUNTING_DAY+1, LAST_BALANCE, AE_COLUMN_VALIDATION_DATE))
			WHERE SIGN(AMOUNT) = INTEREST_ACCOUNTING_DAY.INTEREST_SIGN;
				
			IF (INTEREST_COLLECTION$ IS NOT NULL AND INTEREST_COLLECTION$.COUNT > 0) THEN


				--/* DBUG

					FOR I IN INTEREST_COLLECTION$.FIRST .. INTEREST_COLLECTION$.LAST 
					LOOP
						XXT(I).InterestDate := INTEREST_COLLECTION$(I).DAY; 
						XXT(I).Balance := INTEREST_COLLECTION$(I).BALANCE; 
						XXT(I).Amount := INTEREST_COLLECTION$(I).AMOUNT;
					END LOOP;

				--*/
			
				-- get sum of compensations
				SELECT SUM(AMOUNT) INTO COMPENSATION
				FROM TABLE(INTEREST_COLLECTION$);
						
				IF COMPENSATION IS NOT NULL THEN 
				
					-- save compensation entry
					INSERT INTO "AccountEntries" ("TransactionType", "ValidFrom", "ValidTo", "AccountingDate", "ValidationDate", "Amount", "Visibility", 
						"Status", "Account_Id", "Statement_Id", "Expectation_Id", "OriginalEntry_Id", "LastChange_Changed", "LastChange_ChangedBy")
					--VALUES (APPLICATIONVALUES.TT_INTEREST, TRUNC(DATE_FROM), TRUNC(LAST_INTEREST_DATE), TRUNC(SYSTEMTIME), TRUNC(SYSTEMTIME), COMPENSATION, APPLICATIONVALUES.AEV_VISIBLE,
					VALUES (APPLICATIONVALUES.TT_INTEREST, TRUNC(DATE_FROM), TRUNC(INTEREST_ACCOUNTING_DAY.ACCOUNTING_DAY), TRUNC(SYSTEMTIME), TRUNC(INTEREST_ACCOUNTING_DAY.ACCOUNTING_DAY), COMPENSATION, APPLICATIONVALUES.AEV_VISIBLE,
						APPLICATIONVALUES.AES_CREATED, ACCOUNT_ID, NULL, NULL, NULL, SYSTEMTIME, CURRENTUSER)
					RETURNING "Id" INTO COMPENSATION_ENTRY_ID;
				
					-- save day compensations
					IF COMPENSATION_ENTRY_ID IS NOT NULL THEN
						FORALL I IN INTEREST_COLLECTION$.FIRST .. INTEREST_COLLECTION$.LAST 
							INSERT INTO "InterestCompensations" ("Day", "Balance", "Amount", "Rate", "Account_Id", "AccountEntry_Id")
							VALUES (INTEREST_COLLECTION$(I).DAY, INTEREST_COLLECTION$(I).BALANCE, INTEREST_COLLECTION$(I).AMOUNT, INTEREST_COLLECTION$(I).RATE, ACCOUNT_ID, COMPENSATION_ENTRY_ID)
							RETURNING "Id" BULK COLLECT INTO INSERTED_INTERESTS$;
					END IF;

					IF (INTEREST_ACCOUNTING_DAY.INTEREST_SIGN = -1) THEN LAST_NEG_ACC_DATE := INTEREST_ACCOUNTING_DAY.ACCOUNTING_DAY+1;
					ELSE LAST_POS_ACC_DATE := INTEREST_ACCOUNTING_DAY.ACCOUNTING_DAY+1;
					END IF;
				
				END IF;
			
			END IF;

			PREVIOUS_ACCOUNTING_DATE := INTEREST_ACCOUNTING_DAY.ACCOUNTING_DAY;

			COMMIT;

			
		
		END LOOP;
		CLOSE INTEREST_ACCOUNTING_DAYS;

	END;

/*******************************************************************************/
	PROCEDURE "CreateDailyInterestComp"(ACCOUNT_ID IN NUMBER, FIRST_INSERT_DATE DATE) AS
		LATEST_DATE DATE;
		INTEREST_COLLECTION$ INTEREST_CALC_TABLE;
	BEGIN
	
		-- last interest date
		LATEST_DATE := "GetLastInterestForAccount"(ACCOUNT_ID);
		IF(ROUND(SYSTEMTIME) <= ROUND(LATEST_DATE)) THEN
			dbms_output.put_line('DateTo ('||SYSTEMTIME||') is less or equal than last interest date ('||LATEST_DATE||')');
			RETURN;
		END IF;
		
		SELECT INTEREST_CALC_TYPE(BALANCE, AMOUNT, RATE, DAY)
		BULK COLLECT INTO INTEREST_COLLECTION$
		FROM TABLE("CalculateInterestCompensation"(ACCOUNT_ID, FIRST_INSERT_DATE, SYSTEMTIME, 0))
		WHERE DAY > LATEST_DATE;
		
		FORALL I IN INTEREST_COLLECTION$.FIRST .. INTEREST_COLLECTION$.LAST
			INSERT INTO "Interests" ("Id", "Balance", "Amount", "InterestDate", "InterestRate", "Account_Id")
			VALUES (
				SYS_GUID(),
				INTEREST_COLLECTION$(I).BALANCE,
				INTEREST_COLLECTION$(I).AMOUNT,
				INTEREST_COLLECTION$(I).DAY,
				INTEREST_COLLECTION$(I).RATE,
				ACCOUNT_ID
			);
	END;

/*******************************************************************************/
	PROCEDURE "InsertEntries"(ACCOUNT_ID IN NUMBER, INSERTED_ENTRIES_LIST IN ACCOUNT_ENTRY_TABLE, RESULT_CURSOR OUT SYS_REFCURSOR) AS
			 
		FIRST_INSERTED_DATE DATE;
		LAST_INSERTED_DATE DATE;
				
		ENTRIES_TO_REVERSE T_OUT_CURSOR;
		INSERTED_ENTRIES T_NUMBER_ARRAY := T_NUMBER_ARRAY();
		
		TYPE T_ENTRIES_TO_REVERSE_RECORD IS RECORD (ENTRY_ID NUMBER, TRANSACTION_TYPE INTEGER, STATUS NUMBER, CREATED DATE, ACCOUNTING_DATE DATE, AMOUNT NUMBER, EXPECTATION_ID NUMBER, EXPECTATION_STATEMENT_ID NUMBER, REMINDER_ID NUMBER);
		TYPE T_ENTRIES_TO_REVERSE_RECORDS IS TABLE OF T_ENTRIES_TO_REVERSE_RECORD INDEX BY BINARY_INTEGER;
		ENTRIES_TO_REVERSE$ T_ENTRIES_TO_REVERSE_RECORDS;
		
		REMINDER_STATUS NUMBER;
		ACCOUNT_DATA "Accounts"%ROWTYPE;
		DEBIT_INVOICE_STATEMENT "Statements"%ROWTYPE;
		STATEMENT_CREATED_DATE DATE := NULL;
		LAST_ACCOUNTED_INTEREST_DATE DATE := NULL;

		DATE_FROM DATE;
		--LAST_INTEREST_DATE DATE := SYSTEMTIME; ??
		--CALCULATE_INTEREST_FROM DATE;

		INTEREST_ACCOUNTING_DAYS SYS_REFCURSOR;
	BEGIN

		-- get account 
		BEGIN
			SELECT * INTO ACCOUNT_DATA FROM "Accounts" 
			WHERE "Id" = ACCOUNT_ID;
			
			EXCEPTION WHEN NO_DATA_FOUND THEN 
				CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('AccountDoesntExist', NULL);
		END;

		-- check, that at least one entry should be inserted
		IF INSERTED_ENTRIES_LIST.COUNT = 0 THEN 
			RETURN;
		END IF;

		-- get latest date
		SELECT TRUNC(VALIDATION_DATE) INTO FIRST_INSERTED_DATE 
		FROM (SELECT VALIDATION_DATE FROM TABLE(INSERTED_ENTRIES_LIST) ORDER BY VALIDATION_DATE)
		WHERE rowNum = 1;

		-- handle credit note 
		IF (INSERTED_ENTRIES_LIST.COUNT = 1 AND INSERTED_ENTRIES_LIST(1).TRANSACTION_TYPE = APPLICATIONVALUES.TT_OUTCOMECANCELLATION) THEN
			
			SELECT *
			INTO DEBIT_INVOICE_STATEMENT
			FROM "Statements" 
			WHERE 
				"Account_Id" = ACCOUNT_ID
				AND TRUNC("AccountingPeriodEndDate") = TRUNC(INSERTED_ENTRIES_LIST(1).VALIDATION_DATE);

			IF (DEBIT_INVOICE_STATEMENT."Created" IS NOT NULL) THEN 
				STATEMENT_CREATED_DATE := DEBIT_INVOICE_STATEMENT."Created";
			END IF;

		END  IF;

		-- check FIRST_INSERTED_DATE
		IF (FIRST_INSERTED_DATE < TRUNC(ACCOUNT_DATA."TimeValidity_ValidFrom")) THEN
			CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('ValidDateOutOfAccValidity', NULL);
		END IF;

		-- get lastest date
		SELECT TRUNC(VALIDATION_DATE) INTO LAST_INSERTED_DATE 
		FROM (SELECT VALIDATION_DATE FROM TABLE(INSERTED_ENTRIES_LIST) ORDER BY VALIDATION_DATE DESC)
		WHERE RowNum = 1;

		IF (ACCOUNT_DATA."TimeValidity_ValidTo" IS NOT NULL AND LAST_INSERTED_DATE > TRUNC(ACCOUNT_DATA."TimeValidity_ValidTo")) THEN
			 CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('ValidDateOutOfAccValidity', NULL);
		END IF;

		IF (LAST_INSERTED_DATE > SYSTEMTIME) THEN
			CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('FutureValidationDate', NULL);
		END IF;

		IF (ACCOUNT_DATA."Status" = APPLICATIONVALUES.AS_CLOSED) THEN
			CUSTOM_ORACLE_EXCEPTIONS."RaiseException"('AccountHasBeenClosedAlready', NULL);
		END IF;

		-- get entries for reverse
		SELECT  AE."Id",
						AE."TransactionType",
						AE."Status",
						AE."Created",
						AE."AccountingDate",
						AE."Amount",
						AE."Expectation_Id",
						E."Statement_Id",
						R."Id"
		BULK COLLECT INTO ENTRIES_TO_REVERSE$
		FROM "AccountEntries" AE
		LEFT JOIN "Expectations" E ON AE."Expectation_Id" = E."Id" 
		LEFT JOIN "Reminders" R ON AE."Expectation_Id" = R."FeeExpectation_Id"
		WHERE
			AE."Account_Id" = ACCOUNT_ID
			AND "AccountingDate" > FIRST_INSERTED_DATE
		ORDER BY AE."Id";

		-- insert entries
		FOR I IN INSERTED_ENTRIES_LIST.FIRST .. INSERTED_ENTRIES_LIST.LAST
		LOOP 
			
			INSERTED_ENTRIES.EXTEND;

			INSERT INTO "AccountEntries" ("TransactionType", "ValidFrom", "ValidTo", "AccountingDate", "ValidationDate", "Amount", "Visibility", 
				"Status", "Account_Id", "Statement_Id", "LastChange_Changed", "LastChange_ChangedBy")
			VALUES (INSERTED_ENTRIES_LIST(I).TRANSACTION_TYPE, TRUNC(SYSTEMTIME), TRUNC(SYSTEMTIME), TRUNC(SYSTEMTIME), INSERTED_ENTRIES_LIST(I).VALIDATION_DATE, INSERTED_ENTRIES_LIST(I).AMOUNT, APPLICATIONVALUES.AEV_VISIBLE,
				APPLICATIONVALUES.AES_CREATED , ACCOUNT_ID, NULL, SYSTEMTIME, CURRENTUSER) RETURNING "Id" INTO INSERTED_ENTRIES(INSERTED_ENTRIES.LAST);

			"CreateHistoryChangeEntry"('AccountEntries', 'Amount', INSERTED_ENTRIES(INSERTED_ENTRIES.LAST), INSERTED_ENTRIES_LIST(I).AMOUNT, NULL, NULL, CURRENTUSER, INSERTED_ENTRIES_LIST(I).VALIDATION_DATE, 0, 'InsertEntry', 13);
						
		END LOOP;  

		-- get date from
		IF STATEMENT_CREATED_DATE IS NOT NULL THEN DATE_FROM := STATEMENT_CREATED_DATE;
		ELSE DATE_FROM := FIRST_INSERTED_DATE;
		END IF;

		-- get interest accounting dates
		INTEREST_ACCOUNTING_DAYS := "GetInterestAccountingDates"(ACCOUNT_ID, DATE_FROM, SYSTEMTIME);

		-- handle statuses statements    
		"HandleUnpaidStatements"(ACCOUNT_ID, DATE_FROM);  

		-- reverse interests
		LAST_ACCOUNTED_INTEREST_DATE := "ReverseAccountInterests"(ACCOUNT_ID, DATE_FROM);
		
		-- delete not accounted interests
		DELETE FROM "Interests" 
		WHERE "InterestEntry_Id" IS NULL 
			AND "InterestDate" >= FIRST_INSERTED_DATE 
			AND "Account_Id" = ACCOUNT_ID;

		-- set rigth date for compensation
		IF TRUNC(FIRST_INSERTED_DATE) < TRUNC(LAST_ACCOUNTED_INTEREST_DATE) THEN
			LAST_ACCOUNTED_INTEREST_DATE := FIRST_INSERTED_DATE;
		END IF; 

		-- calculate compensation
		"CreateInterestCompensation"(ACCOUNT_DATA, LAST_ACCOUNTED_INTEREST_DATE, INTEREST_ACCOUNTING_DAYS);

		-- count interests with new values
		"CreateDailyInterestComp"(ACCOUNT_ID, FIRST_INSERTED_DATE);

		-- return inserted entries list
		OPEN RESULT_CURSOR FOR
			SELECT COLUMN_VALUE AS "Id" FROM TABLE (INSERTED_ENTRIES);

	END;

/*******************************************************************************/
FUNCTION "CalculateAccountDayInterests"(ACCOUNT_ID IN NUMBER, DATE_FROM IN DATE, DATE_TO IN DATE, PREVIOUS_BALANCE IN NUMBER, ACCOUNT_ENTRY_COLUMN IN STRING) RETURN INTEREST_CALC_TABLE PIPELINED AS
	
	-- "Interest" collection
	TYPE T_ENTRY IS RECORD (InterestDate DATE, Balance NUMBER(20,2), InterestRate NUMBER(20, 2), YearLength INTEGER);
	TYPE T_ENTRIES IS TABLE OF T_ENTRY INDEX BY BINARY_INTEGER;
	ENTRY_COLLECTION$ T_ENTRIES;
	
	INTEREST_COLLECTION$ INTEREST_CALC_TABLE;
	
BEGIN

	-- check allowed colum names
	IF (ACCOUNT_ENTRY_COLUMN != AE_COLUMN_ACCOUNTING_DATE) AND (ACCOUNT_ENTRY_COLUMN != AE_COLUMN_VALIDATION_DATE) THEN
		RETURN;
	END IF;
	

	--LAST_INTEREST_DATE := DATE_FROM+1;
	SELECT INTEREST_CALC_TYPE
	(
		MAXIMUM_DAY_BALANCE,
		(MAXIMUM_DAY_BALANCE*INTEREST)/(100*YEAR_LENGTH),
		INTEREST,
		VALIDATION_DATE
	)
		BULK COLLECT INTO INTEREST_COLLECTION$
		FROM
		(
		SELECT
			CASE
				WHEN T."MaximumInterestBasedAmount" < ACCOUNTING_VALUES.DAY_BALANCE THEN T."MaximumInterestBasedAmount"
				ELSE ACCOUNTING_VALUES.DAY_BALANCE
			END MAXIMUM_DAY_BALANCE,
			TO_NUMBER((TRUNC(ACCOUNTING_VALUES.ACCOUNTING_DATE,'yyyy')+ interval '1' year-1) - (TRUNC(ACCOUNTING_VALUES.ACCOUNTING_DATE,'yyyy')))+1 YEAR_LENGTH,
			CASE
				WHEN ACCOUNTING_VALUES.DAY_BALANCE IS NULL THEN NULL
				WHEN ACCOUNTING_VALUES.DAY_BALANCE = 0 THEN 0
				WHEN ACCOUNTING_VALUES.DAY_BALANCE > 0 THEN T."PositiveInterestRate"+BI."Value"
				ELSE T."NegativeInterestRate"+BI."Value"
			END INTEREST,
			ACCOUNTING_VALUES.ACCOUNTING_DATE VALIDATION_DATE
			
		FROM
			-- accounting days
			(
			SELECT
		
			--day_amount,
			SUM(DAY_AMOUNT) OVER (ORDER BY ACCOUNTING_DATE RANGE UNBOUNDED PRECEDING) DAY_BALANCE,
			DAYS.*
	
	FROM
	(	
				SELECT
					ACCOUNT_DAYS.ACCOUNT_ID,
					ACCOUNT_DAYS.DAY ACCOUNTING_DATE,
					CASE WHEN TRUNC(DAY) = TRUNC(DATE_FROM) THEN NVL(SUM("Amount"), 0) + PREVIOUS_BALANCE
					ELSE NVL(SUM("Amount"), 0) 
					END DAY_AMOUNT
				FROM			
					(

						SELECT ACCOUNT_ID ACCOUNT_ID,	COLUMN_VALUE DAY
						FROM TABLE(CUSTOMERACCOUNT."GenerateDays"(TRUNC(DATE_FROM), TRUNC(DATE_TO)))
						
					) ACCOUNT_DAYS  -- days to generate parameter
					LEFT JOIN "AccountEntryView" AE    -- accounting entries
							ON ACCOUNT_DAYS.ACCOUNT_ID = AE."Account_Id" AND ACCOUNT_DAYS.DAY = 
							CASE 
								WHEN ACCOUNT_ENTRY_COLUMN = AE_COLUMN_VALIDATION_DATE THEN AE."ValidationDate" 
								WHEN ACCOUNT_ENTRY_COLUMN = AE_COLUMN_ACCOUNTING_DATE THEN AE."AccountingDate" 
							END + 
								CASE -- other than income amount must be effectively postponed by one day
									WHEN AE."TransactionType" = APPLICATIONVALUES.TT_INCOME THEN 0
									WHEN AE."TransactionType" = APPLICATIONVALUES.TT_MANUALCORRECTION THEN 0
									WHEN AE."TransactionType" = APPLICATIONVALUES.TT_REVERSEDPAYMENT THEN 0
--									WHEN AE."TransactionType" IN (SELECT COLUMN_VALUE FROM TABLE(INTEREST_INCOME_TRANS_TYPES)) THEN 0						
									ELSE 1
								END 
					GROUP BY ACCOUNT_DAYS.ACCOUNT_ID, DAY
					ORDER BY DAY
	) DAYS
	ORDER BY ACCOUNTING_DATE
			
				
			) ACCOUNTING_VALUES,
			
			-- other tables
			"BaseInterests" BI,
			"AccountTemplates" AT,
			"Templates" T
		WHERE
			-- link base interests
			ACCOUNTING_VALUES.ACCOUNTING_DATE >= BI."TimeValidity_ValidFrom" AND (ACCOUNTING_VALUES.ACCOUNTING_DATE <= BI."TimeValidity_ValidTo" OR BI."TimeValidity_ValidTo" IS NULL)
			-- link account templates
			AND ACCOUNTING_VALUES.ACCOUNT_ID = AT."Account_Id"
			AND ACCOUNTING_VALUES.ACCOUNTING_DATE >= AT."TimeValidity_ValidFrom" AND (ACCOUNTING_VALUES.ACCOUNTING_DATE <= AT."TimeValidity_ValidTo" OR AT."TimeValidity_ValidTo" IS NULL)
			-- link templates
			AND AT."Template_Id" = T."Id"  
			AND ACCOUNTING_VALUES.DAY_BALANCE <> 0
		ORDER BY
			ACCOUNTING_VALUES.ACCOUNT_ID,
			ACCOUNTING_VALUES.ACCOUNTING_DATE
		);
		
		IF INTEREST_COLLECTION$ IS NOT NULL AND INTEREST_COLLECTION$.COUNT > 0 THEN
			
			-- insert into tables
			FOR I IN 1..INTEREST_COLLECTION$.COUNT
			LOOP
				PIPE ROW (INTEREST_CALC_TYPE(
					INTEREST_COLLECTION$(I).Balance, 
					INTEREST_COLLECTION$(I).Amount, 
					INTEREST_COLLECTION$(I).Rate, 
					INTEREST_COLLECTION$(I).Day
				));
			END LOOP;
			
		END IF;
END;

/*******************************************************************************/
	FUNCTION "GenerateDays"(DATE_FROM IN DATE, DATE_TO IN DATE) RETURN T_DATE_ARRAY /*PIPELINED*/ AS
		DATE_COLLECTION$ T_DATE_ARRAY;
	BEGIN
	
		SELECT DAY
		BULK COLLECT INTO DATE_COLLECTION$
		FROM
		(
			SELECT TRUNC(DATE_FROM + COUNTER) DAY
			FROM (SELECT (LEVEL-1) COUNTER FROM DUAL CONNECT BY LEVEL <= (TRUNC(DATE_TO) - TRUNC(DATE_FROM)))
		)
		WHERE DAY < TRUNC(DATE_TO);
		
		IF (DATE_COLLECTION$ IS NOT NULL AND DATE_COLLECTION$.COUNT > 0) THEN RETURN DATE_COLLECTION$;
		ELSE RETURN T_DATE_ARRAY();
		END IF;

	END;

/*******************************************************************************/
END CUSTOMERACCOUNT;
/

CREATE OR REPLACE PACKAGE MV_PANELMANAGEMENT
AS
	PROCEDURE CLEAN_JOBS;
	PROCEDURE REFRESH_SOURCES;
	PROCEDURE REFRESH_REPORT;
END;
/

CREATE OR REPLACE PACKAGE BODY MV_PANELMANAGEMENT
AS
	statistics_view_count CONSTANT INTEGER := 11;
	longop_name_gather_statistics CONSTANT CHAR(17) := 'Gather statistics';
	longop_name_create_constraints CONSTANT CHAR(20) := 'Creating constraints';
	
	rindex PLS_INTEGER;
    slno PLS_INTEGER;
	
	PROCEDURE CLEAN_JOBS
	IS
	BEGIN
		FOR job IN (SELECT job, what FROM DBA_JOBS WHERE WHAT LIKE 'BEGIN DBMS_MVIEW.REFRESH%') LOOP
			DBMS_JOB.REMOVE(job => job.job);
			DBMS_OUTPUT.PUT_LINE('Job ''' || job.what || ''' removed. ');
		END LOOP;
		
		COMMIT;
	END;

	PROCEDURE DROP_CONSTRAINTS
	IS
	BEGIN
		FOR constraints IN (SELECT CONSTRAINT_NAME, TABLE_NAME FROM ALL_CONSTRAINTS WHERE CONSTRAINT_TYPE IN ('P', 'R') AND OWNER = 'PANELMANAGEMENT' ORDER BY CONSTRAINT_TYPE DESC) LOOP
			DBMS_OUTPUT.PUT('Constraint PANELMANAGEMENT.' || constraints.TABLE_NAME || '.' || constraints.CONSTRAINT_NAME || '... ');
				EXECUTE IMMEDIATE 'ALTER TABLE PANELMANAGEMENT."' || constraints.TABLE_NAME || '" DROP CONSTRAINT "' || constraints.CONSTRAINT_NAME || '"';
			DBMS_OUTPUT.PUT_LINE('dropped. ');
		END LOOP;
	END;
	
	PROCEDURE REFRESH_SOURCES
	IS
		job_id BINARY_INTEGER;
		job_statement_base CONSTANT VARCHAR2(4000) := q'|BEGIN DBMS_MVIEW.REFRESH('"PANELMANAGEMENT"."{0}"', method => 'C', atomic_refresh => FALSE); END;|';
		job_statement VARCHAR2(4000);
	BEGIN
		DBMS_OUTPUT.ENABLE(buffer_size => null);
		DROP_CONSTRAINTS;
		
		FOR materialized_view in (SELECT NAME FROM ALL_SNAPSHOTS WHERE OWNER = 'PANELMANAGEMENT' AND MASTER_OWNER = 'Oracle') LOOP
			job_statement := REPLACE(job_statement_base, '{0}', materialized_view.NAME);
			DBMS_JOB.SUBMIT(job => job_id, what => job_statement);
			
			DBMS_OUTPUT.PUT_LINE('Job ID ' || job_id || ': ' || job_statement);
		END LOOP;
	END;
	
	PROCEDURE UPDATE_GATHER_STATISTICS_INFO(sofar IN OUT INTEGER)
	IS
	BEGIN
		dbms_application_info.set_session_longops(rindex, slno, op_name => longop_name_gather_statistics, target => 0, sofar => sofar, totalwork => statistics_view_count, target_desc => CHR(8) || CHR(8), units => 'materialized views');
		sofar := sofar + 1;
	END;
	
	PROCEDURE REFRESH_REPORT
	IS
		count INTEGER;
		counter INTEGER := 0;
		sort_hash_area_memory_size INTEGER := 536870912;
		respondent_report_object_id INTEGER;
		constraintCommands SYS.ODCIVARCHAR2LIST :=
			SYS.ODCIVARCHAR2LIST(
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.EXTERNALALLOCATION ADD CONSTRAINT PK_EXTERNALALLOCATION PRIMARY KEY (EXTERNALALLOCATION_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.CIRCULAR ADD CONSTRAINT PK_CIRCULAR PRIMARY KEY (CIRCULAR_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.SELECTION ADD CONSTRAINT PK_SELECTION PRIMARY KEY (SELECTION_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RESPONDENTBUCKET ADD CONSTRAINT PK_RESPONDENTBUCKET PRIMARY KEY (RESPONDENTBUCKET_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RESPONDENTQUOTA ADD CONSTRAINT PK_RESPONDENTQUOTA PRIMARY KEY (RESPONDENTQUOTA_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.TARGETGROUPRESPONDENTQUOTA ADD CONSTRAINT PK_TARGETGROUPRESPONDENTQUOTA PRIMARY KEY (TARGETGROUP_ID, RESPONDENTQUOTA_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RESPONDENTQUOTABUCKETMATCH ADD CONSTRAINT PK_RESPONDENTQUOTABUCKETMATCH PRIMARY KEY (RESPONDENTQUOTA_ID, RESPONDENTBUCKET_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.TARGETGROUP ADD CONSTRAINT PK_TARGETGROUP PRIMARY KEY (TARGETGROUP_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.PROJECT ADD CONSTRAINT PK_PROJECT PRIMARY KEY (PROJECT_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.PROJECTMETADATA ADD CONSTRAINT PK_PROJECTMETADATA PRIMARY KEY (PROJECTMETADATA_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.PROJECTAGREEDCPI ADD CONSTRAINT PK_PROJECTAGREEDCPI PRIMARY KEY (PROJECTAGREEDCPI_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.CURRENCY ADD CONSTRAINT PK_CURRENCY PRIMARY KEY (CURRENCY_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.PANEL ADD CONSTRAINT PK_PANEL PRIMARY KEY (PANEL_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.COUNTRY ADD CONSTRAINT PK_COUNTRY PRIMARY KEY (COUNTRY_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT."USER" ADD CONSTRAINT PK_USER PRIMARY KEY (USER_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.COMPANY ADD CONSTRAINT PK_COMPANY PRIMARY KEY (COMPANY_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RATECARD ADD CONSTRAINT PK_RATECARD PRIMARY KEY (RATECARD_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.TARGETGROUPPRICE ADD CONSTRAINT PK_TARGETGROUPPRICE PRIMARY KEY (TARGETGROUPPRICE_ID) NOLOGGING',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.EXTERNALALLOCATION ADD CONSTRAINT FK_EXT_ALLOC_PANEL_ID FOREIGN KEY (PANEL_ID) REFERENCES PANELMANAGEMENT.PANEL (PANEL_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.EXTERNALALLOCATION ADD CONSTRAINT FK_EXT_ALLOC_PROJECT_ID FOREIGN KEY (PROJECT_ID) REFERENCES PANELMANAGEMENT.PROJECT (PROJECT_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.EXTERNALALLOCATION ADD CONSTRAINT FK_EXT_ALLOC_TARGETGROUP_ID FOREIGN KEY (TARGETGROUP_ID) REFERENCES PANELMANAGEMENT.TARGETGROUP (TARGETGROUP_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RATECARD ADD CONSTRAINT FK_RATECARD_COUNTRY_ID FOREIGN KEY (COUNTRY_ID) REFERENCES PANELMANAGEMENT.COUNTRY (COUNTRY_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RATECARD ADD CONSTRAINT FK_RATECARD_CURRENCY_ID FOREIGN KEY (CURRENCY_ID) REFERENCES PANELMANAGEMENT.CURRENCY (CURRENCY_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RATECARD ADD CONSTRAINT FK_RATECARD_COMPANY_ID FOREIGN KEY (COMPANY_ID) REFERENCES PANELMANAGEMENT.COMPANY (COMPANY_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RATECARD ADD CONSTRAINT FK_RATECARD_PANEL_ID FOREIGN KEY (PANEL_ID) REFERENCES PANELMANAGEMENT.PANEL (PANEL_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RATECARD ADD CONSTRAINT FK_RATECARD_CREATEDBYUSER_ID FOREIGN KEY (CREATEDBYUSER_ID) REFERENCES PANELMANAGEMENT."USER" (USER_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT."USER" ADD CONSTRAINT FK_USER_COMPANY_ID FOREIGN KEY (COMPANY_ID) REFERENCES PANELMANAGEMENT.COMPANY (COMPANY_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.SAMPLINGQUEUE ADD CONSTRAINT FK_SAMPLINGQUEUE_SELECTION_ID FOREIGN KEY (SELECTION_ID) REFERENCES PANELMANAGEMENT.SELECTION (SELECTION_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.SAMPLINGQUEUE ADD CONSTRAINT FK_SAMPLINGQUEUE_BUCKET_ID FOREIGN KEY (RESPONDENTBUCKET_ID) REFERENCES PANELMANAGEMENT.RESPONDENTBUCKET (RESPONDENTBUCKET_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.SAMPLINGQUEUE ADD CONSTRAINT FK_SAMPLINGQUEUE_CREATEDBY FOREIGN KEY (CREATEDBY) REFERENCES PANELMANAGEMENT."USER" (USER_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.SELECTION ADD CONSTRAINT FK_SELECTION_BUCKET_ID FOREIGN KEY (RESPONDENTBUCKET_ID) REFERENCES PANELMANAGEMENT.RESPONDENTBUCKET (RESPONDENTBUCKET_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.SELECTION ADD CONSTRAINT FK_SELECTION_PROJECT_ID FOREIGN KEY (PROJECT_ID) REFERENCES PANELMANAGEMENT.PROJECT (PROJECT_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.SELECTION ADD CONSTRAINT FK_SELECTION_CREATOR_ID FOREIGN KEY (CREATOR_ID) REFERENCES PANELMANAGEMENT."USER" (USER_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.TARGETGROUP ADD CONSTRAINT FK_TARGETGROUP_PROJECT_ID FOREIGN KEY (PROJECT_ID) REFERENCES PANELMANAGEMENT.PROJECT (PROJECT_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.TARGETGROUP ADD CONSTRAINT FK_TARGETGROUP_TGPRICE_ID FOREIGN KEY (TARGETGROUPPRICE_ID) REFERENCES PANELMANAGEMENT.TARGETGROUPPRICE (TARGETGROUPPRICE_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.TARGETGROUPPRICE ADD CONSTRAINT FK_TGPRICE_RATECARD_ID FOREIGN KEY (RATECARD_ID) REFERENCES PANELMANAGEMENT.RATECARD (RATECARD_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.APMPROJECTDETAILS ADD CONSTRAINT FK_APMPROJECTDETAILS_PROJECT FOREIGN KEY (PROJECT) REFERENCES PANELMANAGEMENT.PROJECT (PROJECT_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.PROJECT ADD CONSTRAINT FK_PROJECT_USER_ID FOREIGN KEY (USER_ID) REFERENCES PANELMANAGEMENT."USER" (USER_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.PROJECTMETADATA ADD CONSTRAINT FK_PROJECTMETADATA_PROJECT_ID FOREIGN KEY (PROJECT_ID) REFERENCES PANELMANAGEMENT.PROJECT (PROJECT_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.PROJECTAGREEDCPI ADD CONSTRAINT FK_PROJECTAGREEDCPI_PROJECT_ID FOREIGN KEY (PROJECT_ID) REFERENCES PANELMANAGEMENT.PROJECT (PROJECT_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.PROJECTAGREEDCPI ADD CONSTRAINT FK_PROJECTCPI_CURRENCY_ID FOREIGN KEY (CURRENCY_ID) REFERENCES PANELMANAGEMENT.CURRENCY (CURRENCY_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.TARGETGROUPRESPONDENTQUOTA ADD CONSTRAINT FK_TGRQ_RESPONDENTQUOTA_ID FOREIGN KEY (RESPONDENTQUOTA_ID) REFERENCES PANELMANAGEMENT.RESPONDENTQUOTA (RESPONDENTQUOTA_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.TARGETGROUPRESPONDENTQUOTA ADD CONSTRAINT FK_TGRQ_TARGETGROUP_ID FOREIGN KEY (TARGETGROUP_ID) REFERENCES PANELMANAGEMENT.TARGETGROUP (TARGETGROUP_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RESPONDENTQUOTABUCKETMATCH ADD CONSTRAINT FK_RQRBM_RESPONDENTQUOTA_ID FOREIGN KEY (RESPONDENTQUOTA_ID) REFERENCES PANELMANAGEMENT.RESPONDENTQUOTA (RESPONDENTQUOTA_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RESPONDENTQUOTABUCKETMATCH ADD CONSTRAINT FK_RQRBM_RESPONDENTBUCKET_ID FOREIGN KEY (RESPONDENTBUCKET_ID) REFERENCES PANELMANAGEMENT.RESPONDENTBUCKET (RESPONDENTBUCKET_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.RESPONDENTBUCKET ADD CONSTRAINT FK_BUCKET_TARGETGROUP_ID FOREIGN KEY (TARGETGROUP_ID) REFERENCES PANELMANAGEMENT.TARGETGROUP (TARGETGROUP_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.CIRCULAR ADD CONSTRAINT FK_CIRCULAR_SELECTION_ID FOREIGN KEY (SELECTION_ID) REFERENCES PANELMANAGEMENT.SELECTION (SELECTION_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.ALARMLIMITS ADD CONSTRAINT PK_ALARMLIMITS PRIMARY KEY (ALARMLIMITS_ID) ADD CONSTRAINT FK_ALARMLIMITS_TARGETGROUP FOREIGN KEY (TARGETGROUP_ID) REFERENCES PANELMANAGEMENT.TARGETGROUP (TARGETGROUP_ID)',
				'ALTER MATERIALIZED VIEW PANELMANAGEMENT.ALARMEVENT ADD CONSTRAINT PK_ALARMEVENT PRIMARY KEY (ALARMEVENT_ID) ADD CONSTRAINT FK_ALARMEVENT_ALARMLIMITS FOREIGN KEY (ALARMLIMITS_ID) REFERENCES PANELMANAGEMENT.ALARMLIMITS (ALARMLIMITS_ID)'
			);
	BEGIN
		DROP_CONSTRAINTS;

		rindex := dbms_application_info.set_session_longops_nohint;
		slno := NULL;

		FOR i IN 1..constraintCommands.COUNT LOOP
			dbms_application_info.set_session_longops(rindex, slno, op_name => longop_name_create_constraints, target => NULL, sofar => i - 1, totalwork => constraintCommands.COUNT, target_desc => CHR(8) || CHR(8), units => 'constraints');
			EXECUTE IMMEDIATE constraintCommands(i);
			DBMS_OUTPUT.PUT_LINE(constraintCommands(i) || ' executed successfully. ');
		END LOOP;

		dbms_application_info.set_session_longops(rindex, slno, op_name => longop_name_create_constraints, target => NULL, sofar => constraintCommands.COUNT, totalwork => constraintCommands.COUNT, target_desc => NULL, units => 'constraints');
		
		SELECT OBJECT_ID INTO respondent_report_object_id FROM ALL_OBJECTS WHERE OBJECT_NAME = 'RESPONDENT_REPORT' AND OWNER = 'PANELMANAGEMENT' AND OBJECT_TYPE = 'MATERIALIZED VIEW';

		-- hash area must be manually increased to avoid huge temp space requirement; it's not efficient when done within procedure
		--EXECUTE IMMEDIATE 'ALTER SESSION SET WORKAREA_SIZE_POLICY=MANUAL SORT_AREA_SIZE=' || sort_hash_area_memory_size || ' HASH_AREA_SIZE=' || sort_hash_area_memory_size;
		
		dbms_application_info.set_session_longops(rindex, slno, op_name => 'Refreshing materialized view report', target => respondent_report_object_id, sofar => 0, totalwork => 1, target_desc => 'RESPONDENT_REPORT', units => CHR(8));
		DBMS_MVIEW.REFRESH('PANELMANAGEMENT.RESPONDENT_REPORT', method => 'C', atomic_refresh => FALSE);
		dbms_application_info.set_session_longops(rindex, slno, op_name => 'Refreshing materialized view report', target => respondent_report_object_id, sofar => 1, totalwork => 1, target_desc => 'RESPONDENT_REPORT', units => CHR(8));
		
		DBMS_OUTPUT.PUT_LINE('RESPONDENT_REPORT view refreshed successfully. ');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM RESPONDENT_REPORT WHERE STATUS = 29 AND PANELIST_STATUS = 0 AND COUNTRY_ID = 1 AND PANEL_ID = 3524 AND SUPPLYCHANNEL = 1 AND NOMAILOUTS = 0 AND USER_COMPANY_ID = 1 AND RESPONSERATE = 200 AND LANGUAGE_ID = 1 AND APMSTATUS = 2 AND INITIAL_ISSENT = 1 AND PROJECT_CHANNEL = 0;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'RESPONDENT_REPORT', /*estimate_percent => 100,*/ method_opt => 'FOR COLUMNS SIZE AUTO STATUS, SUPPLYCHANNEL, PANEL_ID, PANELIST_STATUS, NOMAILOUTS, COUNTRY_ID, USER_COMPANY_ID, RESPONSERATE, LANGUAGE_ID, APMSTATUS, INITIAL_ISSENT, PROJECT_CHANNEL');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM CIRCULAR WHERE ISSENT = 1 AND CIRCULARTYPE = 1 AND BUFFERLIMIT = 24000;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'CIRCULAR', method_opt => 'FOR COLUMNS SIZE AUTO ISSENT, CIRCULARTYPE, BUFFERLIMIT');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM RESPONDENTSTATUSCHANGE WHERE OLDSTATUS = 1 AND NEWSTATUS = 5;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'RESPONDENTSTATUSCHANGE', method_opt => 'FOR COLUMNS SIZE AUTO OLDSTATUS, NEWSTATUS');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM PANELIST WHERE PANEL_ID = 3378 AND NOSURVEYS = 0 AND NOANSWERS = 0 AND STATUS = 0 AND SEX = 1 AND POSTALCODE = '430000' AND YEAROFBIRTH = 1992 AND RANKING = 0 AND DAYSBETWEENMAILOUTS = 0 AND NOBOUNCES = 0 AND POINTSEARNED = 0 AND NODENIALS = 0;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'PANELIST', method_opt => 'FOR COLUMNS SIZE AUTO PANEL_ID, NOSURVEYS, NOANSWERS, STATUS, SEX, POSTALCODE, YEAROFBIRTH, RANKING, DAYSBETWEENMAILOUTS, NOBOUNCES, POINTSEARNED, NODENIALS');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM SELECTION WHERE STATUS = 0 AND SUPPLYCHANNEL = 0 AND CREATED BETWEEN DATE'2014-12-01' AND DATE'2014-12-08';
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'SELECTION', method_opt => 'FOR COLUMNS SIZE AUTO STATUS, SUPPLYCHANNEL, CREATED');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM PANEL WHERE COUNTRY_ID = 1 AND DEFAULTSTATUS = 0;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'PANEL', method_opt => 'FOR COLUMNS SIZE AUTO COUNTRY_ID, DEFAULTSTATUS');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM PROJECT WHERE STATUS = 1 AND USEPROJECTTOKEN = 0 AND TYPE = 0 AND CHANNEL = 0 AND INVOICINGSTATUS = 100 AND WEEKENDCOVERAGEREQUIRED = 0 AND BLOCKEDDEVICETYPES = 0 AND REQUIREDCAPABILITIES = 0 AND CHECKGEOIP = 0;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'PROJECT', method_opt => 'FOR COLUMNS SIZE AUTO STATUS, USEPROJECTTOKEN, TYPE, CHANNEL, INVOICINGSTATUS, WEEKENDCOVERAGEREQUIRED, BLOCKEDDEVICETYPES, REQUIREDCAPABILITIES, CHECKGEOIP');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM RESPONDENTDEVICEINFORMATION WHERE IPADDRESS = 1553704242 AND TWOLETTERCOUNTRYCODE = 'US' AND DEVICETYPE = 2 AND CAPABILITIES = 2;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'RESPONDENTDEVICEINFORMATION', method_opt => 'FOR COLUMNS SIZE AUTO TWOLETTERCOUNTRYCODE, DEVICETYPE, CAPABILITIES');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM PROJECTEVENTLOG WHERE EVENTTYPE = 1 AND USER_ID = 6885;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'PROJECTEVENTLOG', method_opt => 'FOR COLUMNS SIZE AUTO EVENTTYPE, USER_ID');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM ORDERS WHERE USER_ID = 4943 AND STATUS = 1 AND TOTALCOST > 10000 AND TYPEOFORDER = 1 AND COMPANY_ID = 2578;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'ORDERS', method_opt => 'FOR COLUMNS SIZE AUTO USER_ID, STATUS, TOTALCOST, TYPEOFORDER, COMPANY_ID');

		UPDATE_GATHER_STATISTICS_INFO(counter);
		SELECT COUNT(*) INTO count FROM TARGETGROUP WHERE STATUS = 1 AND ISAPPROVEDFORSENDOUT = 1 AND COUNTRY_ID = 22 AND QUOTATYPE = 0;
		DBMS_STATS.GATHER_TABLE_STATS('PANELMANAGEMENT', 'TARGETGROUP', method_opt => 'FOR COLUMNS SIZE AUTO STATUS, ISAPPROVEDFORSENDOUT, COUNTRY_ID, QUOTATYPE');

		dbms_application_info.set_session_longops(rindex, slno, op_name => longop_name_gather_statistics, target => 0, sofar => statistics_view_count, totalwork => statistics_view_count, target_desc => NULL, units => 'materialized views');
		DBMS_OUTPUT.PUT_LINE('Statistics gathered successfully. ');
	END;
END;
/
