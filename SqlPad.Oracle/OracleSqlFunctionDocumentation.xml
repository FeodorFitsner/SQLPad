<?xml version="1.0" encoding="utf-8"?>
<Documentation xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://husqvik.com/SqlPad/2014/02">
  <Function Name="ABS" Url="http://docs.oracle.com/database/121/SQLRF/functions009.htm">ABS returns the absolute value of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="ACOS" Url="http://docs.oracle.com/database/121/SQLRF/functions010.htm">ACOS returns the arc cosine of n. The argument n must be in the range of -1 to 1, and the function returns a value in the range of 0 to pi, expressed in radians.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="ADD_MONTHS" Url="http://docs.oracle.com/database/121/SQLRF/functions011.htm">ADD_MONTHS returns the date date plus integer months. A month is defined by the session parameter NLS_CALENDAR. The date argument can be a datetime value or any value that can be implicitly converted to DATE. The integer argument can be an integer or any value that can be implicitly converted to an integer. The return type is always DATE, regardless of the data type of date. If date is the last day of the month or if the resulting month has fewer days than the day component of date, then the result is the last day of the resulting month. Otherwise, the result has the same day component as date.</Function>
  <Function Name="APPENDCHILDXML" Url="http://docs.oracle.com/database/121/SQLRF/functions012.htm">APPENDCHILDXML appends a user-supplied value onto the target XML as the child of the node indicated by an XPath expression.</Function>
  <Function Name="APPROX_COUNT_DISTINCT" Url="http://docs.oracle.com/database/121/SQLRF/functions013.htm">APPROX_COUNT_DISTINCT returns the approximate number of rows that contain distinct values of expr.
This function provides an alternative to the COUNT (DISTINCT expr) function, which returns the exact number of rows that contain distinct values of expr. APPROX_COUNT_DISTINCT processes large amounts of data significantly faster than COUNT, with negligible deviation from the exact result.
For expr, you can specify a column of any scalar data type other than BFILE, BLOB, CLOB, LONG, LONG RAW, or NCLOB.
APPROX_COUNT_DISTINCT ignores rows that contain a null value for expr. This function returns a NUMBER.</Function>
  <Function Name="ASCII" Url="http://docs.oracle.com/database/121/SQLRF/functions014.htm">ASCII returns the decimal representation in the database character set of the first character of char.
char can be of data type CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The value returned is of data type NUMBER. If your database character set is 7-bit ASCII, then this function returns an ASCII value. If your database character set is EBCDIC Code, then this function returns an EBCDIC value. There is no corresponding EBCDIC character function.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="ASCIISTR" Url="http://docs.oracle.com/database/121/SQLRF/functions015.htm">ASCIISTR takes as its argument a string, or an expression that resolves to a string, in any character set and returns an ASCII version of the string in the database character set. Non-ASCII characters are converted to the form \xxxx, where xxxx represents a UTF-16 code unit.</Function>
  <Function Name="ASIN" Url="http://docs.oracle.com/database/121/SQLRF/functions016.htm">ASIN returns the arc sine of n. The argument n must be in the range of -1 to 1, and the function returns a value in the range of -pi/2 to pi/2, expressed in radians.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="ATAN" Url="http://docs.oracle.com/database/121/SQLRF/functions017.htm">ATAN returns the arc tangent of n. The argument n can be in an unbounded range and returns a value in the range of -pi/2 to pi/2, expressed in radians.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="ATAN2" Url="http://docs.oracle.com/database/121/SQLRF/functions018.htm">ATAN2 returns the arc tangent of n1 and n2. The argument n1 can be in an unbounded range and returns a value in the range of -pi to pi, depending on the signs of n1 and n2, expressed in radians.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is BINARY_FLOAT or BINARY_DOUBLE, then the function returns BINARY_DOUBLE. Otherwise the function returns NUMBER.</Function>
  <Function Name="AVG" Url="http://docs.oracle.com/database/121/SQLRF/functions019.htm">AVG returns average value of expr.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="BFILENAME" Url="http://docs.oracle.com/database/121/SQLRF/functions020.htm">BFILENAME returns a BFILE locator that is associated with a physical LOB binary file on the server file system.</Function>
  <Function Name="BIN_TO_NUM" Url="http://docs.oracle.com/database/121/SQLRF/functions021.htm">BIN_TO_NUM converts a bit vector to its equivalent number. Each argument to this function represents a bit in the bit vector. This function takes as arguments any numeric data type, or any nonnumeric data type that can be implicitly converted to NUMBER. Each expr must evaluate to 0 or 1. This function returns Oracle NUMBER.
BIN_TO_NUM is useful in data warehousing applications for selecting groups of interest from a materialized view using grouping sets.</Function>
  <Function Name="BITAND" Url="http://docs.oracle.com/database/121/SQLRF/functions022.htm">The BITAND function treats its inputs and its output as vectors of bits; the output is the bitwise AND of the inputs.
The types of expr1 and expr2 are NUMBER, and the result is of type NUMBER. If either argument to BITAND is NULL, the result is NULL.
The arguments must be in the range -(2(n-1)) .. ((2(n-1))-1). If an argument is out of this range, the result is undefined.
The result is computed in several steps. First, each argument A is replaced with the value SIGN(A)*FLOOR(ABS(A)). This conversion has the effect of truncating each argument towards zero. Next, each argument A (which must now be an integer value) is converted to an n-bit two's complement binary integer value. The two bit values are combined using a bitwise AND operation. Finally, the resulting n-bit two's complement value is converted back to NUMBER.</Function>
  <Function Name="CARDINALITY" Url="http://docs.oracle.com/database/121/SQLRF/functions023.htm">CARDINALITY returns the number of elements in a nested table. The return type is NUMBER. If the nested table is empty, or is a null collection, then CARDINALITY returns NULL.</Function>
  <Function Name="CAST" Url="http://docs.oracle.com/database/121/SQLRF/functions024.htm">CAST converts one built-in data type or collection-typed value into another built-in data type or collection-typed value.
CAST lets you convert built-in data types or collection-typed values of one type into another built-in data type or collection type. You can cast an unnamed operand (such as a date or the result set of a subquery) or a named collection (such as a varray or a nested table) into a type-compatible data type or named collection. The type_name must be the name of a built-in data type or collection type and the operand must be a built-in data type or must evaluate to a collection value.
For the operand, expr can be either a built-in data type, a collection type, or an instance of an ANYDATA type. If expr is an instance of an ANYDATA type, then CAST tries to extract the value of the ANYDATA instance and return it if it matches the cast target type, otherwise, null will be returned. MULTISET informs Oracle Database to take the result set of the subquery and return a collection value. Table 7-1 shows which built-in data types can be cast into which other built-in data types. (CAST does not support LONG, LONG RAW, or the Oracle-supplied types.)
CAST does not directly support any of the LOB data types. When you use CAST to convert a CLOB value into a character data type or a BLOB value into the RAW data type, the database implicitly converts the LOB value to character or raw data and then explicitly casts the resulting value into the target data type. If the resulting value is larger than the target type, then the database returns an error.
When you use CAST ... MULTISET to get a collection value, each select list item in the query passed to the CAST function is converted to the corresponding attribute type of the target collection element type.</Function>
  <Function Name="CEIL" Url="http://docs.oracle.com/database/121/SQLRF/functions025.htm">CEIL returns the smallest integer that is greater than or equal to n. The number n can always be written as the difference of an integer k and a positive fraction f such that 0 &lt;= f &lt; 1 and n = k - f. The value of CEIL is the integer k. Thus, the value of CEIL is n itself if and only if n is precisely an integer.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="CHARTOROWID" Url="http://docs.oracle.com/database/121/SQLRF/functions026.htm">CHARTOROWID converts a value from CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to ROWID data type.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="CHR" Url="http://docs.oracle.com/database/121/SQLRF/functions027.htm">CHR returns the character having the binary equivalent to n as a VARCHAR2 value in either the database character set or, if you specify USING NCHAR_CS, the national character set.
For single-byte character sets, if n &gt; 256, then Oracle Database returns the binary equivalent of n mod 256. For multibyte character sets, n must resolve to one entire code point. Invalid code points are not validated, and the result of specifying invalid code points is indeterminate.
This function takes as an argument a NUMBER value, or any value that can be implicitly converted to NUMBER, and returns a character.</Function>
  <Function Name="CLUSTER_DETAILS" Url="http://docs.oracle.com/database/121/SQLRF/functions028.htm">CLUSTER_DETAILS returns cluster details for each row in the selection. The return value is an XML string that describes the attributes of the highest probability cluster or the specified cluster_id.</Function>
  <Function Name="CLUSTER_DISTANCE" Url="http://docs.oracle.com/database/121/SQLRF/functions029.htm">CLUSTER_DISTANCE returns a cluster distance for each row in the selection. The cluster distance is the distance between the row and the centroid of the highest probability cluster or the specified cluster_id. The distance is returned as BINARY_DOUBLE.</Function>
  <Function Name="CLUSTER_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions030.htm">CLUSTER_ID returns the identifier of the highest probability cluster for each row in the selection. The cluster identifier is returned as an Oracle NUMBER.</Function>
  <Function Name="CLUSTER_PROBABILITY" Url="http://docs.oracle.com/database/121/SQLRF/functions031.htm">CLUSTER_PROBABILITY returns a probability for each row in the selection. The probability refers to the highest probability cluster or to the specified cluster_id. The cluster probability is returned as BINARY_DOUBLE.</Function>
  <Function Name="CLUSTER_SET" Url="http://docs.oracle.com/database/121/SQLRF/functions032.htm">CLUSTER_SET returns a set of cluster ID and probability pairs for each row in the selection. The return value is a varray of objects with field names CLUSTER_ID and PROBABILITY. The cluster identifier is an Oracle NUMBER; the probability is BINARY_DOUBLE.</Function>
  <Function Name="COALESCE" Url="http://docs.oracle.com/database/121/SQLRF/functions033.htm">COALESCE returns the first non-null expr in the expression list. You must specify at least two expressions. If all occurrences of expr evaluate to null, then the function returns null.
Oracle Database uses short-circuit evaluation. The database evaluates each expr value and determines whether it is NULL, rather than evaluating all of the expr values before determining whether any of them is NULL.
If all occurrences of expr are numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
  <Function Name="COLLECT" Url="http://docs.oracle.com/database/121/SQLRF/functions034.htm">COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
If column is itself a collection, then the output of COLLECT is a nested table of collections. If column is of a user-defined type, then column must have a MAP or ORDER method defined on it in order for you to use the optional DISTINCT, UNIQUE, and ORDER BY clauses.</Function>
  <Function Name="COMPOSE" Url="http://docs.oracle.com/database/121/SQLRF/functions035.htm">COMPOSE takes as its argument a string, or an expression that resolves to a string, in any data type, and returns a Unicode string in the same character set as the input. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. For example, an o code point qualified by an umlaut code point will be returned as the o-umlaut code point.
COMPOSE returns the string in NFC normal form. For a more exclusive setting, you can first call DECOMPOSE with the CANONICAL setting and then COMPOSE. This combination returns the string in NFKC normal form.
CLOB and NCLOB values are supported through implicit conversion. If char is a character LOB value, then it is converted to a VARCHAR value before the COMPOSE operation. The operation will fail if the size of the LOB value exceeds the supported length of the VARCHAR in the particular development environment.</Function>
  <Function Name="CONCAT" Url="http://docs.oracle.com/database/121/SQLRF/functions040.htm">CONCAT returns char1 concatenated with char2. Both char1 and char2 can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is in the same character set as char1. Its data type depends on the data types of the arguments.
In concatenations of two different data types, Oracle Database returns the data type that results in a lossless conversion. Therefore, if one of the arguments is a LOB, then the returned value is a LOB. If one of the arguments is a national data type, then the returned value is a national data type. For example:</Function>
  <Function Name="CONVERT" Url="http://docs.oracle.com/database/121/SQLRF/functions041.htm">CONVERT converts a character string from one character set to another.</Function>
  <Function Name="CORR" Url="http://docs.oracle.com/database/121/SQLRF/functions042.htm">CORR returns the coefficient of correlation of a set of number pairs. You can use it as an aggregate or analytic function.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
  <Function Name="CORR" Url="http://docs.oracle.com/database/121/SQLRF/functions043.htm">The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
These functions takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns NUMBER.</Function>
  <Function Name="COS" Url="http://docs.oracle.com/database/121/SQLRF/functions044.htm">COS returns the cosine of n (an angle expressed in radians).
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="COSH" Url="http://docs.oracle.com/database/121/SQLRF/functions045.htm">COSH returns the hyperbolic cosine of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="COUNT" Url="http://docs.oracle.com/database/121/SQLRF/functions046.htm">COUNT returns the number of rows returned by the query. You can use it as an aggregate or analytic function.
If you specify DISTINCT, then you can specify only the query_partition_clause of the analytic_clause. The order_by_clause and windowing_clause are not allowed.
If you specify expr, then COUNT returns the number of rows where expr is not null. You can count either all rows, or only distinct values of expr.
If you specify the asterisk (*), then this function returns all rows, including duplicates and nulls. COUNT never returns null.</Function>
  <Function Name="COVAR_POP" Url="http://docs.oracle.com/database/121/SQLRF/functions047.htm">COVAR_POP returns the population covariance of a set of number pairs. You can use it as an aggregate or analytic function.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
  <Function Name="COVAR_SAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions048.htm">COVAR_SAMP returns the sample covariance of a set of number pairs. You can use it as an aggregate or analytic function.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
  <Function Name="CUBE_TABLE" Url="http://docs.oracle.com/database/121/SQLRF/functions049.htm">CUBE_TABLE extracts data from a cube or dimension and returns it in the two-dimensional format of a relational table, which can be used by SQL-based applications.
The function takes a single VARCHAR2 argument. The optional hierarchy clause enables you to specify a dimension hierarchy. A cube can have multiple hierarchy clauses, one for each dimension.
You can generate these different types of tables:</Function>
  <Function Name="CUME_DIST" Url="http://docs.oracle.com/database/121/SQLRF/functions050.htm">CUME_DIST calculates the cumulative distribution of a value in a group of values. The range of values returned by CUME_DIST is &gt;0 to &lt;=1. Tie values always evaluate to the same cumulative distribution value.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns NUMBER.</Function>
  <Function Name="CURRENT_DATE" Url="http://docs.oracle.com/database/121/SQLRF/functions051.htm">CURRENT_DATE returns the current date in the session time zone, in a value in the Gregorian calendar of data type DATE.</Function>
  <Function Name="CURRENT_TIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions052.htm">CURRENT_TIMESTAMP returns the current date and time in the session time zone, in a value of data type TIMESTAMP WITH TIME ZONE. The time zone offset reflects the current local time of the SQL session. If you omit precision, then the default is 6. The difference between this function and LOCALTIMESTAMP is that CURRENT_TIMESTAMP returns a TIMESTAMP WITH TIME ZONE value while LOCALTIMESTAMP returns a TIMESTAMP value.
In the optional argument, precision specifies the fractional second precision of the time value returned.</Function>
  <Function Name="CV" Url="http://docs.oracle.com/database/121/SQLRF/functions053.htm">The CV function can be used only in the model_clause of a SELECT statement and then only on the right-hand side of a model rule. It returns the current value of a dimension column or a partitioning column carried from the left-hand side to the right-hand side of a rule. This function is used in the model_clause to provide relative indexing with respect to the dimension column. The return type is that of the data type of the dimension column. If you omit the argument, then it defaults to the dimension column associated with the relative position of the function within the cell reference.
The CV function can be used outside a cell reference. In this case, dimension_column is required.</Function>
  <Function Name="DATAOBJ_TO_PARTITION" Url="http://docs.oracle.com/database/121/SQLRF/functions054.htm">DATAOBJ_TO_PARTITION is useful only to Data Cartridge developers who are performing data maintenance or query operations on system-partitioned tables that are used to store domain index data. The DML or query operations are triggered by corresponding operations on the base table of the domain index.
This function takes as arguments the name of the base table and the partition ID of the base table partition, both of which are passed to the function by the appropriate ODCIIndex method. The function returns the partition ID of the corresponding system-partitioned table, which can be used to perform the operation (DML or query) on that partition of the system-partitioned table.</Function>
  <Function Name="DBTIMEZONE" Url="http://docs.oracle.com/database/121/SQLRF/functions055.htm">DBTIMEZONE returns the value of the database time zone. The return type is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the user specified the database time zone value in the most recent CREATE DATABASE or ALTER DATABASE statement.</Function>
  <Function Name="DECODE" Url="http://docs.oracle.com/database/121/SQLRF/functions056.htm">DECODE compares expr to each search value one by one. If expr is equal to a search, then Oracle Database returns the corresponding result. If no match is found, then Oracle returns default. If default is omitted, then Oracle returns null.
The arguments can be any of the numeric types (NUMBER, BINARY_FLOAT, or BINARY_DOUBLE) or character types.</Function>
  <Function Name="DECOMPOSE" Url="http://docs.oracle.com/database/121/SQLRF/functions057.htm">DECOMPOSE is valid only for Unicode characters. DECOMPOSE takes as its argument a string in any data type and returns a Unicode string after decomposition in the same character set as the input. For example, an o-umlaut code point will be returned as the "o" code point followed by an umlaut code point.</Function>
  <Function Name="DELETEXML" Url="http://docs.oracle.com/database/121/SQLRF/functions058.htm">DELETEXML deletes the node or nodes matched by the XPath expression in the target XML.</Function>
  <Function Name="DENSE_RANK" Url="http://docs.oracle.com/database/121/SQLRF/functions059.htm">DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting.
This function accepts as arguments any numeric data type and returns NUMBER.</Function>
  <Function Name="DEPTH" Url="http://docs.oracle.com/database/121/SQLRF/functions060.htm">DEPTH is an ancillary function used only with the UNDER_PATH and EQUALS_PATH conditions. It returns the number of levels in the path specified by the UNDER_PATH condition with the same correlation variable.
The correlation_integer can be any NUMBER integer. Use it to correlate this ancillary function with its primary condition if the statement contains multiple primary conditions. Values less than 1 are treated as 1.</Function>
  <Function Name="DEREF" Url="http://docs.oracle.com/database/121/SQLRF/functions061.htm">DEREF returns the object reference of argument expr, where expr must return a REF to an object. If you do not use this function in a query, then Oracle Database returns the object ID of the REF instead, as shown in the example that follows.</Function>
  <Function Name="DUMP" Url="http://docs.oracle.com/database/121/SQLRF/functions062.htm">DUMP returns a VARCHAR2 value containing the data type code, length in bytes, and internal representation of expr. The returned result is always in the database character set. For the data type corresponding to each code, see Table 2-1, "Built-in Data Type Summary".
The argument return_fmt specifies the format of the return value and can have any of the following values:</Function>
  <Function Name="EMPTY_BLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions063.htm">EMPTY_BLOB and EMPTY_CLOB return an empty LOB locator that can be used to initialize a LOB variable or, in an INSERT or UPDATE statement, to initialize a LOB column or attribute to EMPTY. EMPTY means that the LOB is initialized, but not populated with data.</Function>
  <Function Name="EXISTSNODE" Url="http://docs.oracle.com/database/121/SQLRF/functions064.htm">EXISTSNODE determines whether traversal of an XML document using a specified path results in any nodes. It takes as arguments the XMLType instance containing an XML document and a VARCHAR2 XPath string designating a path. The optional namespace_string must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).
The namespace_string argument defaults to the namespace of the root element. If you refer to any subelement in Xpath_string, then you must specify namespace_string, and you must specify the "who" prefix in both of these arguments.</Function>
  <Function Name="EXP" Url="http://docs.oracle.com/database/121/SQLRF/functions065.htm">EXP returns e raised to the nth power, where e = 2.71828183... . The function returns a value of the same type as the argument.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="EXTRACT" Url="http://docs.oracle.com/database/121/SQLRF/functions066.htm">EXTRACT extracts and returns the value of a specified datetime field from a datetime or interval expression. The expr can be any expression that evaluates to a datetime or interval data type compatible with the requested field:</Function>
  <Function Name="EXTRACT" Url="http://docs.oracle.com/database/121/SQLRF/functions067.htm">EXTRACT (XML) is similar to the EXISTSNODE function. It applies a VARCHAR2 XPath string and returns an XMLType instance containing an XML fragment. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. The optional namespace_string is required if the XML you are handling uses a namespace prefix. This argument must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).</Function>
  <Function Name="FEATURE_DETAILS" Url="http://docs.oracle.com/database/121/SQLRF/functions069.htm">FEATURE_DETAILS returns feature details for each row in the selection. The return value is an XML string that describes the attributes of the highest value feature or the specified feature_id.</Function>
  <Function Name="FEATURE_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions070.htm">FEATURE_ID returns the identifier of the highest value feature for each row in the selection. The feature identifier is returned as an Oracle NUMBER.</Function>
  <Function Name="FEATURE_SET" Url="http://docs.oracle.com/database/121/SQLRF/functions071.htm">FEATURE_SET returns a set of feature ID and feature value pairs for each row in the selection. The return value is a varray of objects with field names FEATURE_ID and VALUE. The data type of both fields is NUMBER.</Function>
  <Function Name="FEATURE_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions072.htm">FEATURE_VALUE returns a feature value for each row in the selection. The value refers to the highest value feature or to the specified feature_id. The feature value is returned as BINARY_DOUBLE.</Function>
  <Function Name="FIRST" Url="http://docs.oracle.com/database/121/SQLRF/functions073.htm">FIRST and LAST are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the FIRST or LAST with respect to a given sorting specification. If only one row ranks as FIRST or LAST, then the aggregate operates on the set with only one element.
If you omit the OVER clause, then the FIRST and LAST functions are treated as aggregate functions. You can use these functions as analytic functions by specifying the OVER clause. The query_partition_clause is the only part of the OVER clause valid with these functions. If you include the OVER clause but omit the query_partition_clause, then the function is treated as an analytic function, but the window defined for analysis is the entire table.
These functions take as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.
When you need a value from the first or last row of a sorted group, but the needed value is not the sort key, the FIRST and LAST functions eliminate the need for self-joins or views and enable better performance.</Function>
  <Function Name="FIRST" Url="http://docs.oracle.com/database/121/SQLRF/functions094.htm">FIRST and LAST are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the FIRST or LAST with respect to a given sorting specification. If only one row ranks as FIRST or LAST, then the aggregate operates on the set with only one element.
Refer to FIRST for complete information on this function and for examples of its use.</Function>
  <Function Name="FIRST_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions074.htm">FIRST_VALUE is an analytic function. It returns the first value in an ordered set of values. If the first value in the set is null, then the function returns NULL unless you specify IGNORE NULLS. This setting is useful for data densification.</Function>
  <Function Name="FLOOR" Url="http://docs.oracle.com/database/121/SQLRF/functions075.htm">FLOOR returns the largest integer equal to or less than n. The number n can always be written as the sum of an integer k and a positive fraction f such that 0 &lt;= f &lt; 1 and n = k + f. The value of FLOOR is the integer k. Thus, the value of FLOOR is n itself if and only if n is precisely an integer.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="FROM_TZ" Url="http://docs.oracle.com/database/121/SQLRF/functions076.htm">FROM_TZ converts a timestamp value and a time zone to a TIMESTAMP WITH TIME ZONE value. time_zone_value is a character string in the format 'TZH:TZM' or a character expression that returns a string in TZR with optional TZD format.</Function>
  <Function Name="GREATEST" Url="http://docs.oracle.com/database/121/SQLRF/functions077.htm">GREATEST returns the greatest of a list of one or more expressions. Oracle Database uses the first expr to determine the return type. If the first expr is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first expr is not numeric, then each expr after the first is implicitly converted to the data type of the first expr before the comparison.
Oracle Database compares each expr using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the NLS_COMP parameter is set to LINGUISTIC and the NLS_SORT parameter has a setting other than BINARY. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is VARCHAR2 if the first expr is a character data type and NVARCHAR2 if the first expr is a national character data type.</Function>
  <Function Name="GROUP_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions078.htm">GROUP_ID distinguishes duplicate groups resulting from a GROUP BY specification. It is useful in filtering out duplicate groupings from the query result. It returns an Oracle NUMBER to uniquely identify duplicate groups. This function is applicable only in a SELECT statement that contains a GROUP BY clause.
If n duplicates exist for a particular grouping, then GROUP_ID returns numbers in the range 0 to n-1.</Function>
  <Function Name="GROUPING" Url="http://docs.oracle.com/database/121/SQLRF/functions079.htm">GROUPING distinguishes superaggregate rows from regular grouped rows. GROUP BY extensions such as ROLLUP and CUBE produce superaggregate rows where the set of all values is represented by null. Using the GROUPING function, you can distinguish a null representing the set of all values in a superaggregate row from a null in a regular row.
The expr in the GROUPING function must match one of the expressions in the GROUP BY clause. The function returns a value of 1 if the value of expr in the row is a null representing the set of all values. Otherwise, it returns zero. The data type of the value returned by the GROUPING function is Oracle NUMBER. Refer to the SELECT group_by_clause for a discussion of these terms.</Function>
  <Function Name="GROUPING_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions080.htm">GROUPING_ID returns a number corresponding to the GROUPING bit vector associated with a row. GROUPING_ID is applicable only in a SELECT statement that contains a GROUP BY extension, such as ROLLUP or CUBE, and a GROUPING function. In queries with many GROUP BY expressions, determining the GROUP BY level of a particular row requires many GROUPING functions, which leads to cumbersome SQL. GROUPING_ID is useful in these cases.
GROUPING_ID is functionally equivalent to taking the results of multiple GROUPING functions and concatenating them into a bit vector (a string of ones and zeros). By using GROUPING_ID you can avoid the need for multiple GROUPING functions and make row filtering conditions easier to express. Row filtering is easier with GROUPING_ID because the desired rows can be identified with a single condition of GROUPING_ID = n. The function is especially useful when storing multiple levels of aggregation in a single table.</Function>
  <Function Name="HEXTORAW" Url="http://docs.oracle.com/database/121/SQLRF/functions081.htm">HEXTORAW converts char containing hexadecimal digits in the CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to a raw value.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="INITCAP" Url="http://docs.oracle.com/database/121/SQLRF/functions082.htm">INITCAP returns char, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric.
char can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The return value is the same data type as char. The database sets the case of the initial characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase and lowercase, refer to NLS_INITCAP.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="INSERTCHILDXML" Url="http://docs.oracle.com/database/121/SQLRF/functions083.htm">INSERTCHILDXML inserts a user-supplied value into the target XML at the node indicated by the XPath expression. Compare this function with INSERTXMLBEFORE.</Function>
  <Function Name="INSERTXMLAFTER" Url="http://docs.oracle.com/database/121/SQLRF/functions086.htm">INSERTXMLAFTER inserts one or more nodes of any kind immediately after a target node that is not an attribute node. The XML document that is the target of the insertion can be schema-based or non-schema-based. This function is similar to insertXMLbefore, but it inserts after, not before, the target node.</Function>
  <Function Name="INSERTXMLBEFORE" Url="http://docs.oracle.com/database/121/SQLRF/functions087.htm">INSERTXMLBEFORE inserts a user-supplied value into the target XML before the node indicated by the XPath expression. This function is similar to INSERTXMLAFTER, but it inserts before, not after, the target node. Compare this function with INSERTCHILDXML.</Function>
  <Function Name="INSERTXMLCHILDAFTER" Url="http://docs.oracle.com/database/121/SQLRF/functions084.htm">INSERTXMLCHILDAFTER inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately after a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based.</Function>
  <Function Name="INSERTXMLCHILDBEFORE" Url="http://docs.oracle.com/database/121/SQLRF/functions085.htm">INSERTXMLCHILDBEFORE inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately before a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based.</Function>
  <Function Name="INSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions088.htm">The INSTR functions search string for substring. The search operation is defined as comparing the substring argument with substrings of string of the same length for equality until a match is found or there are no more substrings left. Each consecutive compared substring of string begins one character to the right (for forward searches) or one character to the left (for backward searches) from the first character of the previous compared substring. If a substring that is equal to substring is found, then the function returns an integer indicating the position of the first character of this substring. If no such substring is found, then the function returns zero.</Function>
  <Function Name="ITERATION_NUMBER" Url="http://docs.oracle.com/database/121/SQLRF/functions089.htm">The ITERATION_NUMBER function can be used only in the model_clause of the SELECT statement and then only when ITERATE(number) is specified in the model_rules_clause. It returns an integer representing the completed iteration through the model rules. The ITERATION_NUMBER function returns 0 during the first iteration. For each subsequent iteration, the ITERATION_NUMBER function returns the equivalent of iteration_number plus one.</Function>
  <Function Name="JSON_QUERY" Url="http://docs.oracle.com/database/121/SQLRF/functions090.htm">JSON_QUERY finds one or more specified JSON values in JSON data and returns the values in a character string.</Function>
  <Function Name="JSON_TABLE" Url="http://docs.oracle.com/database/121/SQLRF/functions091.htm">JSON_TABLE creates a relational view of JSON data. It maps the result of a JSON data evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL. The main purpose of JSON_TABLE is to create a row of relational data for each object inside a JSON array and output JSON values from within that object as individual SQL column values.
You must specify JSON_TABLE only in the FROM clause of a SELECT statement. The function first applies a JSON path expression, called a row path expression, to the supplied JSON data. The JSON value that matches the row path expression is called a row source in that it generates a row of relational data. The COLUMNS clause evaluates the row source, finds specific JSON values within the row source, and returns those JSON values as SQL values in individual columns of a row of relational data.
The COLUMNS clause enables you to search for JSON values in different ways by using the following clauses:</Function>
  <Function Name="JSON_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions092.htm">JSON_VALUE finds a specified scalar JSON value in JSON data and returns it as a SQL value.</Function>
  <Function Name="LAG" Url="http://docs.oracle.com/database/121/SQLRF/functions093.htm">LAG is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, LAG provides access to a row at a given physical offset prior to that position.
For the optional offset argument, specify an integer that is greater than zero. If you do not specify offset, then its default is 1. The optional default value is returned if the offset goes beyond the scope of the window. If you do not specify default, then its default is null.
{RESPECT | IGNORE} NULLS determines whether null values of value_expr are included in or eliminated from the calculation. The default is RESPECT NULLS.
You cannot nest analytic functions by using LAG or any other analytic function for value_expr. However, you can use other built-in function expressions for value_expr.</Function>
  <Function Name="LAST_DAY" Url="http://docs.oracle.com/database/121/SQLRF/functions095.htm">LAST_DAY returns the date of the last day of the month that contains date. The last day of the month is defined by the session parameter NLS_CALENDAR. The return type is always DATE, regardless of the data type of date.</Function>
  <Function Name="LAST_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions096.htm">LAST_VALUE is an analytic function that is useful for data densification. It returns the last value in an ordered set of values.</Function>
  <Function Name="LEAD" Url="http://docs.oracle.com/database/121/SQLRF/functions097.htm">LEAD is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, LEAD provides access to a row at a given physical offset beyond that position.
If you do not specify offset, then its default is 1. The optional default value is returned if the offset goes beyond the scope of the table. If you do not specify default, then its default value is null.
{RESPECT | IGNORE} NULLS determines whether null values of value_expr are included in or eliminated from the calculation. The default is RESPECT NULLS.
You cannot nest analytic functions by using LEAD or any other analytic function for value_expr. However, you can use other built-in function expressions for value_expr.</Function>
  <Function Name="LEAST" Url="http://docs.oracle.com/database/121/SQLRF/functions098.htm">LEAST returns the least of a list of one or more expressions. Oracle Database uses the first expr to determine the return type. If the first expr is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first expr is not numeric, then each expr after the first is implicitly converted to the data type of the first expr before the comparison.
Oracle Database compares each expr using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the NLS_COMP parameter is set to LINGUISTIC and the NLS_SORT parameter has a setting other than BINARY. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is VARCHAR2 if the first expr is a character data type and NVARCHAR2 if the first expr is a national character data type.</Function>
  <Function Name="LENGTH" Url="http://docs.oracle.com/database/121/SQLRF/functions099.htm">The LENGTH functions return the length of char. LENGTH calculates length using characters as defined by the input character set. LENGTHB uses bytes instead of characters. LENGTHC uses Unicode complete characters. LENGTH2 uses UCS2 code points. LENGTH4 uses UCS4 code points.
char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The exceptions are LENGTHC, LENGTH2, and LENGTH4, which do not allow char to be a CLOB or NCLOB. The return value is of data type NUMBER. If char has data type CHAR, then the length includes all trailing blanks. If char is null, then this function returns null.</Function>
  <Function Name="LISTAGG" Url="http://docs.oracle.com/database/121/SQLRF/functions100.htm">For a specified measure, LISTAGG orders data within each group specified in the ORDER BY clause and then concatenates the values of the measure column.</Function>
  <Function Name="LN" Url="http://docs.oracle.com/database/121/SQLRF/functions101.htm">LN returns the natural logarithm of n, where n is greater than 0.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="LNNVL" Url="http://docs.oracle.com/database/121/SQLRF/functions102.htm">LNNVL provides a concise way to evaluate a condition when one or both operands of the condition may be null. The function can be used in the WHERE clause of a query, or as the WHEN condition in a searched CASE expression. It takes as an argument a condition and returns TRUE if the condition is FALSE or UNKNOWN and FALSE if the condition is TRUE. LNNVL can be used anywhere a scalar expression can appear, even in contexts where the IS [NOT] NULL, AND, or OR conditions are not valid but would otherwise be required to account for potential nulls.
Oracle Database sometimes uses the LNNVL function internally in this way to rewrite NOT IN conditions as NOT EXISTS conditions. In such cases, output from EXPLAIN PLAN shows this operation in the plan table output. The condition can evaluate any scalar values but cannot be a compound condition containing AND, OR, or BETWEEN.
The table that follows shows what LNNVL returns given that a = 2 and b is null.</Function>
  <Function Name="LOCALTIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions103.htm">LOCALTIMESTAMP returns the current date and time in the session time zone in a value of data type TIMESTAMP. The difference between this function and CURRENT_TIMESTAMP is that LOCALTIMESTAMP returns a TIMESTAMP value while CURRENT_TIMESTAMP returns a TIMESTAMP WITH TIME ZONE value.
The optional argument timestamp_precision specifies the fractional second precision of the time value returned.</Function>
  <Function Name="LOG" Url="http://docs.oracle.com/database/121/SQLRF/functions104.htm">LOG returns the logarithm, base n2, of n1. The base n2 can be any positive value other than 0 or 1 and n1 can be any positive value.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is BINARY_FLOAT or BINARY_DOUBLE, then the function returns BINARY_DOUBLE. Otherwise the function returns NUMBER.</Function>
  <Function Name="LOWER" Url="http://docs.oracle.com/database/121/SQLRF/functions105.htm">LOWER returns char, with all letters lowercase. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The return value is the same data type as char. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive lowercase, refer to NLS_LOWER.</Function>
  <Function Name="LPAD" Url="http://docs.oracle.com/database/121/SQLRF/functions106.htm">LPAD returns expr1, left-padded to length n characters with the sequence of characters in expr2. This function is useful for formatting the output of a query.
Both expr1 and expr2 can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if expr1 is a character data type, NVARCHAR2 if expr1 is a national character data type, and a LOB if expr1 is a LOB data type. The string returned is in the same character set as expr1. The argument n must be a NUMBER integer or a value that can be implicitly converted to a NUMBER integer.
If you do not specify expr2, then the default is a single blank. If expr1 is longer than n, then this function returns the portion of expr1 that fits in n.
The argument n is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string.</Function>
  <Function Name="LTRIM" Url="http://docs.oracle.com/database/121/SQLRF/functions107.htm">LTRIM removes from the left end of char all of the characters contained in set. If you do not specify set, then it defaults to a single blank. If char is a character literal, then you must enclose it in single quotation marks. Oracle Database begins scanning char from its first character and removes all characters that appear in set until reaching a character not in set and then returns the result.
Both char and set can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type, NVARCHAR2 if char is a national character data type, and a LOB if char is a LOB data type.</Function>
  <Function Name="MAKE_REF" Url="http://docs.oracle.com/database/121/SQLRF/functions108.htm">MAKE_REF creates a REF to a row of an object view or a row in an object table whose object identifier is primary key based. This function is useful, for example, if you are creating an object view</Function>
  <Function Name="MAX" Url="http://docs.oracle.com/database/121/SQLRF/functions109.htm">MAX returns maximum value of expr. You can use it as an aggregate or analytic function.</Function>
  <Function Name="MEDIAN" Url="http://docs.oracle.com/database/121/SQLRF/functions110.htm">MEDIAN is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you specify only expr, then the function returns the same data type as the numeric data type of the argument. If you specify the OVER clause, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
  <Function Name="MIN" Url="http://docs.oracle.com/database/121/SQLRF/functions111.htm">MIN returns minimum value of expr. You can use it as an aggregate or analytic function.</Function>
  <Function Name="MOD" Url="http://docs.oracle.com/database/121/SQLRF/functions112.htm">MOD returns the remainder of n2 divided by n1. Returns n2 if n1 is 0.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
  <Function Name="MONTHS_BETWEEN" Url="http://docs.oracle.com/database/121/SQLRF/functions113.htm">MONTHS_BETWEEN returns number of months between dates date1 and date2. The month and the last day of the month are defined by the parameter NLS_CALENDAR. If date1 is later than date2, then the result is positive. If date1 is earlier than date2, then the result is negative. If date1 and date2 are either the same days of the month or both last days of months, then the result is always an integer. Otherwise Oracle Database calculates the fractional portion of the result based on a 31-day month and considers the difference in time components date1 and date2.</Function>
  <Function Name="NANVL" Url="http://docs.oracle.com/database/121/SQLRF/functions114.htm">The NANVL function is useful only for floating-point numbers of type BINARY_FLOAT or BINARY_DOUBLE. It instructs Oracle Database to return an alternative value n1 if the input value n2 is NaN (not a number). If n2 is not NaN, then Oracle returns n2.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
  <Function Name="NCHR" Url="http://docs.oracle.com/database/121/SQLRF/functions115.htm">NCHR returns the character having the binary equivalent to number in the national character set. The value returned is always NVARCHAR2. This function is equivalent to using the CHR function with the USING NCHAR_CS clause.
This function takes as an argument a NUMBER value, or any value that can be implicitly converted to NUMBER, and returns a character.</Function>
  <Function Name="NEW_TIME" Url="http://docs.oracle.com/database/121/SQLRF/functions116.htm">NEW_TIME returns the date and time in time zone timezone2 when date and time in time zone timezone1 are date. Before using this function, you must set the NLS_DATE_FORMAT parameter to display 24-hour time. The return type is always DATE, regardless of the data type of date.</Function>
  <Function Name="NEXT_DAY" Url="http://docs.oracle.com/database/121/SQLRF/functions117.htm">NEXT_DAY returns the date of the first weekday named by char that is later than the date date. The return type is always DATE, regardless of the data type of date. The argument char must be a day of the week in the date language of your session, either the full name or the abbreviation. The minimum number of letters required is the number of letters in the abbreviated version. Any characters immediately following the valid abbreviation are ignored. The return value has the same hours, minutes, and seconds component as the argument date.</Function>
  <Function Name="NLS_CHARSET_DECL_LEN" Url="http://docs.oracle.com/database/121/SQLRF/functions118.htm">NLS_CHARSET_DECL_LEN returns the declaration length (in number of characters) of an NCHAR column. The byte_count argument is the width of the column. The char_set_id argument is the character set ID of the column.</Function>
  <Function Name="NLS_CHARSET_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions119.htm">NLS_CHARSET_ID returns the character set ID number corresponding to character set name string. The string argument is a run-time VARCHAR2 value. The string value 'CHAR_CS' returns the database character set ID number of the server. The string value 'NCHAR_CS' returns the national character set ID number of the server.
Invalid character set names return null.</Function>
  <Function Name="NLS_CHARSET_NAME" Url="http://docs.oracle.com/database/121/SQLRF/functions120.htm">NLS_CHARSET_NAME returns the name of the character set corresponding to ID number number. The character set name is returned as a VARCHAR2 value in the database character set.
If number is not recognized as a valid character set ID, then this function returns null.</Function>
  <Function Name="NLS_INITCAP" Url="http://docs.oracle.com/database/121/SQLRF/functions121.htm">NLS_INITCAP returns char, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The string returned is of VARCHAR2 data type and is in the same character set as char.
The value of 'nlsparam' can have this form:</Function>
  <Function Name="NLS_LOWER" Url="http://docs.oracle.com/database/121/SQLRF/functions122.htm">NLS_LOWER returns char, with all letters lowercase.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type and a LOB if char is a LOB data type. The return string is in the same character set as char.
The 'nlsparam' can have the same form and serve the same purpose as in the NLS_INITCAP function.</Function>
  <Function Name="NLS_UPPER" Url="http://docs.oracle.com/database/121/SQLRF/functions123.htm">NLS_UPPER returns char, with all letters uppercase.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type and a LOB if char is a LOB data type. The return string is in the same character set as char.
The 'nlsparam' can have the same form and serve the same purpose as in the NLS_INITCAP function.</Function>
  <Function Name="NLSSORT" Url="http://docs.oracle.com/database/121/SQLRF/functions124.htm">NLSSORT returns a collation key for the character value char and an explicitly or implicitly specified collation. A collation key is a string of bytes used to sort char according to the specified collation. The property of the collation keys is that mutual ordering of two such keys generated for the given collation when compared according to their binary order is the same as mutual ordering of the source character values when compared according to the given collation.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2.
The value of 'nlsparam' must have the form</Function>
  <Function Name="NTH_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions125.htm">NTH_VALUE returns the measure_expr value of the nth row in the window defined by the analytic_clause. The returned value has the data type of the measure_expr.</Function>
  <Function Name="NTILE" Url="http://docs.oracle.com/database/121/SQLRF/functions126.htm">NTILE is an analytic function. It divides an ordered data set into a number of buckets indicated by expr and assigns the appropriate bucket number to each row. The buckets are numbered 1 through expr. The expr value must resolve to a positive constant for each partition. Oracle Database expects an integer, and if expr is a noninteger constant, then Oracle truncates the value to an integer. The return value is NUMBER.
The number of rows in the buckets can differ by at most 1. The remainder values (the remainder of number of rows divided by buckets) are distributed one for each bucket, starting with bucket 1.
If expr is greater than the number of rows, then a number of buckets equal to the number of rows will be filled, and the remaining buckets will be empty.
You cannot nest analytic functions by using NTILE or any other analytic function for expr. However, you can use other built-in function expressions for expr.</Function>
  <Function Name="NULLIF" Url="http://docs.oracle.com/database/121/SQLRF/functions127.htm">NULLIF compares expr1 and expr2. If they are equal, then the function returns null. If they are not equal, then the function returns expr1. You cannot specify the literal NULL for expr1.
If both arguments are numeric data types, then Oracle Database determines the argument with the higher numeric precedence, implicitly converts the other argument to that data type, and returns that data type. If the arguments are not numeric, then they must be of the same data type, or Oracle returns an error.
The NULLIF function is logically equivalent to the following CASE expression:</Function>
  <Function Name="NUMTODSINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions128.htm">NUMTODSINTERVAL converts n to an INTERVAL DAY TO SECOND literal. The argument n can be any NUMBER value or an expression that can be implicitly converted to a NUMBER value. The argument interval_unit can be of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type. The value for interval_unit specifies the unit of n and must resolve to one of the following string values:</Function>
  <Function Name="NUMTOYMINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions129.htm">NUMTOYMINTERVAL converts number n to an INTERVAL YEAR TO MONTH literal. The argument n can be any NUMBER value or an expression that can be implicitly converted to a NUMBER value. The argument interval_unit can be of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type. The value for interval_unit specifies the unit of n and must resolve to one of the following string values:</Function>
  <Function Name="NVL" Url="http://docs.oracle.com/database/121/SQLRF/functions130.htm">NVL lets you replace null (returned as a blank) with a string in the results of a query. If expr1 is null, then NVL returns expr2. If expr1 is not null, then NVL returns expr1.
The arguments expr1 and expr2 can have any data type. If their data types are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. The implicit conversion is implemented as follows:</Function>
  <Function Name="NVL2" Url="http://docs.oracle.com/database/121/SQLRF/functions131.htm">NVL2 lets you determine the value returned by a query based on whether a specified expression is null or not null. If expr1 is not null, then NVL2 returns expr2. If expr1 is null, then NVL2 returns expr3.
The argument expr1 can have any data type. The arguments expr2 and expr3 can have any data types except LONG.
If the data types of expr2 and expr3 are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. If expr2 is character or numeric data, then the implicit conversion is implemented as follows:</Function>
  <Function Name="ORA_DST_AFFECTED" Url="http://docs.oracle.com/database/121/SQLRF/functions132.htm">ORA_DST_AFFECTED is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values. The function returns 1 if the datetime value is affected by or will result in a "nonexisting time" or "duplicate time" error with the new time zone data. Otherwise, it returns 0.
This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the DBMS_DST.BEGIN_PREPARE and the DBMS_DST.END_PREPARE procedures or between the execution of the DBMS_DST.BEGIN_UPGRADE and the DBMS_DST.END_UPGRADE procedures.</Function>
  <Function Name="ORA_DST_CONVERT" Url="http://docs.oracle.com/database/121/SQLRF/functions133.htm">ORA_DST_CONVERT is useful when you are changing the time zone data file for your database. The function lets you specify error handling for a specified datetime expression.</Function>
  <Function Name="ORA_DST_ERROR" Url="http://docs.oracle.com/database/121/SQLRF/functions134.htm">ORA_DST_ERROR is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values, and indicates whether the datetime value will result in an error with the new time zone data. The return values are:</Function>
  <Function Name="ORA_HASH" Url="http://docs.oracle.com/database/121/SQLRF/functions135.htm">ORA_HASH is a function that computes a hash value for a given expression. This function is useful for operations such as analyzing a subset of data and generating a random sample.</Function>
  <Function Name="ORA_INVOKING_USER" Url="http://docs.oracle.com/database/121/SQLRF/functions136.htm">ORA_INVOKING_USER returns the name of the database user who invoked the current statement or view. This function takes into account the BEQUEATH property of intervening views referenced in the statement. If this function is invoked from within a definer's rights context, then it returns the name of the owner of the definer's rights object. If the invoking user is a Real Application Security user, then it returns user XS$NULL.
This function returns a VARCHAR2 value.</Function>
  <Function Name="ORA_INVOKING_USERID" Url="http://docs.oracle.com/database/121/SQLRF/functions137.htm">ORA_INVOKING_USERID returns the identifier of the database user who invoked the current statement or view. This function takes into account the BEQUEATH property of intervening views referenced in the statement.
This function returns a NUMBER value.</Function>
  <Function Name="PATH" Url="http://docs.oracle.com/database/121/SQLRF/functions138.htm">PATH is an ancillary function used only with the UNDER_PATH and EQUALS_PATH conditions. It returns the relative path that leads to the resource specified in the parent condition.
The correlation_integer can be any NUMBER integer and is used to correlate this ancillary function with its primary condition. Values less than 1 are treated as 1.</Function>
  <Function Name="PERCENT_RANK" Url="http://docs.oracle.com/database/121/SQLRF/functions139.htm">PERCENT_RANK is similar to the CUME_DIST (cumulative distribution) function. The range of values returned by PERCENT_RANK is 0 to 1, inclusive. The first row in any set has a PERCENT_RANK of 0. The return value is NUMBER.</Function>
  <Function Name="PERCENTILE_CONT" Url="http://docs.oracle.com/database/121/SQLRF/functions140.htm">PERCENTILE_CONT is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="PERCENTILE_DISC" Url="http://docs.oracle.com/database/121/SQLRF/functions141.htm">PERCENTILE_DISC is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="POWER" Url="http://docs.oracle.com/database/121/SQLRF/functions142.htm">POWER returns n2 raised to the n1 power. The base n2 and the exponent n1 can be any numbers, but if n2 is negative, then n1 must be an integer.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is BINARY_FLOAT or BINARY_DOUBLE, then the function returns BINARY_DOUBLE. Otherwise, the function returns NUMBER.</Function>
  <Function Name="POWERMULTISET" Url="http://docs.oracle.com/database/121/SQLRF/functions143.htm">POWERMULTISET takes as input a nested table and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the input nested table.</Function>
  <Function Name="POWERMULTISET_BY_CARDINALITY" Url="http://docs.oracle.com/database/121/SQLRF/functions144.htm">POWERMULTISET_BY_CARDINALITY takes as input a nested table and a cardinality and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the nested table of the specified cardinality.</Function>
  <Function Name="PREDICTION" Url="http://docs.oracle.com/database/121/SQLRF/functions145.htm">PREDICTION returns a prediction for each row in the selection. The data type of the returned prediction depends on whether the function performs regression, classification, or anomaly detection.</Function>
  <Function Name="PREDICTION_BOUNDS" Url="http://docs.oracle.com/database/121/SQLRF/functions146.htm">PREDICTION_BOUNDS applies a Generalized Linear Model (GLM) to predict a class or a value for each row in the selection. The function returns the upper and lower bounds of each prediction in a varray of objects with fields UPPER and LOWER.
GLM can perform either regression or binary classification:</Function>
  <Function Name="PREDICTION_COST" Url="http://docs.oracle.com/database/121/SQLRF/functions147.htm">PREDICTION_COST returns a cost for each row in the selection. The cost refers to the lowest cost class or to the specified class. The cost is returned as BINARY_DOUBLE.
PREDICTION_COST can perform classification or anomaly detection. For classification, the returned cost refers to a predicted target class. For anomaly detection, the returned cost refers to a classification of 1 (for typical rows) or 0 (for anomalous rows).
You can use PREDICTION_COST in conjunction with the PREDICTION function to obtain the prediction and the cost of the prediction.</Function>
  <Function Name="PREDICTION_DETAILS" Url="http://docs.oracle.com/database/121/SQLRF/functions148.htm">PREDICTION_DETAILS returns prediction details for each row in the selection. The return value is an XML string that describes the attributes of the prediction.
For regression, the returned details refer to the predicted target value. For classification and anomaly detection, the returned details refer to the highest probability class or the specified class_value.</Function>
  <Function Name="PREDICTION_PROBABILITY" Url="http://docs.oracle.com/database/121/SQLRF/functions149.htm">PREDICTION_PROBABILITY returns a probability for each row in the selection. The probability refers to the highest probability class or to the specified class. The data type of the returned probability is BINARY_DOUBLE.
PREDICTION_PROBABILITY can perform classification or anomaly detection. For classification, the returned probability refers to a predicted target class. For anomaly detection, the returned probability refers to a classification of 1 (for typical rows) or 0 (for anomalous rows).
You can use PREDICTION_PROBABILITY in conjunction with the PREDICTION function to obtain the prediction and the probability of the prediction.</Function>
  <Function Name="PREDICTION_SET" Url="http://docs.oracle.com/database/121/SQLRF/functions150.htm">PREDICTION_SET returns a set of predictions with either probabilities or costs for each row in the selection. The return value is a varray of objects with field names PREDICTION_ID and PROBABILITY or COST. The prediction identifier is an Oracle NUMBER; the probability and cost fields are BINARY_DOUBLE.
PREDICTION_SET can perform classification or anomaly detection. For classification, the return value refers to a predicted target class. For anomaly detection, the return value refers to a classification of 1 (for typical rows) or 0 (for anomalous rows).</Function>
  <Function Name="PRESENTNNV" Url="http://docs.oracle.com/database/121/SQLRF/functions151.htm">The PRESENTNNV function can be used only in the model_clause of the SELECT statement and then only on the right-hand side of a model rule. It returns expr1 when cell_reference exists prior to the execution of the model_clause and is not null when PRESENTNNV is evaluated. Otherwise it returns expr2. This function differs from NVL2 in that NVL2 evaluates the data at the time it is executed, rather than evaluating the data as it was prior to the execution of the model_clause.</Function>
  <Function Name="PRESENTV" Url="http://docs.oracle.com/database/121/SQLRF/functions152.htm">The PRESENTV function can be used only within the model_clause of the SELECT statement and then only on the right-hand side of a model rule. It returns expr1 when, prior to the execution of the model_clause, cell_reference exists. Otherwise it returns expr2.</Function>
  <Function Name="PREVIOUS" Url="http://docs.oracle.com/database/121/SQLRF/functions153.htm">The PREVIOUS function can be used only in the model_clause of the SELECT statement and then only in the ITERATE ... [ UNTIL ] clause of the model_rules_clause. It returns the value of cell_reference at the beginning of each iteration.</Function>
  <Function Name="RANK" Url="http://docs.oracle.com/database/121/SQLRF/functions154.htm">RANK calculates the rank of a value in a group of values. The return type is NUMBER.</Function>
  <Function Name="RATIO_TO_REPORT" Url="http://docs.oracle.com/database/121/SQLRF/functions155.htm">RATIO_TO_REPORT is an analytic function. It computes the ratio of a value to the sum of a set of values. If expr evaluates to null, then the ratio-to-report value also evaluates to null.
The set of values is determined by the query_partition_clause. If you omit that clause, then the ratio-to-report is computed over all rows returned by the query.
You cannot nest analytic functions by using RATIO_TO_REPORT or any other analytic function for expr. However, you can use other built-in function expressions for expr. Refer to "About SQL Expressions" for information on valid forms of expr.</Function>
  <Function Name="RAWTOHEX" Url="http://docs.oracle.com/database/121/SQLRF/functions156.htm">RAWTOHEX converts raw to a character value containing its hexadecimal representation.
As a SQL built-in function, RAWTOHEX accepts an argument of any scalar data type other than LONG, LONG RAW, CLOB, BLOB, or BFILE. It returns a VARCHAR2 value with the hexadecimal representation of bytes that make up the value of raw. Each byte is represented by two hexadecimal digits.</Function>
  <Function Name="RAWTONHEX" Url="http://docs.oracle.com/database/121/SQLRF/functions157.htm">RAWTONHEX converts raw to a character value containing its hexadecimal representation. RAWTONHEX (raw) is equivalent to TO_NCHAR(RAWTOHEX(raw)). The value returned is always in the national character set.</Function>
  <Function Name="REF" Url="http://docs.oracle.com/database/121/SQLRF/functions158.htm">REF takes as its argument a correlation variable (table alias) associated with a row of an object table or an object view. A REF value is returned for the object instance that is bound to the variable or row.</Function>
  <Function Name="REFTOHEX" Url="http://docs.oracle.com/database/121/SQLRF/functions159.htm">REFTOHEX converts argument expr to a character value containing its hexadecimal equivalent. expr must return a REF.</Function>
  <Function Name="REGEXP_COUNT" Url="http://docs.oracle.com/database/121/SQLRF/functions160.htm">REGEXP_COUNT complements the functionality of the REGEXP_INSTR function by returning the number of times a pattern occurs in a source string. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the number of occurrences of pattern. If no match is found, then the function returns 0.</Function>
  <Function Name="REGEXP_INSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions161.htm">REGEXP_INSTR extends the functionality of the INSTR function by letting you search a string for a regular expression pattern. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the beginning or ending position of the matched substring, depending on the value of the return_option argument. If no match is found, then the function returns 0.
This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to Appendix D, "Oracle Regular Expression Support".</Function>
  <Function Name="REGEXP_REPLACE" Url="http://docs.oracle.com/database/121/SQLRF/functions162.htm">REGEXP_REPLACE extends the functionality of the REPLACE function by letting you search a string for a regular expression pattern. By default, the function returns source_char with every occurrence of the regular expression pattern replaced with replace_string. The string returned is in the same character set as source_char. The function returns VARCHAR2 if the first argument is not a LOB and returns CLOB if the first argument is a LOB.
This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to Appendix D, "Oracle Regular Expression Support".</Function>
  <Function Name="REGEXP_SUBSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions163.htm">REGEXP_SUBSTR extends the functionality of the SUBSTR function by letting you search a string for a regular expression pattern. It is also similar to REGEXP_INSTR, but instead of returning the position of the substring, it returns the substring itself. This function is useful if you need the contents of a match string but not its position in the source string. The function returns the string as VARCHAR2 or CLOB data in the same character set as source_char.
This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to Appendix D, "Oracle Regular Expression Support".</Function>
  <Function Name="REMAINDER" Url="http://docs.oracle.com/database/121/SQLRF/functions165.htm">REMAINDER returns the remainder of n2 divided by n1.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.
The MOD function is similar to REMAINDER except that it uses FLOOR in its formula, whereas REMAINDER uses ROUND. Refer to MOD.</Function>
  <Function Name="REPLACE" Url="http://docs.oracle.com/database/121/SQLRF/functions166.htm">REPLACE returns char with every occurrence of search_string replaced with replacement_string. If replacement_string is omitted or null, then all occurrences of search_string are removed. If search_string is null, then char is returned.
Both search_string and replacement_string, as well as char, can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is in the same character set as char. The function returns VARCHAR2 if the first argument is not a LOB and returns CLOB if the first argument is a LOB.
REPLACE provides functionality related to that provided by the TRANSLATE function. TRANSLATE provides single-character, one-to-one substitution. REPLACE lets you substitute one string for another as well as to remove character strings.</Function>
  <Function Name="ROUND" Url="http://docs.oracle.com/database/121/SQLRF/functions167.htm">ROUND returns date rounded to the unit specified by the format model fmt. This function is not sensitive to the NLS_CALENDAR session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type DATE, even if you specify a different datetime data type for date. If you omit fmt, then date is rounded to the nearest day. The date expression must resolve to a DATE value.</Function>
  <Function Name="ROUND" Url="http://docs.oracle.com/database/121/SQLRF/functions168.htm">ROUND returns n rounded to integer places to the right of the decimal point. If you omit integer, then n is rounded to zero places. If integer is negative, then n is rounded off to the left of the decimal point.
n can be any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit integer, then the function returns the value ROUND(n, 0) in the same data type as the numeric data type of n. If you include integer, then the function returns NUMBER.
ROUND is implemented using the following rules:

If n is 0, then ROUND always returns 0 regardless of integer.

If n is negative, then ROUND(n, integer) returns -ROUND(-n, integer).

If n is positive, then

ROUND(n, integer) = FLOOR(n * POWER(10, integer) + 0.5) * POWER(10, -integer)

ROUND applied to a NUMBER value may give a slightly different result from ROUND applied to the same value expressed in floating-point. The different results arise from differences in internal representations of NUMBER and floating point values. The difference will be 1 in the rounded digit if a difference occurs.</Function>
  <Function Name="ROW_NUMBER" Url="http://docs.oracle.com/database/121/SQLRF/functions169.htm">ROW_NUMBER is an analytic function. It assigns a unique number to each row to which it is applied (either each row in the partition or each row returned by the query), in the ordered sequence of rows specified in the order_by_clause, beginning with 1.
By nesting a subquery using ROW_NUMBER inside a query that retrieves the ROW_NUMBER values for a specified range, you can find a precise subset of rows from the results of the inner query. This use of the function lets you implement top-N, bottom-N, and inner-N reporting. For consistent results, the query must ensure a deterministic sort order.
You cannot nest analytic functions by using ROW_NUMBER or any other analytic function for expr. However, you can use other built-in function expressions for expr. Refer to "About SQL Expressions" for information on valid forms of expr.</Function>
  <Function Name="ROWIDTOCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions170.htm">ROWIDTOCHAR converts a rowid value to VARCHAR2 data type. The result of this conversion is always 18 characters long.</Function>
  <Function Name="ROWIDTONCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions171.htm">ROWIDTONCHAR converts a rowid value to NVARCHAR2 data type. The result of this conversion is always in the national character set and is 18 characters long.</Function>
  <Function Name="RPAD" Url="http://docs.oracle.com/database/121/SQLRF/functions172.htm">RPAD returns expr1, right-padded to length n characters with expr2, replicated as many times as necessary. This function is useful for formatting the output of a query.
Both expr1 and expr2 can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if expr1 is a character data type, NVARCHAR2 if expr1 is a national character data type, and a LOB if expr1 is a LOB data type. The string returned is in the same character set as expr1. The argument n must be a NUMBER integer or a value that can be implicitly converted to a NUMBER integer.
expr1 cannot be null. If you do not specify expr2, then it defaults to a single blank. If expr1 is longer than n, then this function returns the portion of expr1 that fits in n.
The argument n is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string.</Function>
  <Function Name="RTRIM" Url="http://docs.oracle.com/database/121/SQLRF/functions173.htm">RTRIM removes from the right end of char all of the characters that appear in set. This function is useful for formatting the output of a query.
If you do not specify set, then it defaults to a single blank. If char is a character literal, then you must enclose it in single quotation marks. RTRIM works similarly to LTRIM.
Both char and set can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type, NVARCHAR2 if char is a national character data type, and a LOB if char is a LOB data type.</Function>
  <Function Name="SCN_TO_TIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions174.htm">SCN_TO_TIMESTAMP takes as an argument a number that evaluates to a system change number (SCN), and returns the approximate timestamp associated with that SCN. The returned value is of TIMESTAMP data type. This function is useful any time you want to know the timestamp associated with an SCN. For example, it can be used in conjunction with the ORA_ROWSCN pseudocolumn to associate a timestamp with the most recent change to a row.</Function>
  <Function Name="SESSIONTIMEZONE" Url="http://docs.oracle.com/database/121/SQLRF/functions175.htm">SESSIONTIMEZONE returns the time zone of the current session. The return type is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the user specified the session time zone value in the most recent ALTER SESSION statement.</Function>
  <Function Name="SET" Url="http://docs.oracle.com/database/121/SQLRF/functions176.htm">SET converts a nested table into a set by eliminating duplicates. The function returns a nested table whose elements are distinct from one another. The returned nested table is of the same type as the input nested table.
The element types of the nested table must be comparable. Refer to "Comparison Conditions" for information on the comparability of nonscalar types.</Function>
  <Function Name="SIGN" Url="http://docs.oracle.com/database/121/SQLRF/functions177.htm">SIGN returns the sign of n. This function takes as an argument any numeric data type, or any nonnumeric data type that can be implicitly converted to NUMBER, and returns NUMBER.
For value of NUMBER type, the sign is:</Function>
  <Function Name="SIN" Url="http://docs.oracle.com/database/121/SQLRF/functions178.htm">SIN returns the sine of n (an angle expressed in radians).
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="SINH" Url="http://docs.oracle.com/database/121/SQLRF/functions179.htm">SINH returns the hyperbolic sine of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="SOUNDEX" Url="http://docs.oracle.com/database/121/SQLRF/functions180.htm">SOUNDEX returns a character string containing the phonetic representation of char. This function lets you compare words that are spelled differently, but sound alike in English.
The phonetic representation is defined in The Art of Computer Programming, Volume 3: Sorting and Searching, by Donald E. Knuth, as follows:

Retain the first letter of the string and remove all other occurrences of the following letters: a, e, h, i, o, u, w, y.

Assign numbers to the remaining letters (after the first) as follows:

b, f, p, v = 1
c, g, j, k, q, s, x, z = 2
d, t = 3
l = 4
m, n = 5
r = 6

If two or more letters with the same number were adjacent in the original name (before step 1), or adjacent except for any intervening h and w, then retain the first letter and omit rest of all the adjacent letters with same number.

Return the first four bytes padded with 0.

char can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The return value is the same data type as char.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="SQRT" Url="http://docs.oracle.com/database/121/SQLRF/functions181.htm">SQRT returns the square root of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="STANDARD_HASH" Url="http://docs.oracle.com/database/121/SQLRF/functions182.htm">STANDARD_HASH computes a hash value for a given expression using one of several hash algorithms that are defined and standardized by the National Institute of Standards and Technology. This function is useful for performing authentication and maintaining data integrity in security applications such as digital signatures, checksums, and fingerprinting.
You can use the STANDARD_HASH function to create an index on an extended data type column. Refer to "Creating an Index on an Extended Data Type Column" for more information.</Function>
  <Function Name="STATS_BINOMIAL_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions183.htm">STATS_BINOMIAL_TEST is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small.
This function takes four arguments: expr1 is the sample being examined. expr2 contains the values for which the proportion is expected to be, and p is a proportion to test against. The fourth argument is a return value of type VARCHAR2. If you omit the fourth argument, then the default is TWO_SIDED_PROB. The meaning of the return values is shown in Table 7-3.</Function>
  <Function Name="STATS_CROSSTAB" Url="http://docs.oracle.com/database/121/SQLRF/functions184.htm">Crosstabulation (commonly called crosstab) is a method used to analyze two nominal variables. The STATS_CROSSTAB function takes three arguments: two expressions and a return value of type VARCHAR2. expr1 and expr2 are the two variables being analyzed. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is CHISQ_SIG. The meaning of the return values is shown in Table 7-4.</Function>
  <Function Name="STATS_F_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions185.htm">STATS_F_TEST tests whether two variances are significantly different. The observed value of f is the ratio of one variance to the other, so values very different from 1 usually indicate significant differences.
This function takes three arguments: expr1 is the grouping or independent variable and expr2 is the sample of values. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is TWO_SIDED_SIG. The meaning of the return values is shown in Table 7-5.</Function>
  <Function Name="STATS_KS_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions186.htm">STATS_KS_TEST is a Kolmogorov-Smirnov function that compares two samples to test whether they are from the same population or from populations that have the same distribution. It does not assume that the population from which the samples were taken is normally distributed.
This function takes three arguments: two expressions and a return value of type VARCHAR2. expr1 classifies the data into the two samples. expr2 contains the values for each of the samples. If expr1 classifies the rows into only one sample or into more than two samples, then an error is raised.The function returns one value determined by the third argument. If you omit the third argument, then the default is SIG. The meaning of the return values is shown in Table 7-6.</Function>
  <Function Name="STATS_MODE" Url="http://docs.oracle.com/database/121/SQLRF/functions187.htm">STATS_MODE takes as its argument a set of values and returns the value that occurs with the greatest frequency. If more than one mode exists, then Oracle Database chooses one and returns only that one value.
To obtain multiple modes (if multiple modes exist), you must use a combination of other functions, as shown in the hypothetical query:</Function>
  <Function Name="STATS_ONE_WAY_ANOVA" Url="http://docs.oracle.com/database/121/SQLRF/functions189.htm">The one-way analysis of variance function (STATS_ONE_WAY_ANOVA) tests differences in means (for groups or variables) for statistical significance by comparing two different estimates of variance. One estimate is based on the variances within each group or category. This is known as the mean squares within or mean square error. The other estimate is based on the variances among the means of the groups. This is known as the mean squares between. If the means of the groups are significantly different, then the mean squares between will be larger than expected and will not match the mean squares within. If the mean squares of the groups are consistent, then the two variance estimates will be about the same.
STATS_ONE_WAY_ANOVA takes three arguments: two expressions and a return value of type VARCHAR2. expr1 is an independent or grouping variable that divides the data into a set of groups. expr2 is a dependent variable (a numeric expression) containing the values corresponding to each member of a group. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is SIG. The meaning of the return values is shown in Table 7-8.</Function>
  <Function Name="STATS_T_TEST_" Url="http://docs.oracle.com/database/121/SQLRF/functions190.htm">The t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample STATS_T_TEST_* functions take three arguments: two expressions and a return value of type VARCHAR2. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is TWO_SIDED_SIG. The meaning of the return values is shown in Table 7-9.</Function>
  <Function Name="STATS_WSR_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions191.htm">STATS_WSR_TEST is a Wilcoxon Signed Ranks test of paired samples to determine whether the median of the differences between the samples is significantly different from zero. The absolute values of the differences are ordered and assigned ranks. Then the null hypothesis states that the sum of the ranks of the positive differences is equal to the sum of the ranks of the negative differences.
This function takes three arguments: expr1 and expr2 are the two samples being analyzed, and the third argument is a return value of type VARCHAR2. If you omit the third argument, then the default is TWO_SIDED_SIG. The meaning of the return values is shown in Table 7-10.</Function>
  <Function Name="STDDEV" Url="http://docs.oracle.com/database/121/SQLRF/functions192.htm">STDDEV returns the sample standard deviation of expr, a set of numbers. You can use it as both an aggregate and analytic function. It differs from STDDEV_SAMP in that STDDEV returns zero when it has only 1 row of input data, whereas STDDEV_SAMP returns null.
Oracle Database calculates the standard deviation as the square root of the variance defined for the VARIANCE aggregate function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="STDDEV_POP" Url="http://docs.oracle.com/database/121/SQLRF/functions193.htm">STDDEV_POP computes the population standard deviation and returns the square root of the population variance. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="STDDEV_SAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions194.htm">STDDEV_SAMP computes the cumulative sample standard deviation and returns the square root of the sample variance. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="SUBSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions195.htm">The SUBSTR functions return a portion of char, beginning at character position, substring_length characters long. SUBSTR calculates lengths using characters as defined by the input character set. SUBSTRB uses bytes instead of characters. SUBSTRC uses Unicode complete characters. SUBSTR2 uses UCS2 code points. SUBSTR4 uses UCS4 code points.</Function>
  <Function Name="SUM" Url="http://docs.oracle.com/database/121/SQLRF/functions196.htm">SUM returns the sum of values of expr. You can use it as an aggregate or analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="SYS_CONNECT_BY_PATH" Url="http://docs.oracle.com/database/121/SQLRF/functions197.htm">SYS_CONNECT_BY_PATH is valid only in hierarchical queries. It returns the path of a column value from root to node, with column values separated by char for each row returned by CONNECT BY condition.
Both column and char can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The string returned is of VARCHAR2 data type and is in the same character set as column.</Function>
  <Function Name="SYS_CONTEXT" Url="http://docs.oracle.com/database/121/SQLRF/functions198.htm">SYS_CONTEXT returns the value of parameter associated with the context namespace at the current instant. You can use this function in both SQL and PL/SQL statements. SYS_CONTEXT must be executed locally.
For namespace and parameter, you can specify either a string or an expression that resolves to a string designating a namespace or an attribute. If you specify literal arguments for namespace and parameter, and you are using SYS_CONTEXT explicitly in a SQL statement—rather than in a PL/SQL function that in turn is in mentioned in a SQL statement—then Oracle Database evaluates SYS_CONTEXT only once per SQL statement execution for each call site that invokes the SYS_CONTEXT function.
The context namespace must already have been created, and the associated parameter and its value must also have been set using the DBMS_SESSION.set_context procedure. The namespace must be a valid SQL identifier. The parameter name can be any string. It is not case sensitive, but it cannot exceed 30 bytes in length.
The data type of the return value is VARCHAR2. The default maximum size of the return value is 256 bytes. You can override this default by specifying the optional length parameter, which must be a NUMBER or a value that can be implicitly converted to NUMBER. The valid range of values is 1 to 4000 bytes. If you specify an invalid value, then Oracle Database ignores it and uses the default.
Oracle provides the following built-in namespaces:</Function>
  <Function Name="SYS_DBURIGEN" Url="http://docs.oracle.com/database/121/SQLRF/functions199.htm">SYS_DBURIGEN takes as its argument one or more columns or attributes, and optionally a rowid, and generates a URL of data type DBURIType to a particular column or row object. You can then use the URL to retrieve an XML document from the database.
All columns or attributes referenced must reside in the same table. They must perform the function of a primary key. They need not actually match the primary key of the table, but they must reference a unique value. If you specify multiple columns, then all but the final column identify the row in the database, and the last column specified identifies the column within the row.
By default the URL points to a formatted XML document. If you want the URL to point only to the text of the document, then specify the optional 'text()'.</Function>
  <Function Name="SYS_EXTRACT_UTC" Url="http://docs.oracle.com/database/121/SQLRF/functions200.htm">SYS_EXTRACT_UTC extracts the UTC (Coordinated Universal Time—formerly Greenwich Mean Time) from a datetime value with time zone offset or time zone region name. If a time zone is not specified, then the datetime is associated with the session time zone.</Function>
  <Function Name="SYS_GUID" Url="http://docs.oracle.com/database/121/SQLRF/functions201.htm">SYS_GUID generates and returns a globally unique identifier (RAW value) made up of 16 bytes. On most platforms, the generated identifier consists of a host identifier, a process or thread identifier of the process or thread invoking the function, and a nonrepeating value (sequence of bytes) for that process or thread.</Function>
  <Function Name="SYS_OP_ZONE_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions202.htm">SYS_OP_ZONE_ID takes as its argument a rowid and returns a zone ID. The rowid identifies a row in a table. The zone ID identifies the set of contiguous disk blocks, called the zone, that contains the row. The function returns a NUMBER value.
The SYS_OP_ZONE_ID function is used when creating a zone map with the CREATE MATERIALIZED ZONEMAP statement. You must specify SYS_OP_ZONE_ID in the SELECT and GROUP BY clauses of the defining subquery of the zone map.
For rowid, specify the ROWID pseudocolumn of the fact table of the zone map.
Use schema and table to specify the schema and name of the fact table, or t_alias to specify the table alias for the fact table. The specification of these parameters depends on the FROM clause in the defining subquery of the zone map:</Function>
  <Function Name="SYS_TYPEID" Url="http://docs.oracle.com/database/121/SQLRF/functions203.htm">SYS_TYPEID returns the typeid of the most specific type of the operand. This value is used primarily to identify the type-discriminant column underlying a substitutable column. For example, you can use the value returned by SYS_TYPEID to build an index on the type-discriminant column.
You can use this function only on object type operands. All final root object types—final types not belonging to a type hierarchy—have a null typeid. Oracle Database assigns to all types belonging to a type hierarchy a unique non-null typeid.</Function>
  <Function Name="SYS_XMLAGG" Url="http://docs.oracle.com/database/121/SQLRF/functions204.htm">SYS_XMLAGG aggregates all of the XML documents or fragments represented by expr and produces a single XML document. It adds a new enclosing element with a default name ROWSET. If you want to format the XML document differently, then specify fmt, which is an instance of the XMLFormat object.</Function>
  <Function Name="SYS_XMLGEN" Url="http://docs.oracle.com/database/121/SQLRF/functions205.htm">SYS_XMLGEN takes an expression that evaluates to a particular row and column of the database, and returns an instance of type XMLType containing an XML document. The expr can be a scalar value, a user-defined type, or an XMLType instance.</Function>
  <Function Name="SYSDATE" Url="http://docs.oracle.com/database/121/SQLRF/functions206.htm">SYSDATE returns the current date and time set for the operating system on which the database server resides. The data type of the returned value is DATE, and the format returned depends on the value of the NLS_DATE_FORMAT initialization parameter. The function requires no arguments. In distributed SQL statements, this function returns the date and time set for the operating system of your local database. You cannot use this function in the condition of a CHECK constraint.</Function>
  <Function Name="SYSTIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions207.htm">SYSTIMESTAMP returns the system date, including fractional seconds and time zone, of the system on which the database resides. The return type is TIMESTAMP WITH TIME ZONE.</Function>
  <Function Name="TAN" Url="http://docs.oracle.com/database/121/SQLRF/functions208.htm">TAN returns the tangent of n (an angle expressed in radians).
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="TANH" Url="http://docs.oracle.com/database/121/SQLRF/functions209.htm">TANH returns the hyperbolic tangent of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
  <Function Name="TIMESTAMP_TO_SCN" Url="http://docs.oracle.com/database/121/SQLRF/functions210.htm">TIMESTAMP_TO_SCN takes as an argument a timestamp value and returns the approximate system change number (SCN) associated with that timestamp. The returned value is of data type NUMBER. This function is useful any time you want to know the SCN associated with a particular timestamp.</Function>
  <Function Name="TO_BINARY_DOUBLE" Url="http://docs.oracle.com/database/121/SQLRF/functions211.htm">TO_BINARY_DOUBLE returns a double-precision floating-point number.</Function>
  <Function Name="TO_BINARY_FLOAT" Url="http://docs.oracle.com/database/121/SQLRF/functions212.htm">TO_BINARY_FLOAT returns a single-precision floating-point number.</Function>
  <Function Name="TO_BLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions213.htm">TO_BLOB converts LONG RAW and RAW values to BLOB values.
From within a PL/SQL package, you can use TO_BLOB to convert RAW and BLOB values to BLOB.</Function>
  <Function Name="TO_CHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions214.htm">TO_CHAR (character) converts NCHAR, NVARCHAR2, CLOB, or NCLOB data to the database character set. The value returned is always VARCHAR2.
When you use this function to convert a character LOB into the database character set, if the LOB value to be converted is larger than the target type, then the database returns an error.
You can use this function in conjunction with any of the XML functions to generate a date in the database format rather than the XML Schema standard format.</Function>
  <Function Name="TO_CHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions215.htm">TO_CHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL DAY TO SECOND, or INTERVAL YEAR TO MONTH data type to a value of VARCHAR2 data type in the format specified by the date format fmt. If you omit fmt, then date is converted to a VARCHAR2 value as follows:</Function>
  <Function Name="TO_CHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions216.htm">TO_CHAR (number) converts n to a value of VARCHAR2 data type, using the optional number format fmt. The value n can be of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. If you omit fmt, then n is converted to a VARCHAR2 value exactly long enough to hold its significant digits.
If n is negative, then the sign is applied after the format is applied. Thus TO_CHAR(-1, '$9') returns -$1, rather than $-1.
Refer to "Format Models" for information on number formats.
The 'nlsparam' argument specifies these characters that are returned by number format elements:</Function>
  <Function Name="TO_CLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions217.htm">TO_CLOB converts NCLOB values in a LOB column or other character strings to CLOB values. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. Oracle Database executes this function by converting the underlying LOB data from the national character set to the database character set.
From within a PL/SQL package, you can use the TO_CLOB function to convert RAW, CHAR, VARCHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB values to CLOB or NCLOB values.</Function>
  <Function Name="TO_DATE" Url="http://docs.oracle.com/database/121/SQLRF/functions218.htm">TO_DATE converts char of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to a value of DATE data type.</Function>
  <Function Name="TO_DSINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions219.htm">TO_DSINTERVAL converts a character string of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to an INTERVAL DAY TO SECOND type.
TO_DSINTERVAL accepts argument in one of the two formats:</Function>
  <Function Name="TO_LOB" Url="http://docs.oracle.com/database/121/SQLRF/functions220.htm">TO_LOB converts LONG or LONG RAW values in the column long_column to LOB values. You can apply this function only to a LONG or LONG RAW column, and only in the select list of a subquery in an INSERT statement.
Before using this function, you must create a LOB column to receive the converted LONG values. To convert LONG values, create a CLOB column. To convert LONG RAW values, create a BLOB column.
You cannot use the TO_LOB function to convert a LONG column to a LOB column in the subquery of a CREATE TABLE ... AS SELECT statement if you are creating an index-organized table. Instead, create the index-organized table without the LONG column, and then use the TO_LOB function in an INSERT ... AS SELECT statement.
You cannot use this function within a PL/SQL package. Instead use the TO_CLOB or TO_BLOB functions.</Function>
  <Function Name="TO_MULTI_BYTE" Url="http://docs.oracle.com/database/121/SQLRF/functions221.htm">TO_MULTI_BYTE returns char with all of its single-byte characters converted to their corresponding multibyte characters. char can be of data type CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The value returned is in the same data type as char.
Any single-byte characters in char that have no multibyte equivalents appear in the output string as single-byte characters. This function is useful only if your database character set contains both single-byte and multibyte characters.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="TO_NCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions222.htm">TO_NCHAR (character) converts a character string, CHAR, VARCHAR2, CLOB, or NCLOB value to the national character set. The value returned is always NVARCHAR2. This function is equivalent to the TRANSLATE ... USING function with a USING clause in the national character set.</Function>
  <Function Name="TO_NCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions223.htm">TO_NCHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL MONTH TO YEAR, or INTERVAL DAY TO SECOND data type from the database character set to the national character set.</Function>
  <Function Name="TO_NCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions224.htm">TO_NCHAR (number) converts n to a string in the national character set. The value n can be of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. The function returns a value of the same type as the argument. The optional fmt and 'nlsparam' corresponding to n can be of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL MONTH TO YEAR, or INTERVAL DAY TO SECOND data type.</Function>
  <Function Name="TO_NCLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions225.htm">TO_NCLOB converts CLOB values in a LOB column or other character strings to NCLOB values. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. Oracle Database implements this function by converting the character set of char from the database character set to the national character set.</Function>
  <Function Name="TO_NUMBER" Url="http://docs.oracle.com/database/121/SQLRF/functions226.htm">TO_NUMBER converts expr to a value of NUMBER data type. The expr can be a BINARY_DOUBLE value or a value of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type containing a number in the format specified by the optional format model fmt.
You can specify an expr of BINARY_FLOAT. However, it makes no sense to do so because a float can be interpreted only by its internal presentation.
Refer to "Format Models" for information on number formats.
The 'nlsparam' argument in this function has the same purpose as it does in the TO_CHAR function for number conversions. Refer to TO_CHAR (number) for more information.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="TO_SINGLE_BYTE" Url="http://docs.oracle.com/database/121/SQLRF/functions227.htm">TO_SINGLE_BYTE returns char with all of its multibyte characters converted to their corresponding single-byte characters. char can be of data type CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The value returned is in the same data type as char.
Any multibyte characters in char that have no single-byte equivalents appear in the output as multibyte characters. This function is useful only if your database character set contains both single-byte and multibyte characters.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="TO_YMINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions230.htm">TO_YMINTERVAL converts a character string of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to an INTERVAL YEAR TO MONTH type.
TO_YMINTERVAL accepts argument in one of the two formats:</Function>
  <Function Name="TRANSLATE" Url="http://docs.oracle.com/database/121/SQLRF/functions231.htm">TRANSLATE returns expr with all occurrences of each character in from_string replaced by its corresponding character in to_string. Characters in expr that are not in from_string are not replaced. The argument from_string can contain more characters than to_string. In this case, the extra characters at the end of from_string have no corresponding characters in to_string. If these extra characters appear in expr, then they are removed from the return value.
If a character appears multiple times in from_string, then the to_string mapping corresponding to the first occurrence is used.
You cannot use an empty string for to_string to remove all characters in from_string from the return value. Oracle Database interprets the empty string as null, and if this function has a null argument, then it returns null. To remove all characters in from_string, concatenate another character to the beginning of from_string and specify this character as the to_string. For example, TRANSLATE(expr, 'x0123456789', 'x') removes all digits from expr.
TRANSLATE provides functionality related to that provided by the REPLACE function. REPLACE lets you substitute a single string for another single string, as well as remove character strings. TRANSLATE lets you make several single-character, one-to-one substitutions in one operation.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="TRANSLATE" Url="http://docs.oracle.com/database/121/SQLRF/functions232.htm">TRANSLATE ... USING converts char into the character set specified for conversions between the database character set and the national character set.</Function>
  <Function Name="TREAT" Url="http://docs.oracle.com/database/121/SQLRF/functions233.htm">TREAT changes the declared type of an expression.
You must have the EXECUTE object privilege on type to use this function.</Function>
  <Function Name="TRIM" Url="http://docs.oracle.com/database/121/SQLRF/functions234.htm">TRIM enables you to trim leading or trailing characters (or both) from a character string. If trim_character or trim_source is a character literal, then you must enclose it in single quotation marks.</Function>
  <Function Name="TRUNC" Url="http://docs.oracle.com/database/121/SQLRF/functions235.htm">The TRUNC (date) function returns date with the time portion of the day truncated to the unit specified by the format model fmt. This function is not sensitive to the NLS_CALENDAR session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type DATE, even if you specify a different datetime data type for date. If you omit fmt, then the default format model 'DD' is used and the value returned is date truncated to the day with a time of midnight. Refer to "ROUND and TRUNC Date Functions" for the permitted format models to use in fmt.</Function>
  <Function Name="TRUNC" Url="http://docs.oracle.com/database/121/SQLRF/functions236.htm">The TRUNC (number) function returns n1 truncated to n2 decimal places. If n2 is omitted, then n1 is truncated to 0 places. n2 can be negative to truncate (make zero) n2 digits left of the decimal point.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit n2, then the function returns the same data type as the numeric data type of the argument. If you include n2, then the function returns NUMBER.</Function>
  <Function Name="TZ_OFFSET" Url="http://docs.oracle.com/database/121/SQLRF/functions237.htm">TZ_OFFSET returns the time zone offset corresponding to the argument based on the date the statement is executed. You can enter a valid time zone region name, a time zone offset from UTC (which simply returns itself), or the keyword SESSIONTIMEZONE or DBTIMEZONE. For a listing of valid values for time_zone_name, query the TZNAME column of the V$TIMEZONE_NAMES dynamic performance view.</Function>
  <Function Name="UID" Url="http://docs.oracle.com/database/121/SQLRF/functions238.htm">UID returns an integer that uniquely identifies the session user (the user who logged on).</Function>
  <Function Name="UNISTR" Url="http://docs.oracle.com/database/121/SQLRF/functions239.htm">UNISTR takes as its argument a text literal or an expression that resolves to character data and returns it in the national character set. The national character set of the database can be either AL16UTF16 or UTF8. UNISTR provides support for Unicode string literals by letting you specify the Unicode encoding value of characters in the string. This is useful, for example, for inserting data into NCHAR columns.
The Unicode encoding value has the form '\xxxx' where 'xxxx' is the hexadecimal value of a character in UCS-2 encoding format. Supplementary characters are encoded as two code units, the first from the high-surrogates range (U+D800 to U+DBFF), and the second from the low-surrogates range (U+DC00 to U+DFFF). To include the backslash in the string itself, precede it with another backslash (\\).
For portability and data preservation, Oracle recommends that in the UNISTR string argument you specify only ASCII characters and the Unicode encoding values.</Function>
  <Function Name="UPDATEXML" Url="http://docs.oracle.com/database/121/SQLRF/functions240.htm">UPDATEXML takes as arguments an XMLType instance and an XPath-value pair and returns an XMLType instance with the updated value. If XPath_string is an XML element, then the corresponding value_expr must be an XMLType instance. If XPath_string is an attribute or text node, then the value_expr can be any scalar data type. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node.
The data types of the target of each XPath_string and its corresponding value_expr must match. The optional namespace_string must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).
If you update an XML element to null, then Oracle removes the attributes and children of the element, and the element becomes empty. If you update the text node of an element to null, Oracle removes the text value of the element, and the element itself remains but is empty.
In most cases, this function materializes an XML document in memory and updates the value. However, UPDATEXML is optimized for UPDATE statements on object-relational columns so that the function updates the value directly in the column. This optimization requires the following conditions:</Function>
  <Function Name="UPPER" Url="http://docs.oracle.com/database/121/SQLRF/functions241.htm">UPPER returns char, with all letters uppercase. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The return value is the same data type as char. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase, refer to NLS_UPPER.</Function>
  <Function Name="USER" Url="http://docs.oracle.com/database/121/SQLRF/functions242.htm">USER returns the name of the session user (the user who logged on). This may change during the duration of a database session as Real Application Security sessions are attached or detached. For enterprise users, this function returns the schema. For other users, it returns the database user name. If a Real Application Security session is currently attached to the database session, then it returns user XS$NULL.
This function returns a VARCHAR2 value.
Oracle Database compares values of this function with blank-padded comparison semantics.
In a distributed SQL statement, the UID and USER functions together identify the user on your local database. You cannot use these functions in the condition of a CHECK constraint.</Function>
  <Function Name="VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions244.htm">VALUE takes as its argument a correlation variable (table alias) associated with a row of an object table and returns object instances stored in the object table. The type of the object instances is the same type as the object table.</Function>
  <Function Name="VAR_POP" Url="http://docs.oracle.com/database/121/SQLRF/functions245.htm">VAR_POP returns the population variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="VAR_SAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions246.htm">VAR_SAMP returns the sample variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
  <Function Name="VARIANCE" Url="http://docs.oracle.com/database/121/SQLRF/functions247.htm">VARIANCE returns the variance of expr. You can use it as an aggregate or analytic function.
Oracle Database calculates the variance of expr as follows:</Function>
  <Function Name="WIDTH_BUCKET" Url="http://docs.oracle.com/database/121/SQLRF/functions249.htm">WIDTH_BUCKET lets you construct equiwidth histograms, in which the histogram range is divided into intervals that have identical size. (Compare this function with NTILE, which creates equiheight histograms.) Ideally each bucket is a closed-open interval of the real number line. For example, a bucket can be assigned to scores between 10.00 and 19.999 ... to indicate that 10 is included in the interval and 20 is excluded. This is sometimes denoted [10, 20).
For a given expression, WIDTH_BUCKET returns the bucket number into which the value of this expression would fall after being evaluated.</Function>
  <Function Name="VSIZE" Url="http://docs.oracle.com/database/121/SQLRF/functions248.htm">VSIZE returns the number of bytes in the internal representation of expr. If expr is null, then this function returns null.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
  <Function Name="XMLAGG" Url="http://docs.oracle.com/database/121/SQLRF/functions250.htm">XMLAGG is an aggregate function. It takes a collection of XML fragments and returns an aggregated XML document. Any arguments that return null are dropped from the result.
XMLAgg is similar to SYS_XMLAgg except that XMLAgg returns a collection of nodes but it does not accept formatting using the XMLFormat object. Also, XMLAgg does not enclose the output in an element tag as does SYS_XMLAgg.
Within the order_by_clause, Oracle Database does not interpret number literals as column positions, as it does in other uses of this clause, but simply as number literals.</Function>
  <Function Name="XMLCAST" Url="http://docs.oracle.com/database/121/SQLRF/functions251.htm">XMLCAST casts value_expression to the scalar SQL data type specified by datatype. The value_expression argument is a SQL expression that is evaluated. The datatype argument can be of data type NUMBER, VARCHAR2, CHAR, CLOB, BLOB, REF XMLTYPE, and any of the datetime data types.</Function>
  <Function Name="XMLCDATA" Url="http://docs.oracle.com/database/121/SQLRF/functions252.htm">XMLCDATA generates a CDATA section by evaluating value_expr. The value_expr must resolve to a string. The value returned by the function takes the following form:</Function>
  <Function Name="XMLCOLATTVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions253.htm">XMLCOLATTVAL creates an XML fragment and then expands the resulting XML so that each XML fragment has the name column with the attribute name.
You can use the AS clause to change the value of the name attribute to something other than the column name. You can do this by specifying c_alias, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the alias. The alias can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED. See "Extended Data Types" for more information.
You must specify a value for value_expr. If value_expr is null, then no element is returned.</Function>
  <Function Name="XMLCOMMENT" Url="http://docs.oracle.com/database/121/SQLRF/functions254.htm">XMLCOMMENT generates an XML comment using an evaluated result of value_expr. The value_expr must resolve to a string. It cannot contain two consecutive dashes (hyphens). The value returned by the function takes the following form:</Function>
  <Function Name="XMLCONCAT" Url="http://docs.oracle.com/database/121/SQLRF/functions255.htm">XMLCONCAT takes as input a series of XMLType instances, concatenates the series of elements for each row, and returns the concatenated series. XMLConcat is the inverse of XMLSequence.
Null expressions are dropped from the result. If all the value expressions are null, then the function returns null.</Function>
  <Function Name="XMLDIFF" Url="http://docs.oracle.com/database/121/SQLRF/functions256.htm">The XMLDIFF function is the SQL interface for the XmlDiff C API. This function compares two XML documents and captures the differences in XML conforming to an Xdiff schema. The diff document is returned as an XMLType document.</Function>
  <Function Name="XMLELEMENT" Url="http://docs.oracle.com/database/121/SQLRF/functions257.htm">XMLELEMENT takes an element name for identifier or evaluates an element name for EVALNAME value_expr, an optional collection of attributes for the element, and arguments that make up the content of the element. It returns an instance of type XMLType. XMLElement is similar to SYS_XMLGen except that XMLElement can include attributes in the XML returned, but it does not accept formatting using the XMLFormat object.
The XMLElement function is typically nested to produce an XML document with a nested structure, as in the example in the following section.
For an explanation of the ENTITYESCAPING and NONENTITYESCAPING keywords, refer to Oracle XML DB Developer's Guide.
You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying identifier, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier does not have to be a column name or column reference. It cannot be an expression or null. It can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED.
The objects that make up the element content follow the XMLATTRIBUTES keyword. In the XML_attributes_clause, if the value_expr is null, then no attribute is created for that value expression. The type of value_expr cannot be an object type or collection. If you specify an alias for value_expr using the AS clause, then the c_alias or the evaluated value expression (EVALNAME value_expr) can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED.</Function>
  <Function Name="XMLEXISTS" Url="http://docs.oracle.com/database/121/SQLRF/functions258.htm">XMLEXISTS checks whether a given XQuery expression returns a nonempty XQuery sequence. If so, the function returns TRUE; otherwise, it returns FALSE. The argument XQuery_string is a literal string, but it can contain XQuery variables that you bind using the XML_passing_clause.
The expr in the XML_passing_clause is an expression returning an XMLType or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one expr in the PASSING clause without an identifier. The result of evaluating each expr is bound to the corresponding identifier in the XQuery_string. If any expr that is not followed by an AS clause, then the result of evaluating that expression is used as the context item for evaluating the XQuery_string.</Function>
  <Function Name="XMLFOREST" Url="http://docs.oracle.com/database/121/SQLRF/functions259.htm">XMLFOREST converts each of its argument parameters to XML, and then returns an XML fragment that is the concatenation of these converted arguments.</Function>
  <Function Name="XMLISVALID" Url="http://docs.oracle.com/database/121/SQLRF/functions260.htm">XMLISVALID checks whether the input XMLType_instance conforms to the relevant XML schema. It does not change the validation status recorded for XMLType_instance.
If the input XML document is determined to be valid, then XMLISVALID returns 1; otherwise, it returns 0. If you provide XMLSchema_URL as an argument, then that is used to check conformance. Otherwise, the XML schema specified by the XML document is used to check conformance.</Function>
  <Function Name="XMLPARSE" Url="http://docs.oracle.com/database/121/SQLRF/functions261.htm">XMLPARSE parses and generates an XML instance from the evaluated result of value_expr. The value_expr must resolve to a string. If value_expr resolves to null, then the function returns null.</Function>
  <Function Name="XMLPATCH" Url="http://docs.oracle.com/database/121/SQLRF/functions262.htm">The XMLPATCH function is the SQL interface for the XmlPatch C API. This function patches an XML document with the changes specified. A patched XMLType document is returned.</Function>
  <Function Name="XMLPI" Url="http://docs.oracle.com/database/121/SQLRF/functions263.htm">XMLPI generates an XML processing instruction using identifier and optionally the evaluated result of value_expr. A processing instruction is commonly used to provide to an application information that is associated with all or part of an XML document. The application uses the processing instruction to determine how best to process the XML document.
You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying identifier, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier does not have to be a column name or column reference. It cannot be an expression or null. It can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED. See "Extended Data Types" for more information.
The optional value_expr must resolve to a string. If you omit the optional value_expr, then a zero-length string is the default. The value returned by the function takes this form:</Function>
  <Function Name="XMLQUERY" Url="http://docs.oracle.com/database/121/SQLRF/functions264.htm">XMLQUERY lets you query XML data in SQL statements. It takes an XQuery expression as a string literal, an optional context item, and other bind variables and returns the result of evaluating the XQuery expression using these input values.</Function>
  <Function Name="XMLROOT" Url="http://docs.oracle.com/database/121/SQLRF/functions265.htm">XMLROOT lets you create a new XML value by providing version and standalone properties in the XML root information (prolog) of an existing XML value. If the value_expr already has a prolog, then the database returns an error. If the input is null, then the function returns null.
The value returned takes the following form:</Function>
  <Function Name="XMLSEQUENCE" Url="http://docs.oracle.com/database/121/SQLRF/functions266.htm">XMLSEQUENCE has two forms:</Function>
  <Function Name="XMLSERIALIZE" Url="http://docs.oracle.com/database/121/SQLRF/functions267.htm">XMLSERIALIZE creates a string or LOB containing the contents of value_expr.</Function>
  <Function Name="XMLTABLE" Url="http://docs.oracle.com/database/121/SQLRF/functions268.htm">XMLTABLE maps the result of an XQuery evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL.</Function>
  <Function Name="XMLTRANSFORM" Url="http://docs.oracle.com/database/121/SQLRF/functions269.htm">XMLTRANSFORM takes as arguments an XMLType instance and an XSL style sheet, which is itself a form of XMLType instance. It applies the style sheet to the instance and returns an XMLType.
This function is useful for organizing data according to a style sheet as you are retrieving it from the database.</Function>
</Documentation>