<?xml version="1.0" encoding="utf-8"?>
<Documentation xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://husqvik.com/SqlPad/2014/02">
  <Functions>
    <Function Name="ABS" Url="http://docs.oracle.com/database/121/SQLRF/functions009.htm">ABS returns the absolute value of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="ACOS" Url="http://docs.oracle.com/database/121/SQLRF/functions010.htm">ACOS returns the arc cosine of n. The argument n must be in the range of -1 to 1, and the function returns a value in the range of 0 to pi, expressed in radians.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="ADD_MONTHS" Url="http://docs.oracle.com/database/121/SQLRF/functions011.htm">ADD_MONTHS returns the date date plus integer months. A month is defined by the session parameter NLS_CALENDAR. The date argument can be a datetime value or any value that can be implicitly converted to DATE. The integer argument can be an integer or any value that can be implicitly converted to an integer. The return type is always DATE, regardless of the data type of date. If date is the last day of the month or if the resulting month has fewer days than the day component of date, then the result is the last day of the resulting month. Otherwise, the result has the same day component as date.</Function>
    <Function Name="APPENDCHILDXML" Url="http://docs.oracle.com/database/121/SQLRF/functions012.htm">APPENDCHILDXML appends a user-supplied value onto the target XML as the child of the node indicated by an XPath expression.

XMLType_instance is an instance of XMLType.

XPath_string is an Xpath expression indicating one or more nodes onto which one or more child nodes are to be appended. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node.

value_expr specifies one or more nodes of XMLType. It must resolve to a string.

The optional namespace_string provides namespace information for the XPath_string. This parameter must be of type VARCHAR2.</Function>
    <Function Name="APPROX_COUNT_DISTINCT" Url="http://docs.oracle.com/database/121/SQLRF/functions013.htm">APPROX_COUNT_DISTINCT returns the approximate number of rows that contain distinct values of expr.
This function provides an alternative to the COUNT (DISTINCT expr) function, which returns the exact number of rows that contain distinct values of expr. APPROX_COUNT_DISTINCT processes large amounts of data significantly faster than COUNT, with negligible deviation from the exact result.
For expr, you can specify a column of any scalar data type other than BFILE, BLOB, CLOB, LONG, LONG RAW, or NCLOB.
APPROX_COUNT_DISTINCT ignores rows that contain a null value for expr. This function returns a NUMBER.</Function>
    <Function Name="ASCII" Url="http://docs.oracle.com/database/121/SQLRF/functions014.htm">ASCII returns the decimal representation in the database character set of the first character of char.
char can be of data type CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The value returned is of data type NUMBER. If your database character set is 7-bit ASCII, then this function returns an ASCII value. If your database character set is EBCDIC Code, then this function returns an EBCDIC value. There is no corresponding EBCDIC character function.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="ASCIISTR" Url="http://docs.oracle.com/database/121/SQLRF/functions015.htm">ASCIISTR takes as its argument a string, or an expression that resolves to a string, in any character set and returns an ASCII version of the string in the database character set. Non-ASCII characters are converted to the form \xxxx, where xxxx represents a UTF-16 code unit.</Function>
    <Function Name="ASIN" Url="http://docs.oracle.com/database/121/SQLRF/functions016.htm">ASIN returns the arc sine of n. The argument n must be in the range of -1 to 1, and the function returns a value in the range of -pi/2 to pi/2, expressed in radians.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="ATAN" Url="http://docs.oracle.com/database/121/SQLRF/functions017.htm">ATAN returns the arc tangent of n. The argument n can be in an unbounded range and returns a value in the range of -pi/2 to pi/2, expressed in radians.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="ATAN2" Url="http://docs.oracle.com/database/121/SQLRF/functions018.htm">ATAN2 returns the arc tangent of n1 and n2. The argument n1 can be in an unbounded range and returns a value in the range of -pi to pi, depending on the signs of n1 and n2, expressed in radians.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is BINARY_FLOAT or BINARY_DOUBLE, then the function returns BINARY_DOUBLE. Otherwise the function returns NUMBER.</Function>
    <Function Name="AVG" Url="http://docs.oracle.com/database/121/SQLRF/functions019.htm">AVG returns average value of expr.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="BFILENAME" Url="http://docs.oracle.com/database/121/SQLRF/functions020.htm">BFILENAME returns a BFILE locator that is associated with a physical LOB binary file on the server file system.

'directory' is a database object that serves as an alias for a full path name on the server file system where the files are actually located.

'filename' is the name of the file in the server file system.

You must create the directory object and associate a BFILE value with a physical file before you can use them as arguments to BFILENAME in a SQL or PL/SQL statement, DBMS_LOB package, or OCI operation.
You can use this function in two ways:

In a DML statement to initialize a BFILE column

In a programmatic interface to access BFILE data by assigning a value to the BFILE locator

The directory argument is case sensitive. You must ensure that you specify the directory object name exactly as it exists in the data dictionary. For example, if an "Admin" directory object was created using mixed case and a quoted identifier in the CREATE DIRECTORY statement, then when using the BFILENAME function you must refer to the directory object as 'Admin'. You must specify the filename argument according to the case and punctuation conventions for your operating system.</Function>
    <Function Name="BIN_TO_NUM" Url="http://docs.oracle.com/database/121/SQLRF/functions021.htm">BIN_TO_NUM converts a bit vector to its equivalent number. Each argument to this function represents a bit in the bit vector. This function takes as arguments any numeric data type, or any nonnumeric data type that can be implicitly converted to NUMBER. Each expr must evaluate to 0 or 1. This function returns Oracle NUMBER.
BIN_TO_NUM is useful in data warehousing applications for selecting groups of interest from a materialized view using grouping sets.</Function>
    <Function Name="BITAND" Url="http://docs.oracle.com/database/121/SQLRF/functions022.htm">The BITAND function treats its inputs and its output as vectors of bits; the output is the bitwise AND of the inputs.
The types of expr1 and expr2 are NUMBER, and the result is of type NUMBER. If either argument to BITAND is NULL, the result is NULL.
The arguments must be in the range -(2(n-1)) .. ((2(n-1))-1). If an argument is out of this range, the result is undefined.
The result is computed in several steps. First, each argument A is replaced with the value SIGN(A)*FLOOR(ABS(A)). This conversion has the effect of truncating each argument towards zero. Next, each argument A (which must now be an integer value) is converted to an n-bit two's complement binary integer value. The two bit values are combined using a bitwise AND operation. Finally, the resulting n-bit two's complement value is converted back to NUMBER.

Notes on the BITAND Function

The current implementation of BITAND defines n = 128.

PL/SQL supports an overload of BITAND for which the types of the inputs and of the result are all BINARY_INTEGER and for which n = 32.</Function>
    <Function Name="CARDINALITY" Url="http://docs.oracle.com/database/121/SQLRF/functions023.htm">CARDINALITY returns the number of elements in a nested table. The return type is NUMBER. If the nested table is empty, or is a null collection, then CARDINALITY returns NULL.</Function>
    <Function Name="CAST" Url="http://docs.oracle.com/database/121/SQLRF/functions024.htm">CAST converts one built-in data type or collection-typed value into another built-in data type or collection-typed value.
CAST lets you convert built-in data types or collection-typed values of one type into another built-in data type or collection type. You can cast an unnamed operand (such as a date or the result set of a subquery) or a named collection (such as a varray or a nested table) into a type-compatible data type or named collection. The type_name must be the name of a built-in data type or collection type and the operand must be a built-in data type or must evaluate to a collection value.
For the operand, expr can be either a built-in data type, a collection type, or an instance of an ANYDATA type. If expr is an instance of an ANYDATA type, then CAST tries to extract the value of the ANYDATA instance and return it if it matches the cast target type, otherwise, null will be returned. MULTISET informs Oracle Database to take the result set of the subquery and return a collection value. Table 7-1 shows which built-in data types can be cast into which other built-in data types. (CAST does not support LONG, LONG RAW, or the Oracle-supplied types.)
CAST does not directly support any of the LOB data types. When you use CAST to convert a CLOB value into a character data type or a BLOB value into the RAW data type, the database implicitly converts the LOB value to character or raw data and then explicitly casts the resulting value into the target data type. If the resulting value is larger than the target type, then the database returns an error.
When you use CAST ... MULTISET to get a collection value, each select list item in the query passed to the CAST function is converted to the corresponding attribute type of the target collection element type.</Function>
    <Function Name="CEIL" Url="http://docs.oracle.com/database/121/SQLRF/functions025.htm">CEIL returns the smallest integer that is greater than or equal to n. The number n can always be written as the difference of an integer k and a positive fraction f such that 0 &lt;= f &lt; 1 and n = k - f. The value of CEIL is the integer k. Thus, the value of CEIL is n itself if and only if n is precisely an integer.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="CHARTOROWID" Url="http://docs.oracle.com/database/121/SQLRF/functions026.htm">CHARTOROWID converts a value from CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to ROWID data type.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="CHR" Url="http://docs.oracle.com/database/121/SQLRF/functions027.htm">CHR returns the character having the binary equivalent to n as a VARCHAR2 value in either the database character set or, if you specify USING NCHAR_CS, the national character set.
For single-byte character sets, if n &gt; 256, then Oracle Database returns the binary equivalent of n mod 256. For multibyte character sets, n must resolve to one entire code point. Invalid code points are not validated, and the result of specifying invalid code points is indeterminate.
This function takes as an argument a NUMBER value, or any value that can be implicitly converted to NUMBER, and returns a character.</Function>
    <Function Name="CLUSTER_DETAILS" Url="http://docs.oracle.com/database/121/SQLRF/functions028.htm">CLUSTER_DETAILS returns cluster details for each row in the selection. The return value is an XML string that describes the attributes of the highest probability cluster or the specified cluster_id.

topN
If you specify a value for topN, the function returns the N attributes that most influence the cluster assignment (the score). If you do not specify topN, the function returns the 5 most influential attributes.

DESC, ASC, or ABS
The returned attributes are ordered by weight. The weight of an attribute expresses its positive or negative impact on cluster assignment. A positive weight indicates an increased likelihood of assignment. A negative weight indicates a decreased likelihood of assignment.
By default, CLUSTER_DETAILS returns the attributes with the highest positive weights (DESC). If you specify ASC, the attributes with the highest negative weights are returned. If you specify ABS, the attributes with the greatest weights, whether negative or positive, are returned. The results are ordered by absolute value from highest to lowest. Attributes with a zero weight are not included in the output.

Syntax Choice
CLUSTER_DETAILS can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="CLUSTER_DISTANCE" Url="http://docs.oracle.com/database/121/SQLRF/functions029.htm">CLUSTER_DISTANCE returns a cluster distance for each row in the selection. The cluster distance is the distance between the row and the centroid of the highest probability cluster or the specified cluster_id. The distance is returned as BINARY_DOUBLE.

Syntax Choice
CLUSTER_DISTANCE can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, this data is also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="CLUSTER_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions030.htm">CLUSTER_ID returns the identifier of the highest probability cluster for each row in the selection. The cluster identifier is returned as an Oracle NUMBER.

Syntax Choice
CLUSTER_ID can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="CLUSTER_PROBABILITY" Url="http://docs.oracle.com/database/121/SQLRF/functions031.htm">CLUSTER_PROBABILITY returns a probability for each row in the selection. The probability refers to the highest probability cluster or to the specified cluster_id. The cluster probability is returned as BINARY_DOUBLE.

Syntax Choice
CLUSTER_PROBABILITY can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="CLUSTER_SET" Url="http://docs.oracle.com/database/121/SQLRF/functions032.htm">CLUSTER_SET returns a set of cluster ID and probability pairs for each row in the selection. The return value is a varray of objects with field names CLUSTER_ID and PROBABILITY. The cluster identifier is an Oracle NUMBER; the probability is BINARY_DOUBLE.

topN and cutoff
You can specify topN and cutoff to limit the number of clusters returned by the function. By default, both topN and cutoff are null and all clusters are returned.

topN is the N most probable clusters. If multiple clusters share the Nth probability, then the function chooses one of them.

cutoff is a probability threshold. Only clusters with probability greater than or equal to cutoff are returned. To filter by cutoff only, specify NULL for topN.

To return up to the N most probable clusters that are greater than or equal to cutoff, specify both topN and cutoff.

Syntax Choice
CLUSTER_SET can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="COALESCE" Url="http://docs.oracle.com/database/121/SQLRF/functions033.htm">COALESCE returns the first non-null expr in the expression list. You must specify at least two expressions. If all occurrences of expr evaluate to null, then the function returns null.
Oracle Database uses short-circuit evaluation. The database evaluates each expr value and determines whether it is NULL, rather than evaluating all of the expr values before determining whether any of them is NULL.
If all occurrences of expr are numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="COLLECT" Url="http://docs.oracle.com/database/121/SQLRF/functions034.htm">COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
If column is itself a collection, then the output of COLLECT is a nested table of collections. If column is of a user-defined type, then column must have a MAP or ORDER method defined on it in order for you to use the optional DISTINCT, UNIQUE, and ORDER BY clauses.</Function>
    <Function Name="COMPOSE" Url="http://docs.oracle.com/database/121/SQLRF/functions035.htm">COMPOSE takes as its argument a string, or an expression that resolves to a string, in any data type, and returns a Unicode string in the same character set as the input. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. For example, an o code point qualified by an umlaut code point will be returned as the o-umlaut code point.
COMPOSE returns the string in NFC normal form. For a more exclusive setting, you can first call DECOMPOSE with the CANONICAL setting and then COMPOSE. This combination returns the string in NFKC normal form.
CLOB and NCLOB values are supported through implicit conversion. If char is a character LOB value, then it is converted to a VARCHAR value before the COMPOSE operation. The operation will fail if the size of the LOB value exceeds the supported length of the VARCHAR in the particular development environment.</Function>
    <Function Name="CONCAT" Url="http://docs.oracle.com/database/121/SQLRF/functions040.htm">CONCAT returns char1 concatenated with char2. Both char1 and char2 can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is in the same character set as char1. Its data type depends on the data types of the arguments.
In concatenations of two different data types, Oracle Database returns the data type that results in a lossless conversion. Therefore, if one of the arguments is a LOB, then the returned value is a LOB. If one of the arguments is a national data type, then the returned value is a national data type. For example:

CONCAT(CLOB, NCLOB) returns NCLOB

CONCAT(NCLOB, NCHAR) returns NCLOB

CONCAT(NCLOB, CHAR) returns NCLOB

CONCAT(NCHAR, CLOB) returns NCLOB

This function is equivalent to the concatenation operator (||).</Function>
    <Function Name="CONVERT" Url="http://docs.oracle.com/database/121/SQLRF/functions041.htm">CONVERT converts a character string from one character set to another.

The char argument is the value to be converted. It can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

The dest_char_set argument is the name of the character set to which char is converted.

The source_char_set argument is the name of the character set in which char is stored in the database. The default value is the database character set.

The return value for CHAR and VARCHAR2 is VARCHAR2. For NCHAR and NVARCHAR2, it is NVARCHAR2. For CLOB, it is CLOB, and for NCLOB, it is NCLOB.
Both the destination and source character set arguments can be either literals or columns containing the name of the character set.
For complete correspondence in character conversion, it is essential that the destination character set contains a representation of all the characters defined in the source character set. Where a character does not exist in the destination character set, a replacement character appears. Replacement characters can be defined as part of a character set definition.</Function>
    <Function Name="CORR" Url="http://docs.oracle.com/database/121/SQLRF/functions042.htm">CORR returns the coefficient of correlation of a set of number pairs. You can use it as an aggregate or analytic function.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="CORR" Url="http://docs.oracle.com/database/121/SQLRF/functions043.htm">The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
These functions takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns NUMBER.</Function>
    <Function Name="COS" Url="http://docs.oracle.com/database/121/SQLRF/functions044.htm">COS returns the cosine of n (an angle expressed in radians).
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="COSH" Url="http://docs.oracle.com/database/121/SQLRF/functions045.htm">COSH returns the hyperbolic cosine of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="COUNT" Url="http://docs.oracle.com/database/121/SQLRF/functions046.htm">COUNT returns the number of rows returned by the query. You can use it as an aggregate or analytic function.
If you specify DISTINCT, then you can specify only the query_partition_clause of the analytic_clause. The order_by_clause and windowing_clause are not allowed.
If you specify expr, then COUNT returns the number of rows where expr is not null. You can count either all rows, or only distinct values of expr.
If you specify the asterisk (*), then this function returns all rows, including duplicates and nulls. COUNT never returns null.</Function>
    <Function Name="COVAR_POP" Url="http://docs.oracle.com/database/121/SQLRF/functions047.htm">COVAR_POP returns the population covariance of a set of number pairs. You can use it as an aggregate or analytic function.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="COVAR_SAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions048.htm">COVAR_SAMP returns the sample covariance of a set of number pairs. You can use it as an aggregate or analytic function.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="CUBE_TABLE" Url="http://docs.oracle.com/database/121/SQLRF/functions049.htm">CUBE_TABLE extracts data from a cube or dimension and returns it in the two-dimensional format of a relational table, which can be used by SQL-based applications.
The function takes a single VARCHAR2 argument. The optional hierarchy clause enables you to specify a dimension hierarchy. A cube can have multiple hierarchy clauses, one for each dimension.
You can generate these different types of tables:

A cube table contains a key column for each dimension and a column for each measure and calculated measure in the cube. To create a cube table, you can specify the cube with or without a cube hierarchy clause. For a dimension with multiple hierarchies, this clause limits the return values to the dimension members and levels in the specified hierarchy. Without a hierarchy clause, all dimension members and all levels are included.

A dimension table contains a key column, and a column for each level and each attribute. It also contains a MEMBER_TYPE column, which identifies each member with one of the following codes:

L - Loaded from a table, view, or synonym

A - Loaded member and the single root of all hierarchies in the dimension, that is, the "all" aggregate member

C - Calculated member

All dimension members and all levels are included in the table. To create a dimension table, specify the dimension without a dimension hierarchy clause.

A hierarchy table contains all the columns of a dimension table plus a column for the parent member and a column for each source level. It also contains a MEMBER_TYPE column, as described for dimension tables. Any dimension members and levels that are not part of the named hierarchy are excluded from the table. To create a hierarchy table, specify the dimension with a dimension hierarchy clause.

CUBE_TABLE is a table function and is always used in the context of a SELECT statement with this syntax:

SELECT ... FROM TABLE(CUBE_TABLE('arg'));</Function>
    <Function Name="CUME_DIST" Url="http://docs.oracle.com/database/121/SQLRF/functions050.htm">CUME_DIST calculates the cumulative distribution of a value in a group of values. The range of values returned by CUME_DIST is &gt;0 to &lt;=1. Tie values always evaluate to the same cumulative distribution value.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns NUMBER.</Function>
    <Function Name="CURRENT_DATE" Url="http://docs.oracle.com/database/121/SQLRF/functions051.htm">CURRENT_DATE returns the current date in the session time zone, in a value in the Gregorian calendar of data type DATE.</Function>
    <Function Name="CURRENT_TIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions052.htm">CURRENT_TIMESTAMP returns the current date and time in the session time zone, in a value of data type TIMESTAMP WITH TIME ZONE. The time zone offset reflects the current local time of the SQL session. If you omit precision, then the default is 6. The difference between this function and LOCALTIMESTAMP is that CURRENT_TIMESTAMP returns a TIMESTAMP WITH TIME ZONE value while LOCALTIMESTAMP returns a TIMESTAMP value.
In the optional argument, precision specifies the fractional second precision of the time value returned.</Function>
    <Function Name="CV" Url="http://docs.oracle.com/database/121/SQLRF/functions053.htm">The CV function can be used only in the model_clause of a SELECT statement and then only on the right-hand side of a model rule. It returns the current value of a dimension column or a partitioning column carried from the left-hand side to the right-hand side of a rule. This function is used in the model_clause to provide relative indexing with respect to the dimension column. The return type is that of the data type of the dimension column. If you omit the argument, then it defaults to the dimension column associated with the relative position of the function within the cell reference.
The CV function can be used outside a cell reference. In this case, dimension_column is required.</Function>
    <Function Name="DATAOBJ_TO_PARTITION" Url="http://docs.oracle.com/database/121/SQLRF/functions054.htm">DATAOBJ_TO_PARTITION is useful only to Data Cartridge developers who are performing data maintenance or query operations on system-partitioned tables that are used to store domain index data. The DML or query operations are triggered by corresponding operations on the base table of the domain index.
This function takes as arguments the name of the base table and the partition ID of the base table partition, both of which are passed to the function by the appropriate ODCIIndex method. The function returns the partition ID of the corresponding system-partitioned table, which can be used to perform the operation (DML or query) on that partition of the system-partitioned table.</Function>
    <Function Name="DBTIMEZONE" Url="http://docs.oracle.com/database/121/SQLRF/functions055.htm">DBTIMEZONE returns the value of the database time zone. The return type is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the user specified the database time zone value in the most recent CREATE DATABASE or ALTER DATABASE statement.</Function>
    <Function Name="DECODE" Url="http://docs.oracle.com/database/121/SQLRF/functions056.htm">DECODE compares expr to each search value one by one. If expr is equal to a search, then Oracle Database returns the corresponding result. If no match is found, then Oracle returns default. If default is omitted, then Oracle returns null.
The arguments can be any of the numeric types (NUMBER, BINARY_FLOAT, or BINARY_DOUBLE) or character types.

If expr and search are character data, then Oracle compares them using nonpadded comparison semantics. expr, search, and result can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The string returned is of VARCHAR2 data type and is in the same character set as the first result parameter.

If the first search-result pair are numeric, then Oracle compares all search-result expressions and the first expr to determine the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.

The search, result, and default values can be derived from expressions. Oracle Database uses short-circuit evaluation. The database evaluates each search value only before comparing it to expr, rather than evaluating all search values before comparing any of them with expr. Consequently, Oracle never evaluates a search if a previous search is equal to expr.
Oracle automatically converts expr and each search value to the data type of the first search value before comparing. Oracle automatically converts the return value to the same data type as the first result. If the first result has the data type CHAR or if the first result is null, then Oracle converts the return value to the data type VARCHAR2.
In a DECODE function, Oracle considers two nulls to be equivalent. If expr is null, then Oracle returns the result of the first search that is also null.
The maximum number of components in the DECODE function, including expr, searches, results, and default, is 255.</Function>
    <Function Name="DECOMPOSE" Url="http://docs.oracle.com/database/121/SQLRF/functions057.htm">DECOMPOSE is valid only for Unicode characters. DECOMPOSE takes as its argument a string in any data type and returns a Unicode string after decomposition in the same character set as the input. For example, an o-umlaut code point will be returned as the "o" code point followed by an umlaut code point.

string can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

CANONICAL causes canonical decomposition, which allows recomposition (for example, with the COMPOSE function) to the original string. This is the default and returns the string in NFD normal form.

COMPATIBILITY causes decomposition in compatibility mode. In this mode, recomposition is not possible. This mode is useful, for example, when decomposing half-width and full-width katakana characters, where recomposition might not be desirable without external formatting or style information. It returns the string in NFKD normal form.

CLOB and NCLOB values are supported through implicit conversion. If char is a character LOB value, then it is converted to a VARCHAR value before the COMPOSE operation. The operation will fail if the size of the LOB value exceeds the supported length of the VARCHAR in the particular development environment.</Function>
    <Function Name="DELETEXML" Url="http://docs.oracle.com/database/121/SQLRF/functions058.htm">DELETEXML deletes the node or nodes matched by the XPath expression in the target XML.

XMLType_instance is an instance of XMLType.

XPath_string is an Xpath expression indicating one or more nodes that are to be deleted. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. Any child nodes of the nodes specified by XPath_string are also deleted.

The optional namespace_string provides namespace information for the XPath_string. This parameter must be of type VARCHAR2.</Function>
    <Function Name="DENSE_RANK" Url="http://docs.oracle.com/database/121/SQLRF/functions059.htm">DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting.
This function accepts as arguments any numeric data type and returns NUMBER.

As an aggregate function, DENSE_RANK calculates the dense rank of a hypothetical row identified by the arguments of the function with respect to a given sort specification. The arguments of the function must all evaluate to constant expressions within each aggregate group, because they identify a single row within each group. The constant argument expressions and the expressions in the order_by_clause of the aggregate match by position. Therefore, the number of arguments must be the same and types must be compatible.

As an analytic function, DENSE_RANK computes the rank of each row returned from a query with respect to the other rows, based on the values of the value_exprs in the order_by_clause.</Function>
    <Function Name="DEPTH" Url="http://docs.oracle.com/database/121/SQLRF/functions060.htm">DEPTH is an ancillary function used only with the UNDER_PATH and EQUALS_PATH conditions. It returns the number of levels in the path specified by the UNDER_PATH condition with the same correlation variable.
The correlation_integer can be any NUMBER integer. Use it to correlate this ancillary function with its primary condition if the statement contains multiple primary conditions. Values less than 1 are treated as 1.</Function>
    <Function Name="DEREF" Url="http://docs.oracle.com/database/121/SQLRF/functions061.htm">DEREF returns the object reference of argument expr, where expr must return a REF to an object. If you do not use this function in a query, then Oracle Database returns the object ID of the REF instead, as shown in the example that follows.</Function>
    <Function Name="DUMP" Url="http://docs.oracle.com/database/121/SQLRF/functions062.htm">DUMP returns a VARCHAR2 value containing the data type code, length in bytes, and internal representation of expr. The returned result is always in the database character set. For the data type corresponding to each code, see Table 2-1, "Built-in Data Type Summary".
The argument return_fmt specifies the format of the return value and can have any of the following values:

8 returns result in octal notation.

10 returns result in decimal notation.

16 returns result in hexadecimal notation.

17 returns each byte printed as a character if and only if it can be interpreted as a printable character in the character set of the compiler—typically ASCII or EBCDIC. Some ASCII control characters may be printed in the form ^X as well. Otherwise the character is printed in hexadecimal notation. All NLS parameters are ignored. Do not depend on any particular output format for DUMP with return_fmt 17.

By default, the return value contains no character set information. To retrieve the character set name of expr, add 1000 to any of the preceding format values. For example, a return_fmt of 1008 returns the result in octal and provides the character set name of expr.
The arguments start_position and length combine to determine which portion of the internal representation to return. The default is to return the entire internal representation in decimal notation.
If expr is null, then this function returns NULL.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="EMPTY_BLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions063.htm">EMPTY_BLOB and EMPTY_CLOB return an empty LOB locator that can be used to initialize a LOB variable or, in an INSERT or UPDATE statement, to initialize a LOB column or attribute to EMPTY. EMPTY means that the LOB is initialized, but not populated with data.</Function>
    <Function Name="EXISTSNODE" Url="http://docs.oracle.com/database/121/SQLRF/functions064.htm">EXISTSNODE determines whether traversal of an XML document using a specified path results in any nodes. It takes as arguments the XMLType instance containing an XML document and a VARCHAR2 XPath string designating a path. The optional namespace_string must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).
The namespace_string argument defaults to the namespace of the root element. If you refer to any subelement in Xpath_string, then you must specify namespace_string, and you must specify the "who" prefix in both of these arguments.</Function>
    <Function Name="EXP" Url="http://docs.oracle.com/database/121/SQLRF/functions065.htm">EXP returns e raised to the nth power, where e = 2.71828183... . The function returns a value of the same type as the argument.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="EXTRACT" Url="http://docs.oracle.com/database/121/SQLRF/functions066.htm">EXTRACT extracts and returns the value of a specified datetime field from a datetime or interval expression. The expr can be any expression that evaluates to a datetime or interval data type compatible with the requested field:

If YEAR or MONTH is requested, then expr must evaluate to an expression of data type DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, or INTERVAL YEAR TO MONTH.

If DAY is requested, then expr must evaluate to an expression of data type DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, or INTERVAL DAY TO SECOND.

If HOUR, MINUTE, or SECOND is requested, then expr must evaluate to an expression of data type TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, or INTERVAL DAY TO SECOND. DATE is not valid here, because Oracle Database treats it as ANSI DATE data type, which has no time fields.

If TIMEZONE_HOUR, TIMEZONE_MINUTE, TIMEZONE_ABBR, TIMEZONE_REGION, or TIMEZONE_OFFSET is requested, then expr must evaluate to an expression of data type TIMESTAMP WITH TIME ZONE or TIMESTAMP WITH LOCAL TIME ZONE.

EXTRACT interprets expr as an ANSI datetime data type. For example, EXTRACT treats DATE not as legacy Oracle DATE but as ANSI DATE, without time elements. Therefore, you can extract only YEAR, MONTH, and DAY from a DATE value. Likewise, you can extract TIMEZONE_HOUR and TIMEZONE_MINUTE only from the TIMESTAMP WITH TIME ZONE data type.
When you specify TIMEZONE_REGION or TIMEZONE_ABBR (abbreviation), the value returned is a VARCHAR2 string containing the appropriate time zone region name or abbreviation. When you specify any of the other datetime fields, the value returned is an integer value of NUMBER data type representing the datetime value in the Gregorian calendar. When extracting from a datetime with a time zone value, the value returned is in UTC. For a listing of time zone region names and their corresponding abbreviations, query the V$TIMEZONE_NAMES dynamic performance view.
This function can be very useful for manipulating datetime field values in very large tables, as shown in the first example below.</Function>
    <Function Name="EXTRACT" Url="http://docs.oracle.com/database/121/SQLRF/functions067.htm">EXTRACT (XML) is similar to the EXISTSNODE function. It applies a VARCHAR2 XPath string and returns an XMLType instance containing an XML fragment. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. The optional namespace_string is required if the XML you are handling uses a namespace prefix. This argument must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).</Function>
    <Function Name="FEATURE_DETAILS" Url="http://docs.oracle.com/database/121/SQLRF/functions069.htm">FEATURE_DETAILS returns feature details for each row in the selection. The return value is an XML string that describes the attributes of the highest value feature or the specified feature_id.

topN
If you specify a value for topN, the function returns the N attributes that most influence the feature value. If you do not specify topN, the function returns the 5 most influential attributes.

DESC, ASC, or ABS
The returned attributes are ordered by weight. The weight of an attribute expresses its positive or negative impact on the value of the feature. A positive weight indicates a higher feature value. A negative weight indicates a lower feature value.
By default, FEATURE_DETAILS returns the attributes with the highest positive weight (DESC). If you specify ASC, the attributes with the highest negative weight are returned. If you specify ABS, the attributes with the greatest weight, whether negative or positive, are returned. The results are ordered by absolute value from highest to lowest. Attributes with a zero weight are not included in the output.

Syntax Choice
FEATURE_DETAILS can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a feature extraction model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of features to extract, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="FEATURE_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions070.htm">FEATURE_ID returns the identifier of the highest value feature for each row in the selection. The feature identifier is returned as an Oracle NUMBER.

Syntax Choice
FEATURE_ID can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a feature extraction model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of features to extract, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="FEATURE_SET" Url="http://docs.oracle.com/database/121/SQLRF/functions071.htm">FEATURE_SET returns a set of feature ID and feature value pairs for each row in the selection. The return value is a varray of objects with field names FEATURE_ID and VALUE. The data type of both fields is NUMBER.

topN and cutoff
You can specify topN and cutoff to limit the number of features returned by the function. By default, both topN and cutoff are null and all features are returned.

topN is the N highest value features. If multiple features have the Nth value, then the function chooses one of them.

cutoff is a value threshold. Only features that are greater than or equal to cutoff are returned. To filter by cutoff only, specify NULL for topN.

To return up to N features that are greater than or equal to cutoff, specify both topN and cutoff.

Syntax Choice
FEATURE_SET can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a feature extraction model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of features to extract, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="FEATURE_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions072.htm">FEATURE_VALUE returns a feature value for each row in the selection. The value refers to the highest value feature or to the specified feature_id. The feature value is returned as BINARY_DOUBLE.

Syntax Choice
FEATURE_VALUE can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a feature extraction model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of features to extract, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, this data is also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="FIRST" Url="http://docs.oracle.com/database/121/SQLRF/functions073.htm">FIRST and LAST are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the FIRST or LAST with respect to a given sorting specification. If only one row ranks as FIRST or LAST, then the aggregate operates on the set with only one element.
If you omit the OVER clause, then the FIRST and LAST functions are treated as aggregate functions. You can use these functions as analytic functions by specifying the OVER clause. The query_partition_clause is the only part of the OVER clause valid with these functions. If you include the OVER clause but omit the query_partition_clause, then the function is treated as an analytic function, but the window defined for analysis is the entire table.
These functions take as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.
When you need a value from the first or last row of a sorted group, but the needed value is not the sort key, the FIRST and LAST functions eliminate the need for self-joins or views and enable better performance.

The aggregate_function argument is any one of the MIN, MAX, SUM, AVG, COUNT, VARIANCE, or STDDEV functions. It operates on values from the rows that rank either FIRST or LAST. If only one row ranks as FIRST or LAST, then the aggregate operates on a singleton (nonaggregate) set.

The KEEP keyword is for semantic clarity. It qualifies aggregate_function, indicating that only the FIRST or LAST values of aggregate_function will be returned.

DENSE_RANK FIRST or DENSE_RANK LAST indicates that Oracle Database will aggregate over only those rows with the minimum (FIRST) or the maximum (LAST) dense rank (also called olympic rank).</Function>
    <Function Name="FIRST" Url="http://docs.oracle.com/database/121/SQLRF/functions094.htm">FIRST and LAST are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the FIRST or LAST with respect to a given sorting specification. If only one row ranks as FIRST or LAST, then the aggregate operates on the set with only one element.
Refer to FIRST for complete information on this function and for examples of its use.</Function>
    <Function Name="FIRST_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions074.htm">FIRST_VALUE is an analytic function. It returns the first value in an ordered set of values. If the first value in the set is null, then the function returns NULL unless you specify IGNORE NULLS. This setting is useful for data densification.</Function>
    <Function Name="FLOOR" Url="http://docs.oracle.com/database/121/SQLRF/functions075.htm">FLOOR returns the largest integer equal to or less than n. The number n can always be written as the sum of an integer k and a positive fraction f such that 0 &lt;= f &lt; 1 and n = k + f. The value of FLOOR is the integer k. Thus, the value of FLOOR is n itself if and only if n is precisely an integer.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="FROM_TZ" Url="http://docs.oracle.com/database/121/SQLRF/functions076.htm">FROM_TZ converts a timestamp value and a time zone to a TIMESTAMP WITH TIME ZONE value. time_zone_value is a character string in the format 'TZH:TZM' or a character expression that returns a string in TZR with optional TZD format.</Function>
    <Function Name="GREATEST" Url="http://docs.oracle.com/database/121/SQLRF/functions077.htm">GREATEST returns the greatest of a list of one or more expressions. Oracle Database uses the first expr to determine the return type. If the first expr is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first expr is not numeric, then each expr after the first is implicitly converted to the data type of the first expr before the comparison.
Oracle Database compares each expr using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the NLS_COMP parameter is set to LINGUISTIC and the NLS_SORT parameter has a setting other than BINARY. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is VARCHAR2 if the first expr is a character data type and NVARCHAR2 if the first expr is a national character data type.</Function>
    <Function Name="GROUP_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions078.htm">GROUP_ID distinguishes duplicate groups resulting from a GROUP BY specification. It is useful in filtering out duplicate groupings from the query result. It returns an Oracle NUMBER to uniquely identify duplicate groups. This function is applicable only in a SELECT statement that contains a GROUP BY clause.
If n duplicates exist for a particular grouping, then GROUP_ID returns numbers in the range 0 to n-1.</Function>
    <Function Name="GROUPING" Url="http://docs.oracle.com/database/121/SQLRF/functions079.htm">GROUPING distinguishes superaggregate rows from regular grouped rows. GROUP BY extensions such as ROLLUP and CUBE produce superaggregate rows where the set of all values is represented by null. Using the GROUPING function, you can distinguish a null representing the set of all values in a superaggregate row from a null in a regular row.
The expr in the GROUPING function must match one of the expressions in the GROUP BY clause. The function returns a value of 1 if the value of expr in the row is a null representing the set of all values. Otherwise, it returns zero. The data type of the value returned by the GROUPING function is Oracle NUMBER. Refer to the SELECT group_by_clause for a discussion of these terms.</Function>
    <Function Name="GROUPING_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions080.htm">GROUPING_ID returns a number corresponding to the GROUPING bit vector associated with a row. GROUPING_ID is applicable only in a SELECT statement that contains a GROUP BY extension, such as ROLLUP or CUBE, and a GROUPING function. In queries with many GROUP BY expressions, determining the GROUP BY level of a particular row requires many GROUPING functions, which leads to cumbersome SQL. GROUPING_ID is useful in these cases.
GROUPING_ID is functionally equivalent to taking the results of multiple GROUPING functions and concatenating them into a bit vector (a string of ones and zeros). By using GROUPING_ID you can avoid the need for multiple GROUPING functions and make row filtering conditions easier to express. Row filtering is easier with GROUPING_ID because the desired rows can be identified with a single condition of GROUPING_ID = n. The function is especially useful when storing multiple levels of aggregation in a single table.</Function>
    <Function Name="HEXTORAW" Url="http://docs.oracle.com/database/121/SQLRF/functions081.htm">HEXTORAW converts char containing hexadecimal digits in the CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to a raw value.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="INITCAP" Url="http://docs.oracle.com/database/121/SQLRF/functions082.htm">INITCAP returns char, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric.
char can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The return value is the same data type as char. The database sets the case of the initial characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase and lowercase, refer to NLS_INITCAP.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="INSERTCHILDXML" Url="http://docs.oracle.com/database/121/SQLRF/functions083.htm">INSERTCHILDXML inserts a user-supplied value into the target XML at the node indicated by the XPath expression. Compare this function with INSERTXMLBEFORE.

XMLType_instance is an instance of XMLType.

XPath_string is an Xpath expression indicating one or more nodes into which the one or more child nodes are to be inserted. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node.

child_expr specifies the one or more element or attribute nodes to be inserted.

value_expr is an fragment of XMLType that specifies one or more notes being inserted. It must resolve to a string.

The optional namespace_string provides namespace information for the XPath_string. This parameter must be of type VARCHAR2.</Function>
    <Function Name="INSERTXMLAFTER" Url="http://docs.oracle.com/database/121/SQLRF/functions086.htm">INSERTXMLAFTER inserts one or more nodes of any kind immediately after a target node that is not an attribute node. The XML document that is the target of the insertion can be schema-based or non-schema-based. This function is similar to insertXMLbefore, but it inserts after, not before, the target node.

XMLType_instance specifies the target node of the of the insertion.

XPath_string is an XPath 1.0 expression that locates in the target node zero or more nodes of any kind except attribute nodes. XML-data is inserted immediately after each of these nodes; that is, each node specified becomes the preceding sibling node of a node specified in value_expr.

value_expr is the XML data to be inserted. You can specify one or more nodes of any kind. The order of the nodes is preserved after the insertion.

The optional namespace_string is the namespace for the target node.</Function>
    <Function Name="INSERTXMLBEFORE" Url="http://docs.oracle.com/database/121/SQLRF/functions087.htm">INSERTXMLBEFORE inserts a user-supplied value into the target XML before the node indicated by the XPath expression. This function is similar to INSERTXMLAFTER, but it inserts before, not after, the target node. Compare this function with INSERTCHILDXML.

XMLType_instance is an instance of XMLType.

XPath_string is an Xpath expression indicating one or more nodes into which one or more child nodes are to be inserted. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node.

value_expr is a fragment of XMLType that defines one or more nodes being inserted and their position within the parent node. It must resolve to a string.

The optional namespace_string provides namespace information for the XPath_string. This parameter must be of type VARCHAR2.</Function>
    <Function Name="INSERTXMLCHILDAFTER" Url="http://docs.oracle.com/database/121/SQLRF/functions084.htm">INSERTXMLCHILDAFTER inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately after a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based.

XMLType_instance identifies the XML data that is the target of the insertion.

XPath_string locates the parent elements within target-data; child-data is inserted under each parent element.

child_expr is a relative XPath 1.0 expression that locates the existing child that will precede the inserted child-data. It must name a child element of the element indicated by parent-xpath, and it can include a predicate.

value_expr is the XMLType child element data to insert. Each top-level element node in this argument must have the same data type as the element indicated by child_expr.

The optional namespace_string specifies the namespace for the parent elements, existing child element, and child element XML data to be inserted.</Function>
    <Function Name="INSERTXMLCHILDBEFORE" Url="http://docs.oracle.com/database/121/SQLRF/functions085.htm">INSERTXMLCHILDBEFORE inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately before a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based.

XMLType_instance identifies the XML data that is the target of the insertion.

XPath_string locates the parent elements within target-data; child-data is inserted under each parent element.

child_expr is a relative XPath 1.0 expression that locates the existing child that will follow the inserted child-data. It must name a child element of the element indicated by parent-xpath, and it can include a predicate.

value_expr is the XMLType child element data to insert. Each top-level element node in this argument must have the same data type as the element indicated by child_expr.

The optional namespace_string specifies the namespace for the parent elements, existing child element, and child element XML data to be inserted.</Function>
    <Function Name="INSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions088.htm">The INSTR functions search string for substring. The search operation is defined as comparing the substring argument with substrings of string of the same length for equality until a match is found or there are no more substrings left. Each consecutive compared substring of string begins one character to the right (for forward searches) or one character to the left (for backward searches) from the first character of the previous compared substring. If a substring that is equal to substring is found, then the function returns an integer indicating the position of the first character of this substring. If no such substring is found, then the function returns zero.

position is an nonzero integer indicating the character of string where Oracle Database begins the search—that is, the position of the first character of the first substring to compare with substring. If position is negative, then Oracle counts backward from the end of string and then searches backward from the resulting position.

occurrence is an integer indicating which occurrence of substring in string Oracle should search for. The value of occurrence must be positive. If occurrence is greater than 1, then the database does not return on the first match but continues comparing consecutive substrings of string, as described above, until match number occurrence has been found.

INSTR accepts and returns positions in characters as defined by the input character set, with the first character of string having position 1. INSTRB uses bytes instead of characters. INSTRC uses Unicode complete characters. INSTR2 uses UCS2 code points. INSTR4 uses UCS4 code points.
string can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The exceptions are INSTRC, INSTR2, and INSTR4, which do not allow string to be a CLOB or NCLOB.
substring can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.
The value returned is of NUMBER data type.
Both position and occurrence must be of data type NUMBER, or any data type that can be implicitly converted to NUMBER, and must resolve to an integer. The default values of both position and occurrence are 1, meaning Oracle begins searching at the first character of string for the first occurrence of substring. The return value is relative to the beginning of string, regardless of the value of position.</Function>
    <Function Name="ITERATION_NUMBER" Url="http://docs.oracle.com/database/121/SQLRF/functions089.htm">The ITERATION_NUMBER function can be used only in the model_clause of the SELECT statement and then only when ITERATE(number) is specified in the model_rules_clause. It returns an integer representing the completed iteration through the model rules. The ITERATION_NUMBER function returns 0 during the first iteration. For each subsequent iteration, the ITERATION_NUMBER function returns the equivalent of iteration_number plus one.</Function>
    <Function Name="JSON_QUERY" Url="http://docs.oracle.com/database/121/SQLRF/functions090.htm">JSON_QUERY finds one or more specified JSON values in JSON data and returns the values in a character string.

expr
Use this clause to specify the JSON data to be evaluated. For expr, specify an expression that evaluates to a text literal. If expr is a column, then the column must be of data type VARCHAR2, CLOB, or BLOB. If expr is null, then the function returns null.
If expr is not a text literal of well-formed JSON data using strict or lax syntax, then the function returns null by default. You can use the JSON_query_on_error_clause to override this default behavior. Refer to JSON_query_on_error_clause.

FORMAT JSON
You must specify FORMAT JSON if expr is a column of data type BLOB.


JSON_path_expression
Use this clause to specify a JSON path expression. The function uses the path expression to evaluate expr and find one or more JSON values that match, or satisfy, the path expression. The path expression must be a text literal.
The path expression must begin with a dollar sign ($), which represents the context item, that is, the expression specified by expr. The dollar sign is followed by zero or more steps, each of which can be an object step or an array step.
The function attempts to match the first step in the path expression to the context item. If the first step results in a match, then the function attempts to match the second step to the JSON value(s) that matched the first step. If the second step results in a match, then the function attempts to match the third step to the JSON values(s) that matched the second step, and so on. The function returns the value(s) matched in the final step as a comma-separated sequence of values in a character string. The order of the sequence is nondeterministic. All values are returned using strict JSON syntax, regardless of whether the original JSON data used strict or lax JSON syntax. A path expression that consists of a dollar sign followed by zero steps ('$') matches the entire context item.
You can specify the JSON_query_returning_clause to control the data type and format of the return character string. Refer to the JSON_query_returning_clause.
If multiple values match the path expression, or if only one scalar value matches the path expression, then you must wrap the value(s) in an array wrapper. Refer to the JSON_query_wrapper_clause.
If any step in the path expression does not result in a match, then the function returns null by default. You can use the JSON_query_on_error_clause to override this default behavior. Refer to the JSON_query_on_error_clause.


object_step Use this clause to specify an object step.

Use simple_name or complex_name to specify a property name. If a member with that property name exists in the JSON object being evaluated, then the object step results in a match to the property value of that member. Otherwise, the object step does not result in a match. Both types of names are case-sensitive. Therefore, a match will result only if the alphabetic character cases match in the object step and the JSON data.
A simple_name can contain only alphanumeric characters and must begin with an alphabetic character. A complex_name can contain only alphanumeric characters and spaces, and must begin with an alphanumeric character. A complex_name must be enclosed in double quotation marks.

Use the asterisk wildcard symbol (*) to specify all property names. If the JSON object being evaluated contains at least one member, then the object step results in a match to the values of all members. Otherwise, the object step does not result in a match.

If you apply an object step to a JSON array, then the array is implicitly unwrapped and the elements of the array are evaluated using the object step. This is called JSON path expression relaxation. Refer to Oracle XML DB Developer's Guide for more information.
If the JSON data being evaluated is not a JSON object, then the object step does not result in a match.


array_step Use this clause to specify an array step.

Use integer to specify the element at index integer in a JSON array. Use integer TO integer to specify the range of elements between the two index integer values, inclusive. If the specified elements exist in the JSON array being evaluated, then the array step results in a match to those elements. Otherwise, the array step does not result in a match. The first element in a JSON array had index 0.

Use the asterisk wildcard symbol (*) to specify all elements in a JSON array. If the JSON array being evaluated contains at least one element, then the array step results in a match to all elements in the JSON array. Otherwise, the array step does not result in a match.

If the JSON data being evaluated is not a JSON array, then the data is implicitly wrapped in an array and then evaluated using the array step. This is called JSON path expression relaxation. Refer to Oracle XML DB Developer's Guide for more information.


JSON_query_returning_clause
Use this clause to specify the data type and format of the character string returned by this function.

RETURNING Use the RETURNING clause to specify the data type of the character string. If you omit this clause, then JSON_QUERY returns a character string of type VARCHAR2(4000).
You can use the JSON_return_type_clause to specify the following data type:

VARCHAR2[(size [BYTE,CHAR])]
When specifying the VARCHAR2 data type elsewhere in SQL, you are required to specify a size. However, in this clause you can omit the size. In this case, JSON_QUERY returns a character string of type VARCHAR2(4000).
Refer to "VARCHAR2 Data Type" for more information.

If the data type is not large enough to hold the return character string, then this function returns null by default. You can use the JSON_query_on_error_clause to override this default behavior. Refer to the JSON_query_on_error_clause.

PRETTY Specify PRETTY to pretty-print the return character string by inserting newline characters and indenting.

ASCII Specify ASCII to automatically escape any non-ASCII Unicode characters in the return character string, using standard ASCII Unicode escape sequences.


JSON_query_wrapper_clause
Use this clause to control whether this function wraps the values matched by the path expression in an array wrapper—that is, encloses the sequence of values in square brackets ([]).

Specify WITHOUT WRAPPER to omit the array wrapper. You can specify this clause only if the path expression matches a single JSON object or JSON array. This is the default.

Specify WITH WRAPPER to include the array wrapper. You must specify this clause if the path expression matches a single scalar value (a value that is not a JSON object or JSON array) or multiple values of any type.

Specifying the WITH UNCONDITIONAL WRAPPER clause is equivalent to specifying the WITH WRAPPER clause. The UNCONDITIONAL keyword is provided for semantic clarity.

Specify WITH CONDITIONAL WRAPPER to include the array wrapper only if the path expression matches a single scalar value or multiple values of any type. If the path expression matches a single JSON object or JSON array, then the array wrapper is omitted.

The ARRAY keyword is optional and is provided for semantic clarity.
If the function returns a single scalar value, or multiple values of any type, and you do not specify WITH [UNCONDITIONAL | CONDITIONAL] WRAPPER, then the function returns null by default. You can use the JSON_query_on_error_clause to override this default behavior. Refer to the JSON_query_on_error_clause.


JSON_query_on_error_clause
Use this clause to specify the value returned by this function when the following errors occur:

expr is not well-formed JSON data using strict or lax JSON syntax

No match is found when the JSON data is evaluated using the JSON path expression

The return value data type is not large enough to hold the return character string

The function matches a single scalar value or, multiple values of any type, and the WITH [UNCONDITIONAL | CONDITIONAL] WRAPPER clause is not specified

You can specify the following clauses:

NULL ON ERROR - Returns null when an error occurs. This is the default.

ERROR ON ERROR - Returns the appropriate Oracle error when an error occurs.

EMPTY ON ERROR - Returns an empty JSON array ('[]') when an error occurs.</Function>
    <Function Name="JSON_TABLE" Url="http://docs.oracle.com/database/121/SQLRF/functions091.htm">JSON_TABLE creates a relational view of JSON data. It maps the result of a JSON data evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL. The main purpose of JSON_TABLE is to create a row of relational data for each object inside a JSON array and output JSON values from within that object as individual SQL column values.
You must specify JSON_TABLE only in the FROM clause of a SELECT statement. The function first applies a JSON path expression, called a row path expression, to the supplied JSON data. The JSON value that matches the row path expression is called a row source in that it generates a row of relational data. The COLUMNS clause evaluates the row source, finds specific JSON values within the row source, and returns those JSON values as SQL values in individual columns of a row of relational data.
The COLUMNS clause enables you to search for JSON values in different ways by using the following clauses:

JSON_exists_column - Evaluates JSON data in the same manner as the JSON_EXISTS condition, that is, determines if a specified JSON value exists, and returns either a VARCHAR2 column of values 'true' or 'false', or a NUMBER column of values 1 or 0.

JSON_query_column - Evaluates JSON data in the same manner as the JSON_QUERY function, that is, finds one or more specified JSON values, and returns a column of character strings that contain those JSON values.

JSON_value_column - Evaluates JSON data in the same manner as the JSON_VALUE function, that is, finds a specified scalar JSON value, and returns a column of those JSON values as SQL values.

JSON_nested_path - Allows you to flatten JSON values in a nested JSON object or JSON array into individual columns in a single row along with JSON values from the parent object or array. You can use this clause recursively to project data from multiple layers of nested objects or arrays into a single row.

ordinality_column - Returns a column of generated row numbers.

The column definition clauses allow you to specify a name for each column of data that they return. You can reference these column names elsewhere in the SELECT statement, such as in the SELECT list and the WHERE clause.

expr
Use this clause to specify the JSON data to be evaluated. For expr, specify an expression that evaluates to a text literal. If expr is a column, then the column must be of data type VARCHAR2, CLOB, or BLOB. If expr is null, then the function returns null.
If expr is not a text literal of well-formed JSON data using strict or lax syntax, then the function returns null by default. You can use the JSON_table_on_error_clause to override this default behavior. Refer to JSON_table_on_error_clause.

FORMAT JSON
You must specify FORMAT JSON if expr is a column of data type BLOB.

JSON_path_expression
Use this clause to specify the row path expression. The function uses the row path expression to evaluate expr and find the a JSON value, called the row source, that matches, or satisfy, the path expression. This row source is then evaluated by the COLUMNS clause. The path expression must be a text literal.
The JSON_path_expression clause has the same semantics for JSON_TABLE and JSON_QUERY. For the full semantics of this clause, refer to JSON_path_expression in the documentation on JSON_QUERY.


JSON_table_on_error_clause
Use this clause to specify the value returned by this function when the following errors occur:

expr is not well-formed JSON data using strict or lax JSON syntax

No match is found when the JSON data is evaluated using the row path expression

You can specify the following clauses:

NULL ON ERROR - Returns null when an error occurs. This is the default.

ERROR ON ERROR - Returns the appropriate Oracle error when an error occurs.

DEFAULT literal ON ERROR - Returns literal when an error occurs. If the data type of the value returned by this function is VARCHAR2, then you must specify a text literal. If the data type is NUMBER, then you must specify a numeric literal.



JSON_columns_clause
Use the COLUMNS clause to define the columns in the virtual relational table returned by the JSON_TABLE function.


JSON_exists_column This clause evaluates JSON data in the same manner as the JSON_EXISTS condition, that is, it determines if a specified JSON value exists. It returns either a VARCHAR2 column of values 'true' or 'false', or a NUMBER column of values 1 or 0. A value of 'true' or 1 indicates that the JSON value exists and a value of 'false' or 0 indicates that the JSON value does not exist.
You can use the JSON_value_return_type clause to control the data type of the returned column. If you omit this clause, then the data type is VARCHAR2(4000). Use column_name to specify the name of the returned column. The rest of the clauses of JSON_exists_column have the same semantics here as they have for the JSON_EXISTS condition. For full information on these clauses, refer to "JSON_EXISTS Condition". Also see "Using JSON_exists_column: Examples" for an example.


JSON_query_column This clause evaluates JSON data in the same manner as the JSON_QUERY function, that is, it finds one or more specified JSON values, and returns a column of character strings that contain those JSON values.
Use column_name to specify the name of the returned column. The rest of the clauses of JSON_query_column have the same semantics here as they have for the JSON_QUERY function. For full information on these clauses, refer to JSON_QUERY. Also see "Using JSON_query_column: Example" for an example.


JSON_value_column This clause evaluates JSON data in the same manner as the JSON_VALUE function, that is, it finds a specified scalar JSON value, and returns a column of those JSON values as SQL values.
Use column_name to specify the name of the returned column. The rest of the clauses of JSON_value_column have the same semantics here as they have for the JSON_VALUE function. For full information on these clauses, refer to JSON_VALUE. Also see "Using JSON_value_column: Example" for an example.


nested_path_column Use this clause to flatten JSON values in a nested JSON object or JSON array into individual columns in a single row along with JSON values from the parent object or array. You can use this clause recursively to project data from multiple layers of nested objects or arrays into a single row.
Specify the JSON_path_expression clause to match the nested object or array. This path expression is relative to the row path expression specified in the JSON_TABLE function.
Use the COLUMNS clause to define the columns of the nested object or array to be returned. This clause is recursive—you can specify the nested_path_column clause within another nested_path_column clause. Also see "Using nested_path_column: Examples" for an example.


ordinality_column This clause returns a column of generated row numbers of data type NUMBER. You can specify at most one ordinality_column. Also see "Using JSON_value_column: Example" for an example of using the ordinality_column clause.</Function>
    <Function Name="JSON_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions092.htm">JSON_VALUE finds a specified scalar JSON value in JSON data and returns it as a SQL value.

expr
Use this clause to specify the JSON data to be evaluated. For expr, specify an expression that evaluates to a text literal. If expr is a column, then the column must be of data type VARCHAR2, CLOB, or BLOB. If expr is null, then the function returns null.
If expr is not a text literal of well-formed JSON data using strict or lax syntax, then the function returns null by default. You can use the JSON_value_on_error_clause to override this default behavior. Refer to the JSON_value_on_error_clause.

FORMAT JSON
You must specify FORMAT JSON if expr is a column of data type BLOB.


JSON_path_expression
Use this clause to specify a JSON path expression. The function uses the path expression to evaluate expr and find a scalar JSON value that matches, or satisfies, the path expression. The path expression must be a text literal.
The path expression must begin with a dollar sign ($), which represents the context item, that is, the expression specified by expr. The dollar sign is followed by zero or more steps, each of which can be an object step or an array step.
The function attempts to match the first step in the path expression to the context item. If the first step results in a match, then the function attempts to match the second step to the JSON value(s) that matched the first step. If the second step results in a match, then the function attempts to match the third step to the JSON value(s) that matched the second step, and so on. If the final step matches a scalar JSON value, then the function returns that value as a SQL value. A path expression that consists of a dollar sign followed by zero steps ('$') matches the entire context item.
You can specify the JSON_value_returning_clause to control the data type and format of the returned SQL value. Refer to the JSON_value_returning_clause.
If any step in the path expression does not result in a match, or if the final step matches a nonscalar value, then the function returns null by default. You can use the JSON_value_on_error_clause to override this default behavior. Refer to the JSON_value_on_error_clause.


object_step Use this clause to specify an object step.

Use simple_name or complex_name to specify a property name. If a member with that property name exists in the JSON object being evaluated, then the object step results in a match to the property value of that member. Otherwise, the object step does not result in a match. Both types of names are case-sensitive. Therefore, a match will result only if the alphabetic character cases match in the object step and the JSON data.
A simple_name can contain only alphanumeric characters and must begin with an alphabetic character. A complex_name can contain only alphanumeric characters and spaces, and must begin with an alphanumeric character. A complex_name must be enclosed in double quotation marks.

Use the asterisk wildcard symbol (*) to specify all property names. If the JSON object being evaluated contains at least one member, then the object step results in a match to the values of all members. Otherwise, the object step does not result in a match.

If you apply an object step to a JSON array, then the array is implicitly unwrapped and the elements of the array are evaluated using the object step. This is called JSON path expression relaxation. Refer to Oracle XML DB Developer's Guide for more information.
If the JSON value being evaluated is not a JSON object, then the object step does not result in a match.


array_step Use this clause to specify an array step.

Use integer to specify the element at index integer in a JSON array. Use integer TO integer to specify the range of elements between the two index integer values, inclusive. If the specified elements exist in the JSON array being evaluated, then the array step results in a match to those elements. Otherwise, the array step does not result in a match. The first element in a JSON array has index 0.

Use the asterisk wildcard symbol (*) to specify all elements in a JSON array. If the JSON array being evaluated contains at least one element, then the array step results in a match to all elements in the JSON array. Otherwise, the array step does not result in a match.

If the JSON data being evaluated is not a JSON array, then the data is implicitly wrapped in an array and then evaluated using the array step. This is called JSON path expression relaxation. Refer to Oracle XML DB Developer's Guide for more information.


JSON_value_returning_clause
Use this clause to specify the data type and format of the value returned by this function.

RETURNING Use the RETURNING clause to specify the data type of the return value. If you omit this clause, then JSON_VALUE returns a value of type VARCHAR2(4000).
You can use JSON_value_return_type to specify the following data types:

VARCHAR2[(size [BYTE,CHAR])]
If you specify this data type, then the scalar value returned by this function can be a character or number value. A number value will be implicitly converted to a VARCHAR2. When specifying the VARCHAR2 data type elsewhere in SQL, you are required to specify a size. However, in this clause you can omit the size. In this case, JSON_VALUE returns a value of type VARCHAR2(4000).
Refer to "VARCHAR2 Data Type" for more information.

NUMBER[(precision [, scale])]
If you specify this data type, then the scalar value returned by this function must be a number value.
Refer to "NUMBER Data Type" for more information.

If the data type is not large enough to hold the return value, then this function returns null by default. You can use the JSON_value_on_error_clause to override this default behavior. Refer to the JSON_value_on_error_clause.

ASCII Specify ASCII to automatically escape any non-ASCII Unicode characters in the return value, using standard ASCII Unicode escape sequences.


JSON_value_on_error_clause
Use this clause to specify the value returned by this function when the following errors occur:

expr is not well-formed JSON data using strict or lax JSON syntax

A nonscalar value or no match is found when the JSON data is evaluated using the JSON path expression

The return value data type is not large enough to hold the return value

You can specify the following clauses:

NULL ON ERROR - Returns null when an error occurs. This is the default.

ERROR ON ERROR - Returns the appropriate Oracle error when an error occurs.

DEFAULT literal ON ERROR - Returns literal when an error occurs. If the data type of the value returned by this function is VARCHAR2, then you must specify a text literal. If the data type is NUMBER, then you must specify a numeric literal.</Function>
    <Function Name="LAG" Url="http://docs.oracle.com/database/121/SQLRF/functions093.htm">LAG is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, LAG provides access to a row at a given physical offset prior to that position.
For the optional offset argument, specify an integer that is greater than zero. If you do not specify offset, then its default is 1. The optional default value is returned if the offset goes beyond the scope of the window. If you do not specify default, then its default is null.
{RESPECT | IGNORE} NULLS determines whether null values of value_expr are included in or eliminated from the calculation. The default is RESPECT NULLS.
You cannot nest analytic functions by using LAG or any other analytic function for value_expr. However, you can use other built-in function expressions for value_expr.</Function>
    <Function Name="LAST_DAY" Url="http://docs.oracle.com/database/121/SQLRF/functions095.htm">LAST_DAY returns the date of the last day of the month that contains date. The last day of the month is defined by the session parameter NLS_CALENDAR. The return type is always DATE, regardless of the data type of date.</Function>
    <Function Name="LAST_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions096.htm">LAST_VALUE is an analytic function that is useful for data densification. It returns the last value in an ordered set of values.</Function>
    <Function Name="LEAD" Url="http://docs.oracle.com/database/121/SQLRF/functions097.htm">LEAD is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, LEAD provides access to a row at a given physical offset beyond that position.
If you do not specify offset, then its default is 1. The optional default value is returned if the offset goes beyond the scope of the table. If you do not specify default, then its default value is null.
{RESPECT | IGNORE} NULLS determines whether null values of value_expr are included in or eliminated from the calculation. The default is RESPECT NULLS.
You cannot nest analytic functions by using LEAD or any other analytic function for value_expr. However, you can use other built-in function expressions for value_expr.</Function>
    <Function Name="LEAST" Url="http://docs.oracle.com/database/121/SQLRF/functions098.htm">LEAST returns the least of a list of one or more expressions. Oracle Database uses the first expr to determine the return type. If the first expr is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first expr is not numeric, then each expr after the first is implicitly converted to the data type of the first expr before the comparison.
Oracle Database compares each expr using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the NLS_COMP parameter is set to LINGUISTIC and the NLS_SORT parameter has a setting other than BINARY. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is VARCHAR2 if the first expr is a character data type and NVARCHAR2 if the first expr is a national character data type.</Function>
    <Function Name="LENGTH" Url="http://docs.oracle.com/database/121/SQLRF/functions099.htm">The LENGTH functions return the length of char. LENGTH calculates length using characters as defined by the input character set. LENGTHB uses bytes instead of characters. LENGTHC uses Unicode complete characters. LENGTH2 uses UCS2 code points. LENGTH4 uses UCS4 code points.
char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The exceptions are LENGTHC, LENGTH2, and LENGTH4, which do not allow char to be a CLOB or NCLOB. The return value is of data type NUMBER. If char has data type CHAR, then the length includes all trailing blanks. If char is null, then this function returns null.

Restriction on LENGTHB The LENGTHB function is supported for single-byte LOBs only. It cannot be used with CLOB and NCLOB data in a multibyte character set.</Function>
    <Function Name="LISTAGG" Url="http://docs.oracle.com/database/121/SQLRF/functions100.htm">For a specified measure, LISTAGG orders data within each group specified in the ORDER BY clause and then concatenates the values of the measure column.

As a single-set aggregate function, LISTAGG operates on all rows and returns a single output row.

As a group-set aggregate, the function operates on and returns an output row for each group defined by the GROUP BY clause.

As an analytic function, LISTAGG partitions the query result set into groups based on one or more expression in the query_partition_clause.

The arguments to the function are subject to the following rules:

The measure_expr can be any expression. Null values in the measure column are ignored.

The delimiter_expr designates the string that is to separate the measure values. This clause is optional and defaults to NULL.

The order_by_clause determines the order in which the concatenated values are returned. The function is deterministic only if the ORDER BY column list achieved unique ordering.

The return data type is RAW if the measure column is RAW; otherwise the return value is VARCHAR2.</Function>
    <Function Name="LN" Url="http://docs.oracle.com/database/121/SQLRF/functions101.htm">LN returns the natural logarithm of n, where n is greater than 0.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="LNNVL" Url="http://docs.oracle.com/database/121/SQLRF/functions102.htm">LNNVL provides a concise way to evaluate a condition when one or both operands of the condition may be null. The function can be used in the WHERE clause of a query, or as the WHEN condition in a searched CASE expression. It takes as an argument a condition and returns TRUE if the condition is FALSE or UNKNOWN and FALSE if the condition is TRUE. LNNVL can be used anywhere a scalar expression can appear, even in contexts where the IS [NOT] NULL, AND, or OR conditions are not valid but would otherwise be required to account for potential nulls.
Oracle Database sometimes uses the LNNVL function internally in this way to rewrite NOT IN conditions as NOT EXISTS conditions. In such cases, output from EXPLAIN PLAN shows this operation in the plan table output. The condition can evaluate any scalar values but cannot be a compound condition containing AND, OR, or BETWEEN.
The table that follows shows what LNNVL returns given that a = 2 and b is null.</Function>
    <Function Name="LOCALTIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions103.htm">LOCALTIMESTAMP returns the current date and time in the session time zone in a value of data type TIMESTAMP. The difference between this function and CURRENT_TIMESTAMP is that LOCALTIMESTAMP returns a TIMESTAMP value while CURRENT_TIMESTAMP returns a TIMESTAMP WITH TIME ZONE value.
The optional argument timestamp_precision specifies the fractional second precision of the time value returned.</Function>
    <Function Name="LOG" Url="http://docs.oracle.com/database/121/SQLRF/functions104.htm">LOG returns the logarithm, base n2, of n1. The base n2 can be any positive value other than 0 or 1 and n1 can be any positive value.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is BINARY_FLOAT or BINARY_DOUBLE, then the function returns BINARY_DOUBLE. Otherwise the function returns NUMBER.</Function>
    <Function Name="LOWER" Url="http://docs.oracle.com/database/121/SQLRF/functions105.htm">LOWER returns char, with all letters lowercase. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The return value is the same data type as char. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive lowercase, refer to NLS_LOWER.</Function>
    <Function Name="LPAD" Url="http://docs.oracle.com/database/121/SQLRF/functions106.htm">LPAD returns expr1, left-padded to length n characters with the sequence of characters in expr2. This function is useful for formatting the output of a query.
Both expr1 and expr2 can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if expr1 is a character data type, NVARCHAR2 if expr1 is a national character data type, and a LOB if expr1 is a LOB data type. The string returned is in the same character set as expr1. The argument n must be a NUMBER integer or a value that can be implicitly converted to a NUMBER integer.
If you do not specify expr2, then the default is a single blank. If expr1 is longer than n, then this function returns the portion of expr1 that fits in n.
The argument n is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string.</Function>
    <Function Name="LTRIM" Url="http://docs.oracle.com/database/121/SQLRF/functions107.htm">LTRIM removes from the left end of char all of the characters contained in set. If you do not specify set, then it defaults to a single blank. If char is a character literal, then you must enclose it in single quotation marks. Oracle Database begins scanning char from its first character and removes all characters that appear in set until reaching a character not in set and then returns the result.
Both char and set can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type, NVARCHAR2 if char is a national character data type, and a LOB if char is a LOB data type.</Function>
    <Function Name="MAKE_REF" Url="http://docs.oracle.com/database/121/SQLRF/functions108.htm">MAKE_REF creates a REF to a row of an object view or a row in an object table whose object identifier is primary key based. This function is useful, for example, if you are creating an object view</Function>
    <Function Name="MAX" Url="http://docs.oracle.com/database/121/SQLRF/functions109.htm">MAX returns maximum value of expr. You can use it as an aggregate or analytic function.</Function>
    <Function Name="MEDIAN" Url="http://docs.oracle.com/database/121/SQLRF/functions110.htm">MEDIAN is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you specify only expr, then the function returns the same data type as the numeric data type of the argument. If you specify the OVER clause, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="MIN" Url="http://docs.oracle.com/database/121/SQLRF/functions111.htm">MIN returns minimum value of expr. You can use it as an aggregate or analytic function.</Function>
    <Function Name="MOD" Url="http://docs.oracle.com/database/121/SQLRF/functions112.htm">MOD returns the remainder of n2 divided by n1. Returns n2 if n1 is 0.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="MONTHS_BETWEEN" Url="http://docs.oracle.com/database/121/SQLRF/functions113.htm">MONTHS_BETWEEN returns number of months between dates date1 and date2. The month and the last day of the month are defined by the parameter NLS_CALENDAR. If date1 is later than date2, then the result is positive. If date1 is earlier than date2, then the result is negative. If date1 and date2 are either the same days of the month or both last days of months, then the result is always an integer. Otherwise Oracle Database calculates the fractional portion of the result based on a 31-day month and considers the difference in time components date1 and date2.</Function>
    <Function Name="NANVL" Url="http://docs.oracle.com/database/121/SQLRF/functions114.htm">The NANVL function is useful only for floating-point numbers of type BINARY_FLOAT or BINARY_DOUBLE. It instructs Oracle Database to return an alternative value n1 if the input value n2 is NaN (not a number). If n2 is not NaN, then Oracle returns n2.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="NCHR" Url="http://docs.oracle.com/database/121/SQLRF/functions115.htm">NCHR returns the character having the binary equivalent to number in the national character set. The value returned is always NVARCHAR2. This function is equivalent to using the CHR function with the USING NCHAR_CS clause.
This function takes as an argument a NUMBER value, or any value that can be implicitly converted to NUMBER, and returns a character.</Function>
    <Function Name="NEW_TIME" Url="http://docs.oracle.com/database/121/SQLRF/functions116.htm">NEW_TIME returns the date and time in time zone timezone2 when date and time in time zone timezone1 are date. Before using this function, you must set the NLS_DATE_FORMAT parameter to display 24-hour time. The return type is always DATE, regardless of the data type of date.</Function>
    <Function Name="NEXT_DAY" Url="http://docs.oracle.com/database/121/SQLRF/functions117.htm">NEXT_DAY returns the date of the first weekday named by char that is later than the date date. The return type is always DATE, regardless of the data type of date. The argument char must be a day of the week in the date language of your session, either the full name or the abbreviation. The minimum number of letters required is the number of letters in the abbreviated version. Any characters immediately following the valid abbreviation are ignored. The return value has the same hours, minutes, and seconds component as the argument date.</Function>
    <Function Name="NLS_CHARSET_DECL_LEN" Url="http://docs.oracle.com/database/121/SQLRF/functions118.htm">NLS_CHARSET_DECL_LEN returns the declaration length (in number of characters) of an NCHAR column. The byte_count argument is the width of the column. The char_set_id argument is the character set ID of the column.</Function>
    <Function Name="NLS_CHARSET_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions119.htm">NLS_CHARSET_ID returns the character set ID number corresponding to character set name string. The string argument is a run-time VARCHAR2 value. The string value 'CHAR_CS' returns the database character set ID number of the server. The string value 'NCHAR_CS' returns the national character set ID number of the server.
Invalid character set names return null.</Function>
    <Function Name="NLS_CHARSET_NAME" Url="http://docs.oracle.com/database/121/SQLRF/functions120.htm">NLS_CHARSET_NAME returns the name of the character set corresponding to ID number number. The character set name is returned as a VARCHAR2 value in the database character set.
If number is not recognized as a valid character set ID, then this function returns null.</Function>
    <Function Name="NLS_INITCAP" Url="http://docs.oracle.com/database/121/SQLRF/functions121.htm">NLS_INITCAP returns char, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The string returned is of VARCHAR2 data type and is in the same character set as char.
The value of 'nlsparam' can have this form:

'NLS_SORT = sort'

where sort is either a linguistic sort sequence or BINARY. The linguistic sort sequence handles special linguistic requirements for case conversions. These requirements can result in a return value of a different length than the char. If you omit 'nlsparam', then this function uses the default sort sequence for your session.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="NLS_LOWER" Url="http://docs.oracle.com/database/121/SQLRF/functions122.htm">NLS_LOWER returns char, with all letters lowercase.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type and a LOB if char is a LOB data type. The return string is in the same character set as char.
The 'nlsparam' can have the same form and serve the same purpose as in the NLS_INITCAP function.</Function>
    <Function Name="NLS_UPPER" Url="http://docs.oracle.com/database/121/SQLRF/functions123.htm">NLS_UPPER returns char, with all letters uppercase.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type and a LOB if char is a LOB data type. The return string is in the same character set as char.
The 'nlsparam' can have the same form and serve the same purpose as in the NLS_INITCAP function.</Function>
    <Function Name="NLSSORT" Url="http://docs.oracle.com/database/121/SQLRF/functions124.htm">NLSSORT returns a collation key for the character value char and an explicitly or implicitly specified collation. A collation key is a string of bytes used to sort char according to the specified collation. The property of the collation keys is that mutual ordering of two such keys generated for the given collation when compared according to their binary order is the same as mutual ordering of the source character values when compared according to the given collation.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2.
The value of 'nlsparam' must have the form

'NLS_SORT = collation'

where collation is the name of a linguistic collation or BINARY. NLSSORT uses the specified collation to generate the collation key. If you omit 'nlsparam', then this function uses the default collation for your session, which is specified in the session parameter NLS_SORT. If you specify BINARY, then this function returns the char value itself cast to RAW and possibly truncated as described below.
If you specify 'nlsparam', then you can append to the linguistic collation name the suffix _ai to request an accent-insensitive collation or _ci to request a case-insensitive collation. Refer to Oracle Database Globalization Support Guide for more information on accent- and case-insensitive sorting. Using accent-insensitive or case-insensitive collations with the ORDER BY query clause is not recommended as it leads to a nondeterministic sort order.
The returned collation key is of RAW data type. The length of the collation key resulting from a given char value for a given collation may exceed the maximum length of the RAW value returned by NLSSORT. In this case, the behavior of NLSSORT depends on the value of the initialization parameter MAX_STRING_SIZE. If MAX_STRING_SIZE = EXTENDED, then the maximum length of the return value is 32767 bytes. If the collation key exceeds this limit, then the function fails with the error "ORA-12742: unable to create the collation key". This error may also be reported for short input strings if they contain a high percentage of Unicode characters with very high decomposition ratios.
If MAX_STRING_SIZE = STANDARD, then the maximum length of the return value is 2000 bytes. If the value to be returned exceeds the limit, then NLSSORT calculates the collation key for a maximum prefix, or initial substring, of char so that the calculated result does not exceed the maximum length. For monolingual collations, for example FRENCH, the prefix length is typically 1000 characters. For multilingual collations, for example GENERIC_M, the prefix is typically 500 characters. For Unicode Collation Algorithm (UCA) collations, for example UCA0610_DUCET, the prefix is typically 285 characters. The exact length may be lower or higher depending on the collation and the characters contained in char.
The behavior when MAX_STRING_SIZE = STANDARD implies that two character values whose collation keys (NLSSORT results) are compared to find the linguistic ordering are considered equal if they do not differ in the prefix even though they may differ at some further character position. Because the NLSSORT function is used implicitly to find linguistic ordering for comparison conditions, the BETWEEN condition, the IN condition, ORDER BY, GROUP BY, and COUNT(DISTINCT), those operations may return results that are only approximate for long character values. If you want guarantee that the results of those operations are exact, then migrate your database to use MAX_STRING_SIZE = EXTENDED.
Refer to "Extended Data Types" for more information on the MAX_STRING_SIZE initialization parameter.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="NTH_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions125.htm">NTH_VALUE returns the measure_expr value of the nth row in the window defined by the analytic_clause. The returned value has the data type of the measure_expr.

{RESPECT | IGNORE} NULLS determines whether null values of measure_expr are included in or eliminated from the calculation. The default is RESPECT NULLS.

n determines the nth row for which the measure value is to be returned. n can be a constant, bind variable, column, or an expression involving them, as long as it resolves to a positive integer. The function returns NULL if the data source window has fewer than n rows. If n is null, then the function returns an error.

FROM {FIRST | LAST} determines whether the calculation begins at the first or last row of the window. The default is FROM FIRST.

If you omit the windowing_clause of the analytic_clause, it defaults to RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. This default sometimes returns an unexpected value for NTH_VALUE ... FROM LAST ... , because the last value in the window is at the bottom of the window, which is not fixed. It keeps changing as the current row changes. For expected results, specify the windowing_clause as RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING. Alternatively, you can specify the windowing_clause as RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING.</Function>
    <Function Name="NTILE" Url="http://docs.oracle.com/database/121/SQLRF/functions126.htm">NTILE is an analytic function. It divides an ordered data set into a number of buckets indicated by expr and assigns the appropriate bucket number to each row. The buckets are numbered 1 through expr. The expr value must resolve to a positive constant for each partition. Oracle Database expects an integer, and if expr is a noninteger constant, then Oracle truncates the value to an integer. The return value is NUMBER.
The number of rows in the buckets can differ by at most 1. The remainder values (the remainder of number of rows divided by buckets) are distributed one for each bucket, starting with bucket 1.
If expr is greater than the number of rows, then a number of buckets equal to the number of rows will be filled, and the remaining buckets will be empty.
You cannot nest analytic functions by using NTILE or any other analytic function for expr. However, you can use other built-in function expressions for expr.</Function>
    <Function Name="NULLIF" Url="http://docs.oracle.com/database/121/SQLRF/functions127.htm">NULLIF compares expr1 and expr2. If they are equal, then the function returns null. If they are not equal, then the function returns expr1. You cannot specify the literal NULL for expr1.
If both arguments are numeric data types, then Oracle Database determines the argument with the higher numeric precedence, implicitly converts the other argument to that data type, and returns that data type. If the arguments are not numeric, then they must be of the same data type, or Oracle returns an error.
The NULLIF function is logically equivalent to the following CASE expression:

CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END</Function>
    <Function Name="NUMTODSINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions128.htm">NUMTODSINTERVAL converts n to an INTERVAL DAY TO SECOND literal. The argument n can be any NUMBER value or an expression that can be implicitly converted to a NUMBER value. The argument interval_unit can be of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type. The value for interval_unit specifies the unit of n and must resolve to one of the following string values:

'DAY'

'HOUR'

'MINUTE'

'SECOND'

interval_unit is case insensitive. Leading and trailing values within the parentheses are ignored. By default, the precision of the return is 9.</Function>
    <Function Name="NUMTOYMINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions129.htm">NUMTOYMINTERVAL converts number n to an INTERVAL YEAR TO MONTH literal. The argument n can be any NUMBER value or an expression that can be implicitly converted to a NUMBER value. The argument interval_unit can be of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type. The value for interval_unit specifies the unit of n and must resolve to one of the following string values:

'YEAR'

'MONTH'

interval_unit is case insensitive. Leading and trailing values within the parentheses are ignored. By default, the precision of the return is 9.</Function>
    <Function Name="NVL" Url="http://docs.oracle.com/database/121/SQLRF/functions130.htm">NVL lets you replace null (returned as a blank) with a string in the results of a query. If expr1 is null, then NVL returns expr2. If expr1 is not null, then NVL returns expr1.
The arguments expr1 and expr2 can have any data type. If their data types are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. The implicit conversion is implemented as follows:

If expr1 is character data, then Oracle Database converts expr2 to the data type of expr1 before comparing them and returns VARCHAR2 in the character set of expr1.

If expr1 is numeric, then Oracle Database determines which argument has the highest numeric precedence, implicitly converts the other argument to that data type, and returns that data type.


See Also:

Table 2-10, "Implicit Type Conversion Matrix" for more information on implicit conversion and "Numeric Precedence" for information on numeric precedence

"COALESCE" and "CASE Expressions", which provide functionality similar to that of NVL</Function>
    <Function Name="NVL2" Url="http://docs.oracle.com/database/121/SQLRF/functions131.htm">NVL2 lets you determine the value returned by a query based on whether a specified expression is null or not null. If expr1 is not null, then NVL2 returns expr2. If expr1 is null, then NVL2 returns expr3.
The argument expr1 can have any data type. The arguments expr2 and expr3 can have any data types except LONG.
If the data types of expr2 and expr3 are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. If expr2 is character or numeric data, then the implicit conversion is implemented as follows:

If expr2 is character data, then Oracle Database converts expr3 to the data type of expr2 before returning a value unless expr3 is a null constant. In that case, a data type conversion is not necessary, and the database returns VARCHAR2 in the character set of expr2.

If expr2 is numeric data, then Oracle Database determines which argument has the highest numeric precedence, implicitly converts the other argument to that data type, and returns that data type.


See Also:
Table 2-10, "Implicit Type Conversion Matrix" for more information on implicit conversion and "Numeric Precedence" for information on numeric precedence</Function>
    <Function Name="ORA_DST_AFFECTED" Url="http://docs.oracle.com/database/121/SQLRF/functions132.htm">ORA_DST_AFFECTED is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values. The function returns 1 if the datetime value is affected by or will result in a "nonexisting time" or "duplicate time" error with the new time zone data. Otherwise, it returns 0.
This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the DBMS_DST.BEGIN_PREPARE and the DBMS_DST.END_PREPARE procedures or between the execution of the DBMS_DST.BEGIN_UPGRADE and the DBMS_DST.END_UPGRADE procedures.</Function>
    <Function Name="ORA_DST_CONVERT" Url="http://docs.oracle.com/database/121/SQLRF/functions133.htm">ORA_DST_CONVERT is useful when you are changing the time zone data file for your database. The function lets you specify error handling for a specified datetime expression.

For datetime_expr, specify a datetime expression that resolves to a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values.

The optional second argument specifies handling of "duplicate time" errors. Specify 0 (false) to suppress the error by returning the source datetime value. This is the default. Specify 1 (true) to allow the database to return the duplicate time error.

The optional third argument specifies handling of "nonexisting time" errors. Specify 0 (false) to suppress the error by returning the source datetime value. This is the default. Specify 1 (true) to allow the database to return the nonexisting time error.

If no error occurs, this function returns a value of the same data type as datetime_expr (a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values). The returned datetime value when interpreted with the new time zone file corresponds to datetime_expr interpreted with the old time zone file.
This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the DBMS_DST.BEGIN_UPGRADE and the DBMS_DST.END_UPGRADE procedures.</Function>
    <Function Name="ORA_DST_ERROR" Url="http://docs.oracle.com/database/121/SQLRF/functions134.htm">ORA_DST_ERROR is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values, and indicates whether the datetime value will result in an error with the new time zone data. The return values are:

0: the datetime value does not result in an error with the new time zone data.

1878: the datetime value results in a "nonexisting time" error.

1883: the datetime value results in a "duplicate time" error.

This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the DBMS_DST.BEGIN_PREPARE and the DBMS_DST.END_PREPARE procedures or between the execution of the DBMS_DST.BEGIN_UPGRADE and the DBMS_DST.END_UPGRADE procedures.</Function>
    <Function Name="ORA_HASH" Url="http://docs.oracle.com/database/121/SQLRF/functions135.htm">ORA_HASH is a function that computes a hash value for a given expression. This function is useful for operations such as analyzing a subset of data and generating a random sample.

The expr argument determines the data for which you want Oracle Database to compute a hash value. There are no restrictions on the length of data represented by expr, which commonly resolves to a column name. The expr cannot be a LONG or LOB type. It cannot be a user-defined object type unless it is a nested table type. The hash value for nested table types does not depend on the order of elements in the collection. All other data types are supported for expr.

The optional max_bucket argument determines the maximum bucket value returned by the hash function. You can specify any value between 0 and 4294967295. The default is 4294967295.

The optional seed_value argument enables Oracle to produce many different results for the same set of data. Oracle applies the hash function to the combination of expr and seed_value. You can specify any value between 0 and 4294967295. The default is 0.

The function returns a NUMBER value.</Function>
    <Function Name="ORA_INVOKING_USER" Url="http://docs.oracle.com/database/121/SQLRF/functions136.htm">ORA_INVOKING_USER returns the name of the database user who invoked the current statement or view. This function takes into account the BEQUEATH property of intervening views referenced in the statement. If this function is invoked from within a definer's rights context, then it returns the name of the owner of the definer's rights object. If the invoking user is a Real Application Security user, then it returns user XS$NULL.
This function returns a VARCHAR2 value.</Function>
    <Function Name="ORA_INVOKING_USERID" Url="http://docs.oracle.com/database/121/SQLRF/functions137.htm">ORA_INVOKING_USERID returns the identifier of the database user who invoked the current statement or view. This function takes into account the BEQUEATH property of intervening views referenced in the statement.
This function returns a NUMBER value.</Function>
    <Function Name="PATH" Url="http://docs.oracle.com/database/121/SQLRF/functions138.htm">PATH is an ancillary function used only with the UNDER_PATH and EQUALS_PATH conditions. It returns the relative path that leads to the resource specified in the parent condition.
The correlation_integer can be any NUMBER integer and is used to correlate this ancillary function with its primary condition. Values less than 1 are treated as 1.</Function>
    <Function Name="PERCENT_RANK" Url="http://docs.oracle.com/database/121/SQLRF/functions139.htm">PERCENT_RANK is similar to the CUME_DIST (cumulative distribution) function. The range of values returned by PERCENT_RANK is 0 to 1, inclusive. The first row in any set has a PERCENT_RANK of 0. The return value is NUMBER.</Function>
    <Function Name="PERCENTILE_CONT" Url="http://docs.oracle.com/database/121/SQLRF/functions140.htm">PERCENTILE_CONT is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="PERCENTILE_DISC" Url="http://docs.oracle.com/database/121/SQLRF/functions141.htm">PERCENTILE_DISC is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="POWER" Url="http://docs.oracle.com/database/121/SQLRF/functions142.htm">POWER returns n2 raised to the n1 power. The base n2 and the exponent n1 can be any numbers, but if n2 is negative, then n1 must be an integer.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is BINARY_FLOAT or BINARY_DOUBLE, then the function returns BINARY_DOUBLE. Otherwise, the function returns NUMBER.</Function>
    <Function Name="POWERMULTISET" Url="http://docs.oracle.com/database/121/SQLRF/functions143.htm">POWERMULTISET takes as input a nested table and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the input nested table.

expr can be any expression that evaluates to a nested table.

If expr resolves to null, then Oracle Database returns NULL.

If expr resolves to a nested table that is empty, then Oracle returns an error.

The element types of the nested table must be comparable. Refer to "Comparison Conditions" for information on the comparability of nonscalar types.


Note:
This function is not supported in PL/SQL.</Function>
    <Function Name="POWERMULTISET_BY_CARDINALITY" Url="http://docs.oracle.com/database/121/SQLRF/functions144.htm">POWERMULTISET_BY_CARDINALITY takes as input a nested table and a cardinality and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the nested table of the specified cardinality.

expr can be any expression that evaluates to a nested table.

cardinality can be any positive integer.

If expr resolves to null, then Oracle Database returns NULL.

If expr resolves to a nested table that is empty, then Oracle returns an error.

The element types of the nested table must be comparable. Refer to "Comparison Conditions" for information on the comparability of nonscalar types.


Note:
This function is not supported in PL/SQL.</Function>
    <Function Name="PREDICTION" Url="http://docs.oracle.com/database/121/SQLRF/functions145.htm">PREDICTION returns a prediction for each row in the selection. The data type of the returned prediction depends on whether the function performs regression, classification, or anomaly detection.

Regression — Returns the expected target value for each row. The data type of the return value is the data type of the target.

Classification — Returns the most probable target class (or lowest cost target class, if costs are specified) for each row. The data type of the return value is the data type of the target.

Anomaly Detection — Returns 1 or 0 for each row. Typical rows are classified as 1. Rows that differ significantly from the rest of the data are classified as 0.


cost_matrix_clause
Costs are a biasing factor for minimizing the most harmful kinds of misclassifications. You can specify cost_matrix_clause for classification or anomaly detection. Costs are not relevant for regression. The cost_matrix_clause behaves as described for "PREDICTION_COST".

Syntax Choice
PREDICTION can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically score the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification, regression, or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause , which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For regression, specify FOR expr, where expr is an expression that identifies a target column that has a numeric data type.

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For anomaly detection, specify the keywords OF ANOMALY.




mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring.

If you specify USING *, all the relevant attributes present in the input row are used.

If you invoke the function with the analytic syntax, the mining_attribute_clause is used both for building the transient models and for scoring.

It you invoke the function with a pre-defined model, the mining_attribute_clause should include all or some of the attributes that were used to create the model. The following conditions apply:

If mining_attribute_clause includes an attribute with the same name but a different data type from the one that was used to create the model, then the data type is converted to the type expected by the model.

If you specify more attributes for scoring than were used to create the model, then the extra attributes are silently ignored.

If you specify fewer attributes for scoring than were used to create the model, then scoring is performed on a best-effort basis.</Function>
    <Function Name="PREDICTION_BOUNDS" Url="http://docs.oracle.com/database/121/SQLRF/functions146.htm">PREDICTION_BOUNDS applies a Generalized Linear Model (GLM) to predict a class or a value for each row in the selection. The function returns the upper and lower bounds of each prediction in a varray of objects with fields UPPER and LOWER.
GLM can perform either regression or binary classification:

The bounds for regression refer to the predicted target value. The data type of UPPER and LOWER is the data type of the target.

The bounds for binary classification refer to the probability of either the predicted target class or the specified class_value. The data type of UPPER and LOWER is BINARY_DOUBLE.

If the model was built using ridge regression, or if the covariance matrix is found to be singular during the build, then PREDICTION_BOUNDS returns NULL for both bounds.
confidence_level is a number in the range (0,1). The default value is 0.95. You can specify class_value while leaving confidence_level at its default by specifying NULL for confidence_level.

mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. This clause behaves as described for the PREDICTION function. (Note that the reference to analytic syntax does not apply.) See "mining_attribute_clause::=".</Function>
    <Function Name="PREDICTION_COST" Url="http://docs.oracle.com/database/121/SQLRF/functions147.htm">PREDICTION_COST returns a cost for each row in the selection. The cost refers to the lowest cost class or to the specified class. The cost is returned as BINARY_DOUBLE.
PREDICTION_COST can perform classification or anomaly detection. For classification, the returned cost refers to a predicted target class. For anomaly detection, the returned cost refers to a classification of 1 (for typical rows) or 0 (for anomalous rows).
You can use PREDICTION_COST in conjunction with the PREDICTION function to obtain the prediction and the cost of the prediction.


cost_matrix_clause
Costs are a biasing factor for minimizing the most harmful kinds of misclassifications. For example, false positives might be considered more costly than false negatives. Costs are specified in a cost matrix that can be associated with the model or defined inline in a VALUES clause. All classification algorithms can use costs to influence scoring.
Decision Tree is the only algorithm that can use costs to influence the model build. The cost matrix used to build a Decision Tree model is also the default scoring cost matrix for the model.
The following cost matrix table specifies that the misclassification of 1 is five times more costly than the misclassification of 0.

ACTUAL_TARGET_VALUE PREDICTED_TARGET_VALUE       COST
------------------- ---------------------- ----------
                  0                      0          0
                  0                      1          1
                  1                      0          5
                  1                      1          0

In cost_matrix_clause:

COST MODEL indicates that scoring should be performed by taking into account the scoring cost matrix associated with the model. If the cost matrix does not exist, then the function returns an error.

COST MODEL AUTO indicates that the existence of a cost matrix is unknown. If a cost matrix exists, then the function uses it to return the lowest cost prediction. Otherwise the function returns the highest probability prediction.

The VALUES clause specifies an inline cost matrix for class_value. For example, you could specify that the misclassification of 1 is five times more costly than the misclassification of 0 as follows:

   PREDICTION (nb_model COST (0,1) VALUES ((0, 1),(1, 5)) USING *)

If a model that has a scoring cost matrix is invoked with an inline cost matrix, then the inline costs are used.



See Also:
Oracle Data Mining User's Guide for more information about cost-sensitive prediction.




Syntax Choice
PREDICTION_COST can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause , which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For anomaly detection, specify the keywords OF ANOMALY.



mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="PREDICTION_DETAILS" Url="http://docs.oracle.com/database/121/SQLRF/functions148.htm">PREDICTION_DETAILS returns prediction details for each row in the selection. The return value is an XML string that describes the attributes of the prediction.
For regression, the returned details refer to the predicted target value. For classification and anomaly detection, the returned details refer to the highest probability class or the specified class_value.

topN
If you specify a value for topN, the function returns the N attributes that have the most influence on the prediction (the score). If you do not specify topN, the function returns the 5 most influential attributes.

DESC, ASC, or ABS
The returned attributes are ordered by weight. The weight of an attribute expresses its positive or negative impact on the prediction. For regression, a positive weight indicates a higher value prediction; a negative weight indicates a lower value prediction. For classification and anomaly detection, a positive weight indicates a higher probability prediction; a negative weight indicates a lower probability prediction.
By default, PREDICTION_DETAILS returns the attributes with the highest positive weight (DESC). If you specify ASC, the attributes with the highest negative weight are returned. If you specify ABS, the attributes with the greatest weight, whether negative or positive, are returned. The results are ordered by absolute value from highest to lowest. Attributes with a zero weight are not included in the output.

Syntax Choice
PREDICTION_DETAILS can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification, regression, or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For regression, specify FOR expr, where expr is an expression that identifies a target column that has a numeric data type.

For anomaly detection, specify the keywords OF ANOMALY.



mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="PREDICTION_PROBABILITY" Url="http://docs.oracle.com/database/121/SQLRF/functions149.htm">PREDICTION_PROBABILITY returns a probability for each row in the selection. The probability refers to the highest probability class or to the specified class. The data type of the returned probability is BINARY_DOUBLE.
PREDICTION_PROBABILITY can perform classification or anomaly detection. For classification, the returned probability refers to a predicted target class. For anomaly detection, the returned probability refers to a classification of 1 (for typical rows) or 0 (for anomalous rows).
You can use PREDICTION_PROBABILITY in conjunction with the PREDICTION function to obtain the prediction and the probability of the prediction.

Syntax Choice
PREDICTION_PROBABILITY can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For anomaly detection, specify the keywords OF ANOMALY.



mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="PREDICTION_SET" Url="http://docs.oracle.com/database/121/SQLRF/functions150.htm">PREDICTION_SET returns a set of predictions with either probabilities or costs for each row in the selection. The return value is a varray of objects with field names PREDICTION_ID and PROBABILITY or COST. The prediction identifier is an Oracle NUMBER; the probability and cost fields are BINARY_DOUBLE.
PREDICTION_SET can perform classification or anomaly detection. For classification, the return value refers to a predicted target class. For anomaly detection, the return value refers to a classification of 1 (for typical rows) or 0 (for anomalous rows).

bestN and cutoff
You can specify bestN and cutoff to limit the number of predictions returned by the function. By default, both bestN and cutoff are null and all predictions are returned.

bestN is the N predictions that are either the most probable or the least costly. If multiple predictions share the Nth probability or cost, then the function chooses one of them.

cutoff is a value threshold. Only predictions with probability greater than or equal to cutoff, or with cost less than or equal to cutoff, are returned. To filter by cutoff only, specify NULL for bestN. If the function uses a cost_matrix_clause with COST MODEL AUTO, then cutoff is ignored.

You can specify bestN with cutoff to return up to the N most probable predictions that are greater than or equal to cutoff. If costs are used, specify bestN with cutoff to return up to the N least costly predictions that are less than or equal to cutoff.

cost_matrix_clause
You can specify cost_matrix_clause as a biasing factor for minimizing the most harmful kinds of misclassifications. cost_matrix_clause behaves as described for "PREDICTION_COST".

Syntax Choice
PREDICTION_SET can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For anomaly detection, specify the keywords OF ANOMALY.



mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="PRESENTNNV" Url="http://docs.oracle.com/database/121/SQLRF/functions151.htm">The PRESENTNNV function can be used only in the model_clause of the SELECT statement and then only on the right-hand side of a model rule. It returns expr1 when cell_reference exists prior to the execution of the model_clause and is not null when PRESENTNNV is evaluated. Otherwise it returns expr2. This function differs from NVL2 in that NVL2 evaluates the data at the time it is executed, rather than evaluating the data as it was prior to the execution of the model_clause.</Function>
    <Function Name="PRESENTV" Url="http://docs.oracle.com/database/121/SQLRF/functions152.htm">The PRESENTV function can be used only within the model_clause of the SELECT statement and then only on the right-hand side of a model rule. It returns expr1 when, prior to the execution of the model_clause, cell_reference exists. Otherwise it returns expr2.</Function>
    <Function Name="PREVIOUS" Url="http://docs.oracle.com/database/121/SQLRF/functions153.htm">The PREVIOUS function can be used only in the model_clause of the SELECT statement and then only in the ITERATE ... [ UNTIL ] clause of the model_rules_clause. It returns the value of cell_reference at the beginning of each iteration.</Function>
    <Function Name="RANK" Url="http://docs.oracle.com/database/121/SQLRF/functions154.htm">RANK calculates the rank of a value in a group of values. The return type is NUMBER.</Function>
    <Function Name="RATIO_TO_REPORT" Url="http://docs.oracle.com/database/121/SQLRF/functions155.htm">RATIO_TO_REPORT is an analytic function. It computes the ratio of a value to the sum of a set of values. If expr evaluates to null, then the ratio-to-report value also evaluates to null.
The set of values is determined by the query_partition_clause. If you omit that clause, then the ratio-to-report is computed over all rows returned by the query.
You cannot nest analytic functions by using RATIO_TO_REPORT or any other analytic function for expr. However, you can use other built-in function expressions for expr. Refer to "About SQL Expressions" for information on valid forms of expr.</Function>
    <Function Name="RAWTOHEX" Url="http://docs.oracle.com/database/121/SQLRF/functions156.htm">RAWTOHEX converts raw to a character value containing its hexadecimal representation.
As a SQL built-in function, RAWTOHEX accepts an argument of any scalar data type other than LONG, LONG RAW, CLOB, BLOB, or BFILE. It returns a VARCHAR2 value with the hexadecimal representation of bytes that make up the value of raw. Each byte is represented by two hexadecimal digits.</Function>
    <Function Name="RAWTONHEX" Url="http://docs.oracle.com/database/121/SQLRF/functions157.htm">RAWTONHEX converts raw to a character value containing its hexadecimal representation. RAWTONHEX (raw) is equivalent to TO_NCHAR(RAWTOHEX(raw)). The value returned is always in the national character set.</Function>
    <Function Name="REF" Url="http://docs.oracle.com/database/121/SQLRF/functions158.htm">REF takes as its argument a correlation variable (table alias) associated with a row of an object table or an object view. A REF value is returned for the object instance that is bound to the variable or row.</Function>
    <Function Name="REFTOHEX" Url="http://docs.oracle.com/database/121/SQLRF/functions159.htm">REFTOHEX converts argument expr to a character value containing its hexadecimal equivalent. expr must return a REF.</Function>
    <Function Name="REGEXP_COUNT" Url="http://docs.oracle.com/database/121/SQLRF/functions160.htm">REGEXP_COUNT complements the functionality of the REGEXP_INSTR function by returning the number of times a pattern occurs in a source string. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the number of occurrences of pattern. If no match is found, then the function returns 0.

source_char is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

pattern is the regular expression. It is usually a text literal and can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. It can contain up to 512 bytes. If the data type of pattern is different from the data type of source_char, then Oracle Database converts pattern to the data type of source_char.
REGEXP_COUNT ignores subexpression parentheses in pattern. For example, the pattern '(123(45))' is equivalent to '12345'. For a listing of the operators you can specify in pattern, refer to Appendix D, "Oracle Regular Expression Support".

position is a positive integer indicating the character of source_char where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of source_char. After finding the first occurrence of pattern, the database searches for a second occurrence beginning with the first character following the first occurrence.

match_param is a text literal that lets you change the default matching behavior of the function. You can specify one or more of the following values for match_param:

'i' specifies case-insensitive matching.

'c' specifies case-sensitive matching.

'n' allows the period (.), which is the match-any-character character, to match the newline character. If you omit this parameter, then the period does not match the newline character.

'm' treats the source string as multiple lines. Oracle interprets the caret (^) and dollar sign ($) as the start and end, respectively, of any line anywhere in the source string, rather than only at the start or end of the entire source string. If you omit this parameter, then Oracle treats the source string as a single line.

'x' ignores whitespace characters. By default, whitespace characters match themselves.

If you specify multiple contradictory values, then Oracle uses the last value. For example, if you specify 'ic', then Oracle uses case-sensitive matching. If you specify a character other than those shown above, then Oracle returns an error.
If you omit match_param, then:

The default case sensitivity is determined by the value of the NLS_SORT parameter.

A period (.) does not match the newline character.

The source string is treated as a single line.</Function>
    <Function Name="REGEXP_INSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions161.htm">REGEXP_INSTR extends the functionality of the INSTR function by letting you search a string for a regular expression pattern. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the beginning or ending position of the matched substring, depending on the value of the return_option argument. If no match is found, then the function returns 0.
This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to Appendix D, "Oracle Regular Expression Support".

source_char is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

pattern is the regular expression. It is usually a text literal and can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. It can contain up to 512 bytes. If the data type of pattern is different from the data type of source_char, then Oracle Database converts pattern to the data type of source_char. For a listing of the operators you can specify in pattern, refer to Appendix D, "Oracle Regular Expression Support".

position is a positive integer indicating the character of source_char where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of source_char.

occurrence is a positive integer indicating which occurrence of pattern in source_char Oracle should search for. The default is 1, meaning that Oracle searches for the first occurrence of pattern. If occurrence is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of pattern, and so forth. This behavior is different from the INSTR function, which begins its search for the second occurrence at the second character of the first occurrence.

return_option lets you specify what Oracle should return in relation to the occurrence:

If you specify 0, then Oracle returns the position of the first character of the occurrence. This is the default.

If you specify 1, then Oracle returns the position of the character following the occurrence.


match_parameter is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for REGEXP_COUNT. Refer to REGEXP_COUNT for detailed information.

For a pattern with subexpressions, subexpr is an integer from 0 to 9 indicating which subexpression in pattern is the target of the function. The subexpr is a fragment of pattern enclosed in parentheses. Subexpressions can be nested. Subexpressions are numbered in order in which their left parentheses appear in pattern. For example, consider the following expression:

0123(((abc)(de)f)ghi)45(678)

This expression has five subexpressions in the following order: "abcdefghi" followed by "abcdef", "abc", "de" and "678".
If subexpr is zero, then the position of the entire substring that matches the pattern is returned. If subexpr is greater than zero, then the position of the substring fragment that corresponds to subexpression number subexpr in the matched substring is returned. If pattern does not have at least subexpr subexpressions, the function returns zero. A null subexpr value returns NULL. The default value for subexpr is zero.</Function>
    <Function Name="REGEXP_REPLACE" Url="http://docs.oracle.com/database/121/SQLRF/functions162.htm">REGEXP_REPLACE extends the functionality of the REPLACE function by letting you search a string for a regular expression pattern. By default, the function returns source_char with every occurrence of the regular expression pattern replaced with replace_string. The string returned is in the same character set as source_char. The function returns VARCHAR2 if the first argument is not a LOB and returns CLOB if the first argument is a LOB.
This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to Appendix D, "Oracle Regular Expression Support".

source_char is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB or NCLOB.

pattern is the regular expression. It is usually a text literal and can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. It can contain up to 512 bytes. If the data type of pattern is different from the data type of source_char, then Oracle Database converts pattern to the data type of source_char. For a listing of the operators you can specify in pattern, refer to Appendix D, "Oracle Regular Expression Support".

replace_string can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. If replace_string is a CLOB or NCLOB, then Oracle truncates replace_string to 32K. The replace_string can contain up to 500 backreferences to subexpressions in the form \n, where n is a number from 1 to 9. If you want to include a backslash (\) in replace_string, then you must precede it with the escape character, which is also a backslash. For example, to replace \2 you would enter \\2. For more information on backreference expressions, refer to the notes to "Oracle Regular Expression Support", Table D-1.

position is a positive integer indicating the character of source_char where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of source_char.

occurrence is a nonnegative integer indicating the occurrence of the replace operation:

If you specify 0, then Oracle replaces all occurrences of the match.

If you specify a positive integer n, then Oracle replaces the nth occurrence.

If occurrence is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of pattern, and so forth. This behavior is different from the INSTR function, which begins its search for the second occurrence at the second character of the first occurrence.

match_parameter is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for REGEXP_COUNT. Refer to REGEXP_COUNT for detailed information.</Function>
    <Function Name="REGEXP_SUBSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions163.htm">REGEXP_SUBSTR extends the functionality of the SUBSTR function by letting you search a string for a regular expression pattern. It is also similar to REGEXP_INSTR, but instead of returning the position of the substring, it returns the substring itself. This function is useful if you need the contents of a match string but not its position in the source string. The function returns the string as VARCHAR2 or CLOB data in the same character set as source_char.
This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to Appendix D, "Oracle Regular Expression Support".

source_char is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

pattern is the regular expression. It is usually a text literal and can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. It can contain up to 512 bytes. If the data type of pattern is different from the data type of source_char, then Oracle Database converts pattern to the data type of source_char. For a listing of the operators you can specify in pattern, refer to Appendix D, "Oracle Regular Expression Support".

position is a positive integer indicating the character of source_char where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of source_char.

occurrence is a positive integer indicating which occurrence of pattern in source_char Oracle should search for. The default is 1, meaning that Oracle searches for the first occurrence of pattern.
If occurrence is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of pattern, and so forth. This behavior is different from the SUBSTR function, which begins its search for the second occurrence at the second character of the first occurrence.

match_parameter is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for REGEXP_COUNT. Refer to REGEXP_COUNT for detailed information.

For a pattern with subexpressions, subexpr is a nonnegative integer from 0 to 9 indicating which subexpression in pattern is to be returned by the function. This parameter has the same semantics that it has for the REGEXP_INSTR function. Refer to REGEXP_INSTR for more information.</Function>
    <Function Name="REMAINDER" Url="http://docs.oracle.com/database/121/SQLRF/functions165.htm">REMAINDER returns the remainder of n2 divided by n1.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.
The MOD function is similar to REMAINDER except that it uses FLOOR in its formula, whereas REMAINDER uses ROUND. Refer to MOD.</Function>
    <Function Name="REPLACE" Url="http://docs.oracle.com/database/121/SQLRF/functions166.htm">REPLACE returns char with every occurrence of search_string replaced with replacement_string. If replacement_string is omitted or null, then all occurrences of search_string are removed. If search_string is null, then char is returned.
Both search_string and replacement_string, as well as char, can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is in the same character set as char. The function returns VARCHAR2 if the first argument is not a LOB and returns CLOB if the first argument is a LOB.
REPLACE provides functionality related to that provided by the TRANSLATE function. TRANSLATE provides single-character, one-to-one substitution. REPLACE lets you substitute one string for another as well as to remove character strings.</Function>
    <Function Name="ROUND" Url="http://docs.oracle.com/database/121/SQLRF/functions167.htm">ROUND returns date rounded to the unit specified by the format model fmt. This function is not sensitive to the NLS_CALENDAR session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type DATE, even if you specify a different datetime data type for date. If you omit fmt, then date is rounded to the nearest day. The date expression must resolve to a DATE value.</Function>
    <Function Name="ROUND" Url="http://docs.oracle.com/database/121/SQLRF/functions168.htm">ROUND returns n rounded to integer places to the right of the decimal point. If you omit integer, then n is rounded to zero places. If integer is negative, then n is rounded off to the left of the decimal point.
n can be any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit integer, then the function returns the value ROUND(n, 0) in the same data type as the numeric data type of n. If you include integer, then the function returns NUMBER.
ROUND is implemented using the following rules:

If n is 0, then ROUND always returns 0 regardless of integer.

If n is negative, then ROUND(n, integer) returns -ROUND(-n, integer).

If n is positive, then

ROUND(n, integer) = FLOOR(n * POWER(10, integer) + 0.5) * POWER(10, -integer)

ROUND applied to a NUMBER value may give a slightly different result from ROUND applied to the same value expressed in floating-point. The different results arise from differences in internal representations of NUMBER and floating point values. The difference will be 1 in the rounded digit if a difference occurs.</Function>
    <Function Name="ROW_NUMBER" Url="http://docs.oracle.com/database/121/SQLRF/functions169.htm">ROW_NUMBER is an analytic function. It assigns a unique number to each row to which it is applied (either each row in the partition or each row returned by the query), in the ordered sequence of rows specified in the order_by_clause, beginning with 1.
By nesting a subquery using ROW_NUMBER inside a query that retrieves the ROW_NUMBER values for a specified range, you can find a precise subset of rows from the results of the inner query. This use of the function lets you implement top-N, bottom-N, and inner-N reporting. For consistent results, the query must ensure a deterministic sort order.
You cannot nest analytic functions by using ROW_NUMBER or any other analytic function for expr. However, you can use other built-in function expressions for expr. Refer to "About SQL Expressions" for information on valid forms of expr.</Function>
    <Function Name="ROWIDTOCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions170.htm">ROWIDTOCHAR converts a rowid value to VARCHAR2 data type. The result of this conversion is always 18 characters long.</Function>
    <Function Name="ROWIDTONCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions171.htm">ROWIDTONCHAR converts a rowid value to NVARCHAR2 data type. The result of this conversion is always in the national character set and is 18 characters long.</Function>
    <Function Name="RPAD" Url="http://docs.oracle.com/database/121/SQLRF/functions172.htm">RPAD returns expr1, right-padded to length n characters with expr2, replicated as many times as necessary. This function is useful for formatting the output of a query.
Both expr1 and expr2 can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if expr1 is a character data type, NVARCHAR2 if expr1 is a national character data type, and a LOB if expr1 is a LOB data type. The string returned is in the same character set as expr1. The argument n must be a NUMBER integer or a value that can be implicitly converted to a NUMBER integer.
expr1 cannot be null. If you do not specify expr2, then it defaults to a single blank. If expr1 is longer than n, then this function returns the portion of expr1 that fits in n.
The argument n is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string.</Function>
    <Function Name="RTRIM" Url="http://docs.oracle.com/database/121/SQLRF/functions173.htm">RTRIM removes from the right end of char all of the characters that appear in set. This function is useful for formatting the output of a query.
If you do not specify set, then it defaults to a single blank. If char is a character literal, then you must enclose it in single quotation marks. RTRIM works similarly to LTRIM.
Both char and set can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type, NVARCHAR2 if char is a national character data type, and a LOB if char is a LOB data type.</Function>
    <Function Name="SCN_TO_TIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions174.htm">SCN_TO_TIMESTAMP takes as an argument a number that evaluates to a system change number (SCN), and returns the approximate timestamp associated with that SCN. The returned value is of TIMESTAMP data type. This function is useful any time you want to know the timestamp associated with an SCN. For example, it can be used in conjunction with the ORA_ROWSCN pseudocolumn to associate a timestamp with the most recent change to a row.</Function>
    <Function Name="SESSIONTIMEZONE" Url="http://docs.oracle.com/database/121/SQLRF/functions175.htm">SESSIONTIMEZONE returns the time zone of the current session. The return type is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the user specified the session time zone value in the most recent ALTER SESSION statement.</Function>
    <Function Name="SET" Url="http://docs.oracle.com/database/121/SQLRF/functions176.htm">SET converts a nested table into a set by eliminating duplicates. The function returns a nested table whose elements are distinct from one another. The returned nested table is of the same type as the input nested table.
The element types of the nested table must be comparable. Refer to "Comparison Conditions" for information on the comparability of nonscalar types.</Function>
    <Function Name="SIGN" Url="http://docs.oracle.com/database/121/SQLRF/functions177.htm">SIGN returns the sign of n. This function takes as an argument any numeric data type, or any nonnumeric data type that can be implicitly converted to NUMBER, and returns NUMBER.
For value of NUMBER type, the sign is:

-1 if n&lt;0

0 if n=0

1 if n&gt;0

For binary floating-point numbers (BINARY_FLOAT and BINARY_DOUBLE), this function returns the sign bit of the number. The sign bit is:

-1 if n&lt;0

+1 if n&gt;=0 or n=NaN</Function>
    <Function Name="SIN" Url="http://docs.oracle.com/database/121/SQLRF/functions178.htm">SIN returns the sine of n (an angle expressed in radians).
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="SINH" Url="http://docs.oracle.com/database/121/SQLRF/functions179.htm">SINH returns the hyperbolic sine of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="SOUNDEX" Url="http://docs.oracle.com/database/121/SQLRF/functions180.htm">SOUNDEX returns a character string containing the phonetic representation of char. This function lets you compare words that are spelled differently, but sound alike in English.
The phonetic representation is defined in The Art of Computer Programming, Volume 3: Sorting and Searching, by Donald E. Knuth, as follows:

Retain the first letter of the string and remove all other occurrences of the following letters: a, e, h, i, o, u, w, y.

Assign numbers to the remaining letters (after the first) as follows:

b, f, p, v = 1
c, g, j, k, q, s, x, z = 2
d, t = 3
l = 4
m, n = 5
r = 6

If two or more letters with the same number were adjacent in the original name (before step 1), or adjacent except for any intervening h and w, then retain the first letter and omit rest of all the adjacent letters with same number.

Return the first four bytes padded with 0.

char can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The return value is the same data type as char.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="SQRT" Url="http://docs.oracle.com/database/121/SQLRF/functions181.htm">SQRT returns the square root of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="STANDARD_HASH" Url="http://docs.oracle.com/database/121/SQLRF/functions182.htm">STANDARD_HASH computes a hash value for a given expression using one of several hash algorithms that are defined and standardized by the National Institute of Standards and Technology. This function is useful for performing authentication and maintaining data integrity in security applications such as digital signatures, checksums, and fingerprinting.
You can use the STANDARD_HASH function to create an index on an extended data type column. Refer to "Creating an Index on an Extended Data Type Column" for more information.

The expr argument determines the data for which you want Oracle Database to compute a hash value. There are no restrictions on the length of data represented by expr, which commonly resolves to a column name. The expr cannot be a LONG or LOB type. It cannot be a user-defined object type. All other data types are supported for expr.

The optional method argument lets you specify the name of the hash algorithm to be used. Valid algorithms are SHA1, SHA256, SHA384, SHA512, and MD5. If you omit this argument, then SHA1 is used.

The function returns a RAW value.</Function>
    <Function Name="STATS_BINOMIAL_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions183.htm">STATS_BINOMIAL_TEST is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small.
This function takes four arguments: expr1 is the sample being examined. expr2 contains the values for which the proportion is expected to be, and p is a proportion to test against. The fourth argument is a return value of type VARCHAR2. If you omit the fourth argument, then the default is TWO_SIDED_PROB. The meaning of the return values is shown in Table 7-3.</Function>
    <Function Name="STATS_CROSSTAB" Url="http://docs.oracle.com/database/121/SQLRF/functions184.htm">Crosstabulation (commonly called crosstab) is a method used to analyze two nominal variables. The STATS_CROSSTAB function takes three arguments: two expressions and a return value of type VARCHAR2. expr1 and expr2 are the two variables being analyzed. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is CHISQ_SIG. The meaning of the return values is shown in Table 7-4.</Function>
    <Function Name="STATS_F_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions185.htm">STATS_F_TEST tests whether two variances are significantly different. The observed value of f is the ratio of one variance to the other, so values very different from 1 usually indicate significant differences.
This function takes three arguments: expr1 is the grouping or independent variable and expr2 is the sample of values. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is TWO_SIDED_SIG. The meaning of the return values is shown in Table 7-5.</Function>
    <Function Name="STATS_KS_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions186.htm">STATS_KS_TEST is a Kolmogorov-Smirnov function that compares two samples to test whether they are from the same population or from populations that have the same distribution. It does not assume that the population from which the samples were taken is normally distributed.
This function takes three arguments: two expressions and a return value of type VARCHAR2. expr1 classifies the data into the two samples. expr2 contains the values for each of the samples. If expr1 classifies the rows into only one sample or into more than two samples, then an error is raised.The function returns one value determined by the third argument. If you omit the third argument, then the default is SIG. The meaning of the return values is shown in Table 7-6.</Function>
    <Function Name="STATS_MODE" Url="http://docs.oracle.com/database/121/SQLRF/functions187.htm">STATS_MODE takes as its argument a set of values and returns the value that occurs with the greatest frequency. If more than one mode exists, then Oracle Database chooses one and returns only that one value.
To obtain multiple modes (if multiple modes exist), you must use a combination of other functions, as shown in the hypothetical query:

SELECT x FROM (SELECT x, COUNT(x) AS cnt1
   FROM t GROUP BY x)
   WHERE cnt1 =
      (SELECT MAX(cnt2) FROM (SELECT COUNT(x) AS cnt2 FROM t GROUP BY x));</Function>
    <Function Name="STATS_ONE_WAY_ANOVA" Url="http://docs.oracle.com/database/121/SQLRF/functions189.htm">The one-way analysis of variance function (STATS_ONE_WAY_ANOVA) tests differences in means (for groups or variables) for statistical significance by comparing two different estimates of variance. One estimate is based on the variances within each group or category. This is known as the mean squares within or mean square error. The other estimate is based on the variances among the means of the groups. This is known as the mean squares between. If the means of the groups are significantly different, then the mean squares between will be larger than expected and will not match the mean squares within. If the mean squares of the groups are consistent, then the two variance estimates will be about the same.
STATS_ONE_WAY_ANOVA takes three arguments: two expressions and a return value of type VARCHAR2. expr1 is an independent or grouping variable that divides the data into a set of groups. expr2 is a dependent variable (a numeric expression) containing the values corresponding to each member of a group. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is SIG. The meaning of the return values is shown in Table 7-8.</Function>
    <Function Name="STATS_T_TEST_" Url="http://docs.oracle.com/database/121/SQLRF/functions190.htm">The t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample STATS_T_TEST_* functions take three arguments: two expressions and a return value of type VARCHAR2. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is TWO_SIDED_SIG. The meaning of the return values is shown in Table 7-9.</Function>
    <Function Name="STATS_WSR_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions191.htm">STATS_WSR_TEST is a Wilcoxon Signed Ranks test of paired samples to determine whether the median of the differences between the samples is significantly different from zero. The absolute values of the differences are ordered and assigned ranks. Then the null hypothesis states that the sum of the ranks of the positive differences is equal to the sum of the ranks of the negative differences.
This function takes three arguments: expr1 and expr2 are the two samples being analyzed, and the third argument is a return value of type VARCHAR2. If you omit the third argument, then the default is TWO_SIDED_SIG. The meaning of the return values is shown in Table 7-10.</Function>
    <Function Name="STDDEV" Url="http://docs.oracle.com/database/121/SQLRF/functions192.htm">STDDEV returns the sample standard deviation of expr, a set of numbers. You can use it as both an aggregate and analytic function. It differs from STDDEV_SAMP in that STDDEV returns zero when it has only 1 row of input data, whereas STDDEV_SAMP returns null.
Oracle Database calculates the standard deviation as the square root of the variance defined for the VARIANCE aggregate function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="STDDEV_POP" Url="http://docs.oracle.com/database/121/SQLRF/functions193.htm">STDDEV_POP computes the population standard deviation and returns the square root of the population variance. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="STDDEV_SAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions194.htm">STDDEV_SAMP computes the cumulative sample standard deviation and returns the square root of the sample variance. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="SUBSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions195.htm">The SUBSTR functions return a portion of char, beginning at character position, substring_length characters long. SUBSTR calculates lengths using characters as defined by the input character set. SUBSTRB uses bytes instead of characters. SUBSTRC uses Unicode complete characters. SUBSTR2 uses UCS2 code points. SUBSTR4 uses UCS4 code points.

If position is 0, then it is treated as 1.

If position is positive, then Oracle Database counts from the beginning of char to find the first character.

If position is negative, then Oracle counts backward from the end of char.

If substring_length is omitted, then Oracle returns all characters to the end of char. If substring_length is less than 1, then Oracle returns null.

char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The exceptions are SUBSTRC, SUBSTR2, and SUBSTR4, which do not allow char to be a CLOB or NCLOB. Both position and substring_length must be of data type NUMBER, or any data type that can be implicitly converted to NUMBER, and must resolve to an integer. The return value is the same data type as char. Floating-point numbers passed as arguments to SUBSTR are automatically converted to integers.</Function>
    <Function Name="SUM" Url="http://docs.oracle.com/database/121/SQLRF/functions196.htm">SUM returns the sum of values of expr. You can use it as an aggregate or analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="SYS_CONNECT_BY_PATH" Url="http://docs.oracle.com/database/121/SQLRF/functions197.htm">SYS_CONNECT_BY_PATH is valid only in hierarchical queries. It returns the path of a column value from root to node, with column values separated by char for each row returned by CONNECT BY condition.
Both column and char can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The string returned is of VARCHAR2 data type and is in the same character set as column.</Function>
    <Function Name="SYS_CONTEXT" Url="http://docs.oracle.com/database/121/SQLRF/functions198.htm">SYS_CONTEXT returns the value of parameter associated with the context namespace at the current instant. You can use this function in both SQL and PL/SQL statements. SYS_CONTEXT must be executed locally.
For namespace and parameter, you can specify either a string or an expression that resolves to a string designating a namespace or an attribute. If you specify literal arguments for namespace and parameter, and you are using SYS_CONTEXT explicitly in a SQL statement—rather than in a PL/SQL function that in turn is in mentioned in a SQL statement—then Oracle Database evaluates SYS_CONTEXT only once per SQL statement execution for each call site that invokes the SYS_CONTEXT function.
The context namespace must already have been created, and the associated parameter and its value must also have been set using the DBMS_SESSION.set_context procedure. The namespace must be a valid SQL identifier. The parameter name can be any string. It is not case sensitive, but it cannot exceed 30 bytes in length.
The data type of the return value is VARCHAR2. The default maximum size of the return value is 256 bytes. You can override this default by specifying the optional length parameter, which must be a NUMBER or a value that can be implicitly converted to NUMBER. The valid range of values is 1 to 4000 bytes. If you specify an invalid value, then Oracle Database ignores it and uses the default.
Oracle provides the following built-in namespaces:

USERENV - Describes the current session. The predefined parameters of namespace USERENV are listed in Table 7-11.

SYS_SESSION_ROLES - Indicates whether a specified role is currently enabled for the session.</Function>
    <Function Name="SYS_DBURIGEN" Url="http://docs.oracle.com/database/121/SQLRF/functions199.htm">SYS_DBURIGen takes as its argument one or more columns or attributes, and optionally a rowid, and generates a URL of data type DBURIType to a particular column or row object. You can then use the URL to retrieve an XML document from the database.
All columns or attributes referenced must reside in the same table. They must perform the function of a primary key. They need not actually match the primary key of the table, but they must reference a unique value. If you specify multiple columns, then all but the final column identify the row in the database, and the last column specified identifies the column within the row.
By default the URL points to a formatted XML document. If you want the URL to point only to the text of the document, then specify the optional 'text()'.</Function>
    <Function Name="SYS_EXTRACT_UTC" Url="http://docs.oracle.com/database/121/SQLRF/functions200.htm">SYS_EXTRACT_UTC extracts the UTC (Coordinated Universal Time—formerly Greenwich Mean Time) from a datetime value with time zone offset or time zone region name. If a time zone is not specified, then the datetime is associated with the session time zone.</Function>
    <Function Name="SYS_GUID" Url="http://docs.oracle.com/database/121/SQLRF/functions201.htm">SYS_GUID generates and returns a globally unique identifier (RAW value) made up of 16 bytes. On most platforms, the generated identifier consists of a host identifier, a process or thread identifier of the process or thread invoking the function, and a nonrepeating value (sequence of bytes) for that process or thread.</Function>
    <Function Name="SYS_OP_ZONE_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions202.htm">SYS_OP_ZONE_ID takes as its argument a rowid and returns a zone ID. The rowid identifies a row in a table. The zone ID identifies the set of contiguous disk blocks, called the zone, that contains the row. The function returns a NUMBER value.
The SYS_OP_ZONE_ID function is used when creating a zone map with the CREATE MATERIALIZED ZONEMAP statement. You must specify SYS_OP_ZONE_ID in the SELECT and GROUP BY clauses of the defining subquery of the zone map.
For rowid, specify the ROWID pseudocolumn of the fact table of the zone map.
Use schema and table to specify the schema and name of the fact table, or t_alias to specify the table alias for the fact table. The specification of these parameters depends on the FROM clause in the defining subquery of the zone map:

If the FROM clause specifies a table alias for the fact table, then you must also specify the table alias (t_alias) in SYS_OP_ZONE_ID.

If the FROM clause does not specify a table alias for the fact table, then use table to specify the name of the fact table. You can use the schema qualifier if the fact table is in a schema other than your own. If you omit schema, then the database assumes the fact table is in your own schema. If the FROM clause specifies only one table (the fact table) then you need not specify schema or table.

The optional scale parameter represents the scale of the zone map. It is not necessary to specify this parameter because, by default, SYS_OP_ZONE_ID uses the scale of the zone map being created. If you do specify scale, then it must match the scale of the zone map being created. Refer to the SCALE clause of CREATE MATERIALIZED ZONEMAP for information on specifying the scale of a zone map.</Function>
    <Function Name="SYS_TYPEID" Url="http://docs.oracle.com/database/121/SQLRF/functions203.htm">SYS_TYPEID returns the typeid of the most specific type of the operand. This value is used primarily to identify the type-discriminant column underlying a substitutable column. For example, you can use the value returned by SYS_TYPEID to build an index on the type-discriminant column.
You can use this function only on object type operands. All final root object types—final types not belonging to a type hierarchy—have a null typeid. Oracle Database assigns to all types belonging to a type hierarchy a unique non-null typeid.</Function>
    <Function Name="SYS_XMLAGG" Url="http://docs.oracle.com/database/121/SQLRF/functions204.htm">SYS_XMLAgg aggregates all of the XML documents or fragments represented by expr and produces a single XML document. It adds a new enclosing element with a default name ROWSET. If you want to format the XML document differently, then specify fmt, which is an instance of the XMLFormat object.</Function>
    <Function Name="SYS_XMLGEN" Url="http://docs.oracle.com/database/121/SQLRF/functions205.htm">SYS_XMLGen takes an expression that evaluates to a particular row and column of the database, and returns an instance of type XMLType containing an XML document. The expr can be a scalar value, a user-defined type, or an XMLType instance.

If expr is a scalar value, then the function returns an XML element containing the scalar value.

If expr is a type, then the function maps the user-defined type attributes to XML elements.

If expr is an XMLType instance, then the function encloses the document in an XML element whose default tag name is ROW.

By default the elements of the XML document match the elements of expr. For example, if expr resolves to a column name, then the enclosing XML element will be the same column name. If you want to format the XML document differently, then specify fmt, which is an instance of the XMLFormat object.</Function>
    <Function Name="SYSDATE" Url="http://docs.oracle.com/database/121/SQLRF/functions206.htm">SYSDATE returns the current date and time set for the operating system on which the database server resides. The data type of the returned value is DATE, and the format returned depends on the value of the NLS_DATE_FORMAT initialization parameter. The function requires no arguments. In distributed SQL statements, this function returns the date and time set for the operating system of your local database. You cannot use this function in the condition of a CHECK constraint.</Function>
    <Function Name="SYSTIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions207.htm">SYSTIMESTAMP returns the system date, including fractional seconds and time zone, of the system on which the database resides. The return type is TIMESTAMP WITH TIME ZONE.</Function>
    <Function Name="TAN" Url="http://docs.oracle.com/database/121/SQLRF/functions208.htm">TAN returns the tangent of n (an angle expressed in radians).
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="TANH" Url="http://docs.oracle.com/database/121/SQLRF/functions209.htm">TANH returns the hyperbolic tangent of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="TIMESTAMP_TO_SCN" Url="http://docs.oracle.com/database/121/SQLRF/functions210.htm">TIMESTAMP_TO_SCN takes as an argument a timestamp value and returns the approximate system change number (SCN) associated with that timestamp. The returned value is of data type NUMBER. This function is useful any time you want to know the SCN associated with a particular timestamp.</Function>
    <Function Name="TO_BINARY_DOUBLE" Url="http://docs.oracle.com/database/121/SQLRF/functions211.htm">TO_BINARY_DOUBLE returns a double-precision floating-point number.

expr can be a character string or a numeric value of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. If expr is BINARY_DOUBLE, then the function returns expr.

The optional 'fmt' and 'nlsparam' arguments are valid only if expr is a character string. They serve the same purpose as for the TO_CHAR (number) function.

The case-insensitive string 'INF' is converted to positive infinity.

The case-insensitive string '-INF' is converted to negative identity.

The case-insensitive string 'NaN' is converted to NaN (not a number).


You cannot use a floating-point number format element (F, f, D, or d) in a character string expr.
Conversions from character strings or NUMBER to BINARY_DOUBLE can be inexact, because the NUMBER and character types use decimal precision to represent the numeric value, and BINARY_DOUBLE uses binary precision.
Conversions from BINARY_FLOAT to BINARY_DOUBLE are exact.</Function>
    <Function Name="TO_BINARY_FLOAT" Url="http://docs.oracle.com/database/121/SQLRF/functions212.htm">TO_BINARY_FLOAT returns a single-precision floating-point number.

expr can be a character string or a numeric value of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. If expr is BINARY_FLOAT, then the function returns expr.

The optional 'fmt' and 'nlsparam' arguments are valid only if expr is a character string. They serve the same purpose as for the TO_CHAR (number) function.

The incase-sensitive string 'INF' is converted to positive infinity.

The incase-sensitive string '-INF' is converted to negative identity.

The incase-sensitive string 'NaN' is converted to NaN (not a number).


You cannot use a floating-point number format element (F, f, D, or d) in a character string expr.
Conversions from character strings or NUMBER to BINARY_FLOAT can be inexact, because the NUMBER and character types use decimal precision to represent the numeric value and BINARY_FLOAT uses binary precision.
Conversions from BINARY_DOUBLE to BINARY_FLOAT are inexact if the BINARY_DOUBLE value uses more bits of precision than supported by the BINARY_FLOAT.</Function>
    <Function Name="TO_BLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions213.htm">TO_BLOB converts LONG RAW and RAW values to BLOB values.
From within a PL/SQL package, you can use TO_BLOB to convert RAW and BLOB values to BLOB.</Function>
    <Function Name="TO_CHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions214.htm">TO_CHAR (character) converts NCHAR, NVARCHAR2, CLOB, or NCLOB data to the database character set. The value returned is always VARCHAR2.
When you use this function to convert a character LOB into the database character set, if the LOB value to be converted is larger than the target type, then the database returns an error.
You can use this function in conjunction with any of the XML functions to generate a date in the database format rather than the XML Schema standard format.</Function>
    <Function Name="TO_CHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions215.htm">TO_CHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL DAY TO SECOND, or INTERVAL YEAR TO MONTH data type to a value of VARCHAR2 data type in the format specified by the date format fmt. If you omit fmt, then date is converted to a VARCHAR2 value as follows:

DATE values are converted to values in the default date format.

TIMESTAMP and TIMESTAMP WITH LOCAL TIME ZONE values are converted to values in the default timestamp format.

TIMESTAMP WITH TIME ZONE values are converted to values in the default timestamp with time zone format.

Interval values are converted to the numeric representation of the interval literal.

Refer to "Format Models" for information on datetime formats.
The 'nlsparam' argument specifies the language in which month and day names and abbreviations are returned. This argument can have this form:

'NLS_DATE_LANGUAGE = language' 

If you omit 'nlsparam', then this function uses the default date language for your session.</Function>
    <Function Name="TO_CHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions216.htm">TO_CHAR (number) converts n to a value of VARCHAR2 data type, using the optional number format fmt. The value n can be of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. If you omit fmt, then n is converted to a VARCHAR2 value exactly long enough to hold its significant digits.
If n is negative, then the sign is applied after the format is applied. Thus TO_CHAR(-1, '$9') returns -$1, rather than $-1.
Refer to "Format Models" for information on number formats.
The 'nlsparam' argument specifies these characters that are returned by number format elements:

Decimal character

Group separator

Local currency symbol

International currency symbol

This argument can have this form:

'NLS_NUMERIC_CHARACTERS = ''dg''
   NLS_CURRENCY = ''text''
   NLS_ISO_CURRENCY = territory '

The characters d and g represent the decimal character and group separator, respectively. They must be different single-byte characters. Within the quoted string, you must use two single quotation marks around the parameter values. Ten characters are available for the currency symbol.
If you omit 'nlsparam' or any one of the parameters, then this function uses the default parameter values for your session.</Function>
    <Function Name="TO_CLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions217.htm">TO_CLOB converts NCLOB values in a LOB column or other character strings to CLOB values. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. Oracle Database executes this function by converting the underlying LOB data from the national character set to the database character set.
From within a PL/SQL package, you can use the TO_CLOB function to convert RAW, CHAR, VARCHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB values to CLOB or NCLOB values.</Function>
    <Function Name="TO_DATE" Url="http://docs.oracle.com/database/121/SQLRF/functions218.htm">TO_DATE converts char of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to a value of DATE data type.</Function>
    <Function Name="TO_DSINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions219.htm">TO_DSINTERVAL converts a character string of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to an INTERVAL DAY TO SECOND type.
TO_DSINTERVAL accepts argument in one of the two formats:

SQL interval format compatible with the SQL standard (ISO/IEC 9075:2003)

ISO duration format compatible with the ISO 8601:2004 standard

In the SQL format, days is an integer between 0 and 999999999, hours is an integer between 0 and 23, and minutes and seconds are integers between 0 and 59. frac_secs is the fractional part of seconds between .0 and .999999999. One or more blanks separate days from hours. Additional blanks are allowed between format elements.
In the ISO format, days, hours, minutes and seconds are integers between 0 and 999999999. frac_secs is the fractional part of seconds between .0 and .999999999. No blanks are allowed in the value. If you specify T, then you must specify at least one of the hours, minutes, or seconds values.</Function>
    <Function Name="TO_LOB" Url="http://docs.oracle.com/database/121/SQLRF/functions220.htm">TO_LOB converts LONG or LONG RAW values in the column long_column to LOB values. You can apply this function only to a LONG or LONG RAW column, and only in the select list of a subquery in an INSERT statement.
Before using this function, you must create a LOB column to receive the converted LONG values. To convert LONG values, create a CLOB column. To convert LONG RAW values, create a BLOB column.
You cannot use the TO_LOB function to convert a LONG column to a LOB column in the subquery of a CREATE TABLE ... AS SELECT statement if you are creating an index-organized table. Instead, create the index-organized table without the LONG column, and then use the TO_LOB function in an INSERT ... AS SELECT statement.
You cannot use this function within a PL/SQL package. Instead use the TO_CLOB or TO_BLOB functions.</Function>
    <Function Name="TO_MULTI_BYTE" Url="http://docs.oracle.com/database/121/SQLRF/functions221.htm">TO_MULTI_BYTE returns char with all of its single-byte characters converted to their corresponding multibyte characters. char can be of data type CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The value returned is in the same data type as char.
Any single-byte characters in char that have no multibyte equivalents appear in the output string as single-byte characters. This function is useful only if your database character set contains both single-byte and multibyte characters.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TO_NCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions222.htm">TO_NCHAR (character) converts a character string, CHAR, VARCHAR2, CLOB, or NCLOB value to the national character set. The value returned is always NVARCHAR2. This function is equivalent to the TRANSLATE ... USING function with a USING clause in the national character set.</Function>
    <Function Name="TO_NCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions223.htm">TO_NCHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL MONTH TO YEAR, or INTERVAL DAY TO SECOND data type from the database character set to the national character set.</Function>
    <Function Name="TO_NCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions224.htm">TO_NCHAR (number) converts n to a string in the national character set. The value n can be of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. The function returns a value of the same type as the argument. The optional fmt and 'nlsparam' corresponding to n can be of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL MONTH TO YEAR, or INTERVAL DAY TO SECOND data type.</Function>
    <Function Name="TO_NCLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions225.htm">TO_NCLOB converts CLOB values in a LOB column or other character strings to NCLOB values. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. Oracle Database implements this function by converting the character set of char from the database character set to the national character set.</Function>
    <Function Name="TO_NUMBER" Url="http://docs.oracle.com/database/121/SQLRF/functions226.htm">TO_NUMBER converts expr to a value of NUMBER data type. The expr can be a BINARY_DOUBLE value or a value of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type containing a number in the format specified by the optional format model fmt.
You can specify an expr of BINARY_FLOAT. However, it makes no sense to do so because a float can be interpreted only by its internal presentation.
Refer to "Format Models" for information on number formats.
The 'nlsparam' argument in this function has the same purpose as it does in the TO_CHAR function for number conversions. Refer to TO_CHAR (number) for more information.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TO_SINGLE_BYTE" Url="http://docs.oracle.com/database/121/SQLRF/functions227.htm">TO_SINGLE_BYTE returns char with all of its multibyte characters converted to their corresponding single-byte characters. char can be of data type CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The value returned is in the same data type as char.
Any multibyte characters in char that have no single-byte equivalents appear in the output as multibyte characters. This function is useful only if your database character set contains both single-byte and multibyte characters.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TO_YMINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions230.htm">TO_YMINTERVAL converts a character string of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to an INTERVAL YEAR TO MONTH type.
TO_YMINTERVAL accepts argument in one of the two formats:

SQL interval format compatible with the SQL standard (ISO/IEC 9075:2003)

ISO duration format compatible with the ISO 8601:2004 standard

In the SQL format, years is an integer between 0 and 999999999, and months is an integer between 0 and 11. Additional blanks are allowed between format elements.
In the ISO format, years and months are integers between 0 and 999999999. Days, hours, minutes, seconds, and frac_secs are non-negative integers, and are ignored, if specified. No blanks are allowed in the value. If you specify T, then you must specify at least one of the hours, minutes, or seconds values.</Function>
    <Function Name="TRANSLATE" Url="http://docs.oracle.com/database/121/SQLRF/functions231.htm">TRANSLATE returns expr with all occurrences of each character in from_string replaced by its corresponding character in to_string. Characters in expr that are not in from_string are not replaced. The argument from_string can contain more characters than to_string. In this case, the extra characters at the end of from_string have no corresponding characters in to_string. If these extra characters appear in expr, then they are removed from the return value.
If a character appears multiple times in from_string, then the to_string mapping corresponding to the first occurrence is used.
You cannot use an empty string for to_string to remove all characters in from_string from the return value. Oracle Database interprets the empty string as null, and if this function has a null argument, then it returns null. To remove all characters in from_string, concatenate another character to the beginning of from_string and specify this character as the to_string. For example, TRANSLATE(expr, 'x0123456789', 'x') removes all digits from expr.
TRANSLATE provides functionality related to that provided by the REPLACE function. REPLACE lets you substitute a single string for another single string, as well as remove character strings. TRANSLATE lets you make several single-character, one-to-one substitutions in one operation.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TRANSLATE" Url="http://docs.oracle.com/database/121/SQLRF/functions232.htm">TRANSLATE ... USING converts char into the character set specified for conversions between the database character set and the national character set.</Function>
    <Function Name="TREAT" Url="http://docs.oracle.com/database/121/SQLRF/functions233.htm">TREAT changes the declared type of an expression.
You must have the EXECUTE object privilege on type to use this function.

type must be some supertype or subtype of the declared type of expr. If the most specific type of expr is type (or some subtype of type), then TREAT returns expr. If the most specific type of expr is not type (or some subtype of type), then TREAT returns NULL.

You can specify REF only if the declared type of expr is a REF type.

If the declared type of expr is a REF to a source type of expr, then type must be some subtype or supertype of the source type of expr. If the most specific type of DEREF(expr) is type (or a subtype of type), then TREAT returns expr. If the most specific type of DEREF(expr) is not type (or a subtype of type), then TREAT returns NULL.

This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TRIM" Url="http://docs.oracle.com/database/121/SQLRF/functions234.htm">TRIM enables you to trim leading or trailing characters (or both) from a character string. If trim_character or trim_source is a character literal, then you must enclose it in single quotation marks.

If you specify LEADING, then Oracle Database removes any leading characters equal to trim_character.

If you specify TRAILING, then Oracle removes any trailing characters equal to trim_character.

If you specify BOTH or none of the three, then Oracle removes leading and trailing characters equal to trim_character.

If you do not specify trim_character, then the default value is a blank space.

If you specify only trim_source, then Oracle removes leading and trailing blank spaces.

The function returns a value with data type VARCHAR2. The maximum length of the value is the length of trim_source.

If either trim_source or trim_character is null, then the TRIM function returns null.

Both trim_character and trim_source can be VARCHAR2 or any data type that can be implicitly converted to VARCHAR2. The string returned is a VARCHAR2 (NVARCHAR2) data type if trim_source is a CHAR or VARCHAR2 (NCHAR or NVARCHAR2) data type, and a CLOB if trim_source is a CLOB data type. The return string is in the same character set as trim_source.</Function>
    <Function Name="TRUNC" Url="http://docs.oracle.com/database/121/SQLRF/functions235.htm">The TRUNC (date) function returns date with the time portion of the day truncated to the unit specified by the format model fmt. This function is not sensitive to the NLS_CALENDAR session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type DATE, even if you specify a different datetime data type for date. If you omit fmt, then the default format model 'DD' is used and the value returned is date truncated to the day with a time of midnight. Refer to "ROUND and TRUNC Date Functions" for the permitted format models to use in fmt.</Function>
    <Function Name="TRUNC" Url="http://docs.oracle.com/database/121/SQLRF/functions236.htm">The TRUNC (number) function returns n1 truncated to n2 decimal places. If n2 is omitted, then n1 is truncated to 0 places. n2 can be negative to truncate (make zero) n2 digits left of the decimal point.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit n2, then the function returns the same data type as the numeric data type of the argument. If you include n2, then the function returns NUMBER.</Function>
    <Function Name="TZ_OFFSET" Url="http://docs.oracle.com/database/121/SQLRF/functions237.htm">TZ_OFFSET returns the time zone offset corresponding to the argument based on the date the statement is executed. You can enter a valid time zone region name, a time zone offset from UTC (which simply returns itself), or the keyword SESSIONTIMEZONE or DBTIMEZONE. For a listing of valid values for time_zone_name, query the TZNAME column of the V$TIMEZONE_NAMES dynamic performance view.</Function>
    <Function Name="UID" Url="http://docs.oracle.com/database/121/SQLRF/functions238.htm">UID returns an integer that uniquely identifies the session user (the user who logged on).</Function>
    <Function Name="UNISTR" Url="http://docs.oracle.com/database/121/SQLRF/functions239.htm">UNISTR takes as its argument a text literal or an expression that resolves to character data and returns it in the national character set. The national character set of the database can be either AL16UTF16 or UTF8. UNISTR provides support for Unicode string literals by letting you specify the Unicode encoding value of characters in the string. This is useful, for example, for inserting data into NCHAR columns.
The Unicode encoding value has the form '\xxxx' where 'xxxx' is the hexadecimal value of a character in UCS-2 encoding format. Supplementary characters are encoded as two code units, the first from the high-surrogates range (U+D800 to U+DBFF), and the second from the low-surrogates range (U+DC00 to U+DFFF). To include the backslash in the string itself, precede it with another backslash (\\).
For portability and data preservation, Oracle recommends that in the UNISTR string argument you specify only ASCII characters and the Unicode encoding values.</Function>
    <Function Name="UPDATEXML" Url="http://docs.oracle.com/database/121/SQLRF/functions240.htm">UPDATEXML takes as arguments an XMLType instance and an XPath-value pair and returns an XMLType instance with the updated value. If XPath_string is an XML element, then the corresponding value_expr must be an XMLType instance. If XPath_string is an attribute or text node, then the value_expr can be any scalar data type. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node.
The data types of the target of each XPath_string and its corresponding value_expr must match. The optional namespace_string must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).
If you update an XML element to null, then Oracle removes the attributes and children of the element, and the element becomes empty. If you update the text node of an element to null, Oracle removes the text value of the element, and the element itself remains but is empty.
In most cases, this function materializes an XML document in memory and updates the value. However, UPDATEXML is optimized for UPDATE statements on object-relational columns so that the function updates the value directly in the column. This optimization requires the following conditions:

The XMLType_instance must be the same as the column in the UPDATE ... SET clause.

The XPath_string must resolve to scalar content.</Function>
    <Function Name="UPPER" Url="http://docs.oracle.com/database/121/SQLRF/functions241.htm">UPPER returns char, with all letters uppercase. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The return value is the same data type as char. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase, refer to NLS_UPPER.</Function>
    <Function Name="USER" Url="http://docs.oracle.com/database/121/SQLRF/functions242.htm">USER returns the name of the session user (the user who logged on). This may change during the duration of a database session as Real Application Security sessions are attached or detached. For enterprise users, this function returns the schema. For other users, it returns the database user name. If a Real Application Security session is currently attached to the database session, then it returns user XS$NULL.
This function returns a VARCHAR2 value.
Oracle Database compares values of this function with blank-padded comparison semantics.
In a distributed SQL statement, the UID and USER functions together identify the user on your local database. You cannot use these functions in the condition of a CHECK constraint.</Function>
    <Function Name="VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions244.htm">VALUE takes as its argument a correlation variable (table alias) associated with a row of an object table and returns object instances stored in the object table. The type of the object instances is the same type as the object table.</Function>
    <Function Name="VAR_POP" Url="http://docs.oracle.com/database/121/SQLRF/functions245.htm">VAR_POP returns the population variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="VAR_SAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions246.htm">VAR_SAMP returns the sample variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="VARIANCE" Url="http://docs.oracle.com/database/121/SQLRF/functions247.htm">VARIANCE returns the variance of expr. You can use it as an aggregate or analytic function.
Oracle Database calculates the variance of expr as follows:

0 if the number of rows in expr = 1

VAR_SAMP if the number of rows in expr &gt; 1

If you specify DISTINCT, then you can specify only the query_partition_clause of the analytic_clause. The order_by_clause and windowing_clause are not allowed.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="WIDTH_BUCKET" Url="http://docs.oracle.com/database/121/SQLRF/functions249.htm">WIDTH_BUCKET lets you construct equiwidth histograms, in which the histogram range is divided into intervals that have identical size. (Compare this function with NTILE, which creates equiheight histograms.) Ideally each bucket is a closed-open interval of the real number line. For example, a bucket can be assigned to scores between 10.00 and 19.999 ... to indicate that 10 is included in the interval and 20 is excluded. This is sometimes denoted [10, 20).
For a given expression, WIDTH_BUCKET returns the bucket number into which the value of this expression would fall after being evaluated.

expr is the expression for which the histogram is being created. This expression must evaluate to a numeric or datetime value or to a value that can be implicitly converted to a numeric or datetime value. If expr evaluates to null, then the expression returns null.

min_value and max_value are expressions that resolve to the end points of the acceptable range for expr. Both of these expressions must also evaluate to numeric or datetime values, and neither can evaluate to null.

num_buckets is an expression that resolves to a constant indicating the number of buckets. This expression must evaluate to a positive integer.


See Also:
Table 2-10, "Implicit Type Conversion Matrix" for more information on implicit conversion


When needed, Oracle Database creates an underflow bucket numbered 0 and an overflow bucket numbered num_buckets+1. These buckets handle values less than min_value and more than max_value and are helpful in checking the reasonableness of endpoints.</Function>
    <Function Name="VSIZE" Url="http://docs.oracle.com/database/121/SQLRF/functions248.htm">VSIZE returns the number of bytes in the internal representation of expr. If expr is null, then this function returns null.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="XMLAGG" Url="http://docs.oracle.com/database/121/SQLRF/functions250.htm">XMLAgg is an aggregate function. It takes a collection of XML fragments and returns an aggregated XML document. Any arguments that return null are dropped from the result.
XMLAgg is similar to SYS_XMLAgg except that XMLAgg returns a collection of nodes but it does not accept formatting using the XMLFormat object. Also, XMLAgg does not enclose the output in an element tag as does SYS_XMLAgg.
Within the order_by_clause, Oracle Database does not interpret number literals as column positions, as it does in other uses of this clause, but simply as number literals.</Function>
    <Function Name="XMLCAST" Url="http://docs.oracle.com/database/121/SQLRF/functions251.htm">XMLCast casts value_expression to the scalar SQL data type specified by datatype. The value_expression argument is a SQL expression that is evaluated. The datatype argument can be of data type NUMBER, VARCHAR2, CHAR, CLOB, BLOB, REF XMLTYPE, and any of the datetime data types.</Function>
    <Function Name="XMLCDATA" Url="http://docs.oracle.com/database/121/SQLRF/functions252.htm">XMLCData generates a CDATA section by evaluating value_expr. The value_expr must resolve to a string. The value returned by the function takes the following form:

&lt;![CDATA[string]]&gt;

If the resulting value is not a valid XML CDATA section, then the function returns an error.The following conditions apply to XMLCData:

The value_expr cannot contain the substring ]]&gt;.

If value_expr evaluates to null, then the function returns null.</Function>
    <Function Name="XMLCOLATTVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions253.htm">XMLColAttVal creates an XML fragment and then expands the resulting XML so that each XML fragment has the name column with the attribute name.
You can use the AS clause to change the value of the name attribute to something other than the column name. You can do this by specifying c_alias, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the alias. The alias can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED. See "Extended Data Types" for more information.
You must specify a value for value_expr. If value_expr is null, then no element is returned.

Restriction on XMLColAttVal You cannot specify an object type column for value_expr.</Function>
    <Function Name="XMLCOMMENT" Url="http://docs.oracle.com/database/121/SQLRF/functions254.htm">XMLComment generates an XML comment using an evaluated result of value_expr. The value_expr must resolve to a string. It cannot contain two consecutive dashes (hyphens). The value returned by the function takes the following form:

&lt;!--string--&gt;

If value_expr resolves to null, then the function returns null.</Function>
    <Function Name="XMLCONCAT" Url="http://docs.oracle.com/database/121/SQLRF/functions255.htm">XMLConcat takes as input a series of XMLType instances, concatenates the series of elements for each row, and returns the concatenated series. XMLConcat is the inverse of XMLSequence.
Null expressions are dropped from the result. If all the value expressions are null, then the function returns null.</Function>
    <Function Name="XMLDIFF" Url="http://docs.oracle.com/database/121/SQLRF/functions256.htm">The XMLDiff function is the SQL interface for the XmlDiff C API. This function compares two XML documents and captures the differences in XML conforming to an Xdiff schema. The diff document is returned as an XMLType document.

For the first two arguments, specify the names of two XMLType documents.

For the integer, specify a number representing the hashLevel for a C function XmlDiff. If you do not want hashing, set this argument to 0 or omit it entirely. If you do not want hashing, but you want to specify flags, then you must set this argument to 0.

For string, specify the flags that control the behavior of the function. These flags are specified by one or more names separated by semicolon. The names are the same as the names of constants for XmlDiff function.</Function>
    <Function Name="XMLELEMENT" Url="http://docs.oracle.com/database/121/SQLRF/functions257.htm">XMLElement takes an element name for identifier or evaluates an element name for EVALNAME value_expr, an optional collection of attributes for the element, and arguments that make up the content of the element. It returns an instance of type XMLType. XMLElement is similar to SYS_XMLGen except that XMLElement can include attributes in the XML returned, but it does not accept formatting using the XMLFormat object.
The XMLElement function is typically nested to produce an XML document with a nested structure, as in the example in the following section.
For an explanation of the ENTITYESCAPING and NONENTITYESCAPING keywords, refer to Oracle XML DB Developer's Guide.
You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying identifier, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier does not have to be a column name or column reference. It cannot be an expression or null. It can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED.
The objects that make up the element content follow the XMLATTRIBUTES keyword. In the XML_attributes_clause, if the value_expr is null, then no attribute is created for that value expression. The type of value_expr cannot be an object type or collection. If you specify an alias for value_expr using the AS clause, then the c_alias or the evaluated value expression (EVALNAME value_expr) can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED.</Function>
    <Function Name="XMLEXISTS" Url="http://docs.oracle.com/database/121/SQLRF/functions258.htm">XMLExists checks whether a given XQuery expression returns a nonempty XQuery sequence. If so, the function returns TRUE; otherwise, it returns FALSE. The argument XQuery_string is a literal string, but it can contain XQuery variables that you bind using the XML_passing_clause.
The expr in the XML_passing_clause is an expression returning an XMLType or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one expr in the PASSING clause without an identifier. The result of evaluating each expr is bound to the corresponding identifier in the XQuery_string. If any expr that is not followed by an AS clause, then the result of evaluating that expression is used as the context item for evaluating the XQuery_string.</Function>
    <Function Name="XMLFOREST" Url="http://docs.oracle.com/database/121/SQLRF/functions259.htm">XMLForest converts each of its argument parameters to XML, and then returns an XML fragment that is the concatenation of these converted arguments.

If value_expr is a scalar expression, then you can omit the AS clause, and Oracle Database uses the column name as the element name.

If value_expr is an object type or collection, then the AS clause is mandatory, and Oracle uses the specified expression as the enclosing tag.
You can do this by specifying c_alias, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier does not have to be a column name or column reference. It cannot be an expression or null. It can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED. See "Extended Data Types" for more information.

If value_expr is null, then no element is created for that value_expr.</Function>
    <Function Name="XMLISVALID" Url="http://docs.oracle.com/database/121/SQLRF/functions260.htm">XMLISVALID checks whether the input XMLType_instance conforms to the relevant XML schema. It does not change the validation status recorded for XMLType_instance.
If the input XML document is determined to be valid, then XMLISVALID returns 1; otherwise, it returns 0. If you provide XMLSchema_URL as an argument, then that is used to check conformance. Otherwise, the XML schema specified by the XML document is used to check conformance.

XMLType_instance is the XMLType instance to be validated.

XMLSchema_URL is the URL of the XML schema against which to check conformance.

element is the element of the specified schema against which to check conformance. Use this if you have an XML schema that defines more than one top level element, and you want to check conformance against a specific one of those elements.</Function>
    <Function Name="XMLPARSE" Url="http://docs.oracle.com/database/121/SQLRF/functions261.htm">XMLParse parses and generates an XML instance from the evaluated result of value_expr. The value_expr must resolve to a string. If value_expr resolves to null, then the function returns null.

If you specify DOCUMENT, then value_expr must resolve to a singly rooted XML document.

If you specify CONTENT, then value_expr must resolve to a valid XML value.

When you specify WELLFORMED, you are guaranteeing that value_expr resolves to a well-formed XML document, so the database does not perform validity checks to ensure that the input is well formed.</Function>
    <Function Name="XMLPATCH" Url="http://docs.oracle.com/database/121/SQLRF/functions262.htm">The XMLPatch function is the SQL interface for the XmlPatch C API. This function patches an XML document with the changes specified. A patched XMLType document is returned.

For the first argument, specify the name of the input XMLType document.

For the second argument, specify the XMLType document containing the changes to be applied to the first document. The changes should conform to the Xdiff XML schema. You can supply the XML output from the Oracle XML Developer's Kit Java method diff().</Function>
    <Function Name="XMLPI" Url="http://docs.oracle.com/database/121/SQLRF/functions263.htm">XMLPI generates an XML processing instruction using identifier and optionally the evaluated result of value_expr. A processing instruction is commonly used to provide to an application information that is associated with all or part of an XML document. The application uses the processing instruction to determine how best to process the XML document.
You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying identifier, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier does not have to be a column name or column reference. It cannot be an expression or null. It can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED. See "Extended Data Types" for more information.
The optional value_expr must resolve to a string. If you omit the optional value_expr, then a zero-length string is the default. The value returned by the function takes this form:

&lt;?identifier string?&gt;

XMLPI is subject to the following restrictions:

The identifier must be a valid target for a processing instruction.

You cannot specify xml in any case combination for identifier.

The identifier cannot contain the consecutive characters ?&gt;.</Function>
    <Function Name="XMLQUERY" Url="http://docs.oracle.com/database/121/SQLRF/functions264.htm">XMLQUERY lets you query XML data in SQL statements. It takes an XQuery expression as a string literal, an optional context item, and other bind variables and returns the result of evaluating the XQuery expression using these input values.

XQuery_string is a complete XQuery expression, including prolog.

The expr in the XML_passing_clause is an expression returning an XMLType or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one expr in the PASSING clause without an identifier. The result of evaluating each expr is bound to the corresponding identifier in the XQuery_string. If any expr that is not followed by an AS clause, then the result of evaluating that expression is used as the context item for evaluating the XQuery_string.

RETURNING CONTENT indicates that the result from the XQuery evaluation is either an XML 1.0 document or a document fragment conforming to the XML 1.0 semantics.

If the result set is empty, then the function returns the SQL NULL value. The NULL ON EMPTY keywords are implemented by default and are shown for semantic clarity.</Function>
    <Function Name="XMLROOT" Url="http://docs.oracle.com/database/121/SQLRF/functions265.htm">XMLROOT lets you create a new XML value by providing version and standalone properties in the XML root information (prolog) of an existing XML value. If the value_expr already has a prolog, then the database returns an error. If the input is null, then the function returns null.
The value returned takes the following form:

&lt;?xml version = "version" [ STANDALONE = "{yes | no}" ]?&gt;


The first value_expr specifies the XML value for which you are providing prolog information.

In the VERSION clause, value_expr must resolve to a string representing a valid XML version. If you specify NO VALUE for VERSION, then the version defaults to 1.0.

If you omit the optional STANDALONE clause, or if you specify it with NO VALUE, then the standalone property is absent from the value returned by the function.</Function>
    <Function Name="XMLSEQUENCE" Url="http://docs.oracle.com/database/121/SQLRF/functions266.htm">XMLSequence has two forms:

The first form takes as input an XMLType instance and returns a varray of the top-level nodes in the XMLType. This form is effectively superseded by the SQL/XML standard function XMLTable, which provides for more readable SQL code. Prior to Oracle Database 10g Release 2, XMLSequence was used with SQL function TABLE to do some of what can now be done better with the XMLTable function.

The second form takes as input a REFCURSOR instance, with an optional instance of the XMLFormat object, and returns as an XMLSequence type an XML document for each row of the cursor.

Because XMLSequence returns a collection of XMLType, you can use this function in a TABLE clause to unnest the collection values into multiple rows, which can in turn be further processed in the SQL query.</Function>
    <Function Name="XMLSERIALIZE" Url="http://docs.oracle.com/database/121/SQLRF/functions267.htm">XMLSerialize creates a string or LOB containing the contents of value_expr.

If you specify DOCUMENT, then the value_expr must be a valid XML document.

If you specify CONTENT, then the value_expr need not be a singly rooted XML document. However it must be valid XML content.

The datatype specified can be a string type (VARCHAR2 or VARCHAR, but not NVARCHAR2), BLOB, or CLOB. The default is CLOB.

If datatype is BLOB, then you can specify the ENCODING clause to use the specified encoding in the prolog. The xml_encoding_spec is an XML encoding declaration (encoding="...").

Specify the VERSION clause to use the version you provide as string_literal in the XML declaration (&lt;?xml version="..." ...?&gt;).

Specify NO INDENT to strip all insignificant whitespace from the output. Specify INDENT SIZE = N, where N is a whole number, for output that is pretty-printed using a relative indentation of N spaces. If N is 0, then pretty-printing inserts a newline character after each element, placing each element on a line by itself, but omitting all other insignificant whitespace in the output. If INDENT is present without a SIZE specification, then 2-space indenting is used. If you omit this clause, then the behavior (pretty-printing or not) is indeterminate.

HIDE DEFAULTS and SHOW DEFAULTS apply only to XML schema-based data. If you specify SHOW DEFAULTS and the input data is missing any optional elements or attributes for which the XML schema defines default values, then those elements or attributes are included in the output with their default values. If you specify HIDE DEFAULTS, then no such elements or attributes are included in the output. HIDE DEFAULTS is the default behavior.</Function>
    <Function Name="XMLTABLE" Url="http://docs.oracle.com/database/121/SQLRF/functions268.htm">XMLTable maps the result of an XQuery evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL.

The XMLNAMESPACES clause contains a set of XML namespace declarations. These declarations are referenced by the XQuery expression (the evaluated XQuery_string), which computes the row, and by the XPath expression in the PATH clause of XML_table_column, which computes the columns for the entire XMLTable function. If you want to use qualified names in the PATH expressions of the COLUMNS clause, then you need to specify the XMLNAMESPACES clause.

XQuery_string is a literal string. It is a complete XQuery expression and can include prolog declarations. The value of XQuery_string serves as input to the XMLTable function; it is this XQuery result that is decomposed and stored as relational data.

The expr in the XML_passing_clause is an expression returning an XMLType or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one expr in the PASSING clause without an identifier. The result of evaluating each expr is bound to the corresponding identifier in the XQuery_string. If any expr that is not followed by an AS clause, then the result of evaluating that expression is used as the context item for evaluating the XQuery_string. This clause supports only passing by value, not passing by reference. Therefore, the BY VALUE keywords are optional and are provided for semantic clarity.

The optional RETURNING SEQUENCE BY REF clause causes the result of the XQuery evaluation to be returned by reference. This allows you to refer to any part of the source data in the XML_table_column clause.
If you omit this clause, then the result of the XQuery evaluation is returned by value. That is, a copy of the targeted nodes is returned instead of a reference to the actual nodes. In this case, you cannot refer to any data that is not in the returned copy in the XML_table_column clause. In particular, you cannot refer to data that precedes the targeted nodes in the source data.

The optional COLUMNS clause defines the columns of the virtual table to be created by XMLTable.

If you omit the COLUMNS clause, then XMLTable returns a row with a single XMLType pseudocolumn named COLUMN_VALUE.

FOR ORDINALITY specifies that column is to be a column of generated row numbers. There must be at most one FOR ORDINALITY clause. It is created as a NUMBER column.

For each resulting column except the FOR ORDINALITY column, you must specify the column data type, which can be XMLType or any other data type.
If the column data type is XMLType, then specify the XMLTYPE clause. If you specify the optional (SEQUENCE) BY REF clause, then a reference to the source data targeted by the PATH expression is returned as the column content. Otherwise, column contains a copy of that targeted data.
Returning the XMLType data by reference lets you specify other columns whose paths target nodes in the source data that are outside those targeted by the PATH expression for column.
If the column data type is any other data type, then specify datatype.

The optional PATH clause specifies that the portion of the XQuery result that is addressed by XQuery expression string is to be used as the column content.
If you omit PATH, then the XQuery expression column is assumed. For example:

XMLTable(... COLUMNS xyz)

is equivalent to

XMLTable(... COLUMNS xyz PATH 'XYZ')

You can use different PATH clauses to split the XQuery result into different virtual-table columns.

The optional DEFAULT clause specifies the value to use when the PATH expression results in an empty sequence. Its expr is an XQuery expression that is evaluated to produce the default value.</Function>
    <Function Name="XMLTRANSFORM" Url="http://docs.oracle.com/database/121/SQLRF/functions269.htm">XMLTransform takes as arguments an XMLType instance and an XSL style sheet, which is itself a form of XMLType instance. It applies the style sheet to the instance and returns an XMLType.
This function is useful for organizing data according to a style sheet as you are retrieving it from the database.</Function>
  </Functions>
  <Statements>
    <Statement Name="ADMINISTER KEY MANAGEMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_1003.htm" />
    <Statement Name="ALTER AUDIT POLICY" Url="http://docs.oracle.com/database/121/SQLRF/statements_1004.htm" />
    <Statement Name="ALTER CLUSTER" Url="http://docs.oracle.com/database/121/SQLRF/statements_1005.htm" />
    <Statement Name="ALTER DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_1006.htm" />
    <Statement Name="ALTER DATABASE LINK" Url="http://docs.oracle.com/database/121/SQLRF/statements_1007.htm" />
    <Statement Name="ALTER DIMENSION" Url="http://docs.oracle.com/database/121/SQLRF/statements_1008.htm" />
    <Statement Name="ALTER DISKGROUP" Url="http://docs.oracle.com/database/121/SQLRF/statements_1009.htm" />
    <Statement Name="ALTER FLASHBACK ARCHIVE" Url="http://docs.oracle.com/database/121/SQLRF/statements_1010.htm" />
    <Statement Name="ALTER FUNCTION" Url="http://docs.oracle.com/database/121/SQLRF/statements_1011.htm" />
    <Statement Name="ALTER INDEX" Url="http://docs.oracle.com/database/121/SQLRF/statements_1012.htm" />
    <Statement Name="ALTER INDEXTYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_1013.htm" />
    <Statement Name="ALTER JAVA" Url="http://docs.oracle.com/database/121/SQLRF/statements_1014.htm" />
    <Statement Name="ALTER LIBRARY" Url="http://docs.oracle.com/database/121/SQLRF/statements_2001.htm" />
    <Statement Name="ALTER MATERIALIZED VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_2002.htm" />
    <Statement Name="ALTER MATERIALIZED VIEW LOG" Url="http://docs.oracle.com/database/121/SQLRF/statements_2003.htm" />
    <Statement Name="ALTER MATERIALIZED ZONEMAP" Url="http://docs.oracle.com/database/121/SQLRF/statements_2004.htm" />
    <Statement Name="ALTER OPERATOR" Url="http://docs.oracle.com/database/121/SQLRF/statements_2005.htm" />
    <Statement Name="ALTER OUTLINE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2006.htm" />
    <Statement Name="ALTER PACKAGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2007.htm" />
    <Statement Name="ALTER PLUGGABLE DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2008.htm" />
    <Statement Name="ALTER PROCEDURE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2009.htm" />
    <Statement Name="ALTER PROFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2010.htm" />
    <Statement Name="ALTER RESOURCE COST" Url="http://docs.oracle.com/database/121/SQLRF/statements_2011.htm" />
    <Statement Name="ALTER ROLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2012.htm" />
    <Statement Name="ALTER ROLLBACK SEGMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_2013.htm" />
    <Statement Name="ALTER SEQUENCE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2014.htm" />
    <Statement Name="ALTER SESSION" Url="http://docs.oracle.com/database/121/SQLRF/statements_2015.htm" />
    <Statement Name="ALTER SYNONYM" Url="http://docs.oracle.com/database/121/SQLRF/statements_2016.htm" />
    <Statement Name="ALTER SYSTEM" Url="http://docs.oracle.com/database/121/SQLRF/statements_2017.htm" />
    <Statement Name="ALTER TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_3001.htm" />
    <Statement Name="ALTER TABLESPACE" Url="http://docs.oracle.com/database/121/SQLRF/statements_3002.htm" />
    <Statement Name="ALTER TRIGGER" Url="http://docs.oracle.com/database/121/SQLRF/statements_4001.htm" />
    <Statement Name="ALTER TYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_4002.htm" />
    <Statement Name="ALTER USER" Url="http://docs.oracle.com/database/121/SQLRF/statements_4003.htm" />
    <Statement Name="ALTER VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_4004.htm" />
    <Statement Name="ANALYZE" Url="http://docs.oracle.com/database/121/SQLRF/statements_4005.htm" />
    <Statement Name="ASSOCIATE STATISTICS" Url="http://docs.oracle.com/database/121/SQLRF/statements_4006.htm" />
    <Statement Name="AUDIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_4007.htm" />
    <Statement Name="AUDIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_4008.htm" />
    <Statement Name="CALL" Url="http://docs.oracle.com/database/121/SQLRF/statements_4009.htm" />
    <Statement Name="COMMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_4010.htm" />
    <Statement Name="COMMIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_4011.htm" />
    <Statement Name="CREATE AUDIT POLICY" Url="http://docs.oracle.com/database/121/SQLRF/statements_5001.htm" />
    <Statement Name="CREATE CLUSTER" Url="http://docs.oracle.com/database/121/SQLRF/statements_5002.htm" />
    <Statement Name="CREATE CONTEXT" Url="http://docs.oracle.com/database/121/SQLRF/statements_5003.htm" />
    <Statement Name="CREATE CONTROLFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_5004.htm" />
    <Statement Name="CREATE DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_5005.htm" />
    <Statement Name="CREATE DATABASE LINK" Url="http://docs.oracle.com/database/121/SQLRF/statements_5006.htm" />
    <Statement Name="CREATE DIMENSION" Url="http://docs.oracle.com/database/121/SQLRF/statements_5007.htm" />
    <Statement Name="CREATE DIRECTORY" Url="http://docs.oracle.com/database/121/SQLRF/statements_5008.htm" />
    <Statement Name="CREATE DISKGROUP" Url="http://docs.oracle.com/database/121/SQLRF/statements_5009.htm" />
    <Statement Name="CREATE EDITION" Url="http://docs.oracle.com/database/121/SQLRF/statements_5010.htm" />
    <Statement Name="CREATE FLASHBACK ARCHIVE" Url="http://docs.oracle.com/database/121/SQLRF/statements_5011.htm" />
    <Statement Name="CREATE FUNCTION" Url="http://docs.oracle.com/database/121/SQLRF/statements_5012.htm" />
    <Statement Name="CREATE INDEX" Url="http://docs.oracle.com/database/121/SQLRF/statements_5013.htm" />
    <Statement Name="CREATE INDEXTYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_5014.htm" />
    <Statement Name="CREATE JAVA" Url="http://docs.oracle.com/database/121/SQLRF/statements_5015.htm" />
    <Statement Name="CREATE LIBRARY" Url="http://docs.oracle.com/database/121/SQLRF/statements_6001.htm" />
    <Statement Name="CREATE MATERIALIZED VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_6002.htm" />
    <Statement Name="CREATE MATERIALIZED VIEW LOG" Url="http://docs.oracle.com/database/121/SQLRF/statements_6003.htm" />
    <Statement Name="CREATE MATERIALIZED ZONEMAP" Url="http://docs.oracle.com/database/121/SQLRF/statements_6004.htm" />
    <Statement Name="CREATE OPERATOR" Url="http://docs.oracle.com/database/121/SQLRF/statements_6005.htm" />
    <Statement Name="CREATE OUTLINE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6006.htm" />
    <Statement Name="CREATE PACKAGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6007.htm" />
    <Statement Name="CREATE PACKAGE BODY" Url="http://docs.oracle.com/database/121/SQLRF/statements_6008.htm" />
    <Statement Name="CREATE PFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6009.htm" />
    <Statement Name="CREATE PLUGGABLE DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6010.htm" />
    <Statement Name="CREATE PROCEDURE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6011.htm" />
    <Statement Name="CREATE PROFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6012.htm" />
    <Statement Name="CREATE RESTORE POINT" Url="http://docs.oracle.com/database/121/SQLRF/statements_6013.htm" />
    <Statement Name="CREATE ROLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6014.htm" />
    <Statement Name="CREATE ROLLBACK SEGMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_6015.htm" />
    <Statement Name="CREATE SCHEMA" Url="http://docs.oracle.com/database/121/SQLRF/statements_6016.htm" />
    <Statement Name="CREATE SEQUENCE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6017.htm" />
    <Statement Name="CREATE SPFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6018.htm" />
    <Statement Name="CREATE SYNONYM" Url="http://docs.oracle.com/database/121/SQLRF/statements_7001.htm" />
    <Statement Name="CREATE TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_7002.htm" />
    <Statement Name="CREATE TABLESPACE" Url="http://docs.oracle.com/database/121/SQLRF/statements_7003.htm" />
    <Statement Name="CREATE TRIGGER" Url="http://docs.oracle.com/database/121/SQLRF/statements_7004.htm" />
    <Statement Name="CREATE TYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8001.htm" />
    <Statement Name="CREATE TYPE BODY" Url="http://docs.oracle.com/database/121/SQLRF/statements_8002.htm" />
    <Statement Name="CREATE USER" Url="http://docs.oracle.com/database/121/SQLRF/statements_8003.htm" />
    <Statement Name="CREATE VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_8004.htm" />
    <Statement Name="DELETE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8005.htm" />
    <Statement Name="DISASSOCIATE STATISTICS" Url="http://docs.oracle.com/database/121/SQLRF/statements_8006.htm" />
    <Statement Name="DROP AUDIT POLICY" Url="http://docs.oracle.com/database/121/SQLRF/statements_8007.htm" />
    <Statement Name="DROP CLUSTER" Url="http://docs.oracle.com/database/121/SQLRF/statements_8008.htm" />
    <Statement Name="DROP CONTEXT" Url="http://docs.oracle.com/database/121/SQLRF/statements_8009.htm" />
    <Statement Name="DROP DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8010.htm" />
    <Statement Name="DROP DATABASE LINK" Url="http://docs.oracle.com/database/121/SQLRF/statements_8011.htm" />
    <Statement Name="DROP DIMENSION" Url="http://docs.oracle.com/database/121/SQLRF/statements_8012.htm" />
    <Statement Name="DROP DIRECTORY" Url="http://docs.oracle.com/database/121/SQLRF/statements_8013.htm" />
    <Statement Name="DROP DISKGROUP" Url="http://docs.oracle.com/database/121/SQLRF/statements_8014.htm" />
    <Statement Name="DROP EDITION" Url="http://docs.oracle.com/database/121/SQLRF/statements_8015.htm" />
    <Statement Name="DROP FLASHBACK ARCHIVE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8016.htm" />
    <Statement Name="DROP FUNCTION" Url="http://docs.oracle.com/database/121/SQLRF/statements_8017.htm" />
    <Statement Name="DROP INDEX" Url="http://docs.oracle.com/database/121/SQLRF/statements_8018.htm" />
    <Statement Name="DROP INDEXTYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8019.htm" />
    <Statement Name="DROP JAVA" Url="http://docs.oracle.com/database/121/SQLRF/statements_8020.htm" />
    <Statement Name="DROP LIBRARY" Url="http://docs.oracle.com/database/121/SQLRF/statements_8021.htm" />
    <Statement Name="DROP MATERIALIZED VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_8022.htm" />
    <Statement Name="DROP MATERIALIZED VIEW LOG" Url="http://docs.oracle.com/database/121/SQLRF/statements_8023.htm" />
    <Statement Name="DROP MATERIALIZED ZONEMAP" Url="http://docs.oracle.com/database/121/SQLRF/statements_8024.htm" />
    <Statement Name="DROP OPERATOR" Url="http://docs.oracle.com/database/121/SQLRF/statements_8025.htm" />
    <Statement Name="DROP OUTLINE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8026.htm" />
    <Statement Name="DROP PACKAGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8027.htm" />
    <Statement Name="DROP PLUGGABLE DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8028.htm" />
    <Statement Name="DROP PROCEDURE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8029.htm" />
    <Statement Name="DROP PROFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8030.htm" />
    <Statement Name="DROP RESTORE POINT" Url="http://docs.oracle.com/database/121/SQLRF/statements_8031.htm" />
    <Statement Name="DROP ROLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8032.htm" />
    <Statement Name="DROP ROLLBACK SEGMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_8033.htm" />
    <Statement Name="DROP SEQUENCE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9001.htm" />
    <Statement Name="DROP SYNONYM" Url="http://docs.oracle.com/database/121/SQLRF/statements_9002.htm" />
    <Statement Name="DROP TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9003.htm" />
    <Statement Name="DROP TABLESPACE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9004.htm" />
    <Statement Name="DROP TRIGGER" Url="http://docs.oracle.com/database/121/SQLRF/statements_9005.htm" />
    <Statement Name="DROP TYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9006.htm" />
    <Statement Name="DROP TYPE BODY" Url="http://docs.oracle.com/database/121/SQLRF/statements_9007.htm" />
    <Statement Name="DROP USER" Url="http://docs.oracle.com/database/121/SQLRF/statements_9008.htm" />
    <Statement Name="DROP VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_9009.htm" />
    <Statement Name="EXPLAIN PLAN" Url="http://docs.oracle.com/database/121/SQLRF/statements_9010.htm" />
    <Statement Name="FLASHBACK DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9011.htm" />
    <Statement Name="FLASHBACK TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9012.htm" />
    <Statement Name="GRANT" Url="http://docs.oracle.com/database/121/SQLRF/statements_9013.htm" />
    <Statement Name="INSERT" Url="http://docs.oracle.com/database/121/SQLRF/statements_9014.htm" />
    <Statement Name="LOCK TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9015.htm" />
    <Statement Name="MERGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9016.htm" />
    <Statement Name="NOAUDIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_9017.htm" />
    <Statement Name="NOAUDIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_9018.htm" />
    <Statement Name="PURGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9019.htm" />
    <Statement Name="RENAME" Url="http://docs.oracle.com/database/121/SQLRF/statements_9020.htm" />
    <Statement Name="REVOKE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9021.htm" />
    <Statement Name="ROLLBACK" Url="http://docs.oracle.com/database/121/SQLRF/statements_9022.htm" />
    <Statement Name="SAVEPOINT" Url="http://docs.oracle.com/database/121/SQLRF/statements_10001.htm" />
    <Statement Name="SELECT" Url="http://docs.oracle.com/database/121/SQLRF/statements_10002.htm" />
    <Statement Name="SET CONSTRAINT" Url="http://docs.oracle.com/database/121/SQLRF/statements_10003.htm" />
    <Statement Name="SET CONSTRAINTS" Url="http://docs.oracle.com/database/121/SQLRF/statements_10003.htm" />
    <Statement Name="SET ROLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_10004.htm" />
    <Statement Name="SET TRANSACTION" Url="http://docs.oracle.com/database/121/SQLRF/statements_10005.htm" />
    <Statement Name="TRUNCATE CLUSTER" Url="http://docs.oracle.com/database/121/SQLRF/statements_10006.htm" />
    <Statement Name="TRUNCATE TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_10007.htm" />
    <Statement Name="UPDATE" Url="http://docs.oracle.com/database/121/SQLRF/statements_10008.htm" />
  </Statements>
</Documentation>