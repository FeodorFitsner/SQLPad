<?xml version="1.0" encoding="utf-8"?>
<Documentation xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://husqvik.com/SqlPad/2014/08/Oracle">
  <Functions>
    <Function Name="ABS" Url="http://docs.oracle.com/database/121/SQLRF/functions009.htm">ABS returns the absolute value of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="ACOS" Url="http://docs.oracle.com/database/121/SQLRF/functions010.htm">ACOS returns the arc cosine of n. The argument n must be in the range of -1 to 1, and the function returns a value in the range of 0 to pi, expressed in radians.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="ADD_MONTHS" Url="http://docs.oracle.com/database/121/SQLRF/functions011.htm">ADD_MONTHS returns the date date plus integer months. A month is defined by the session parameter NLS_CALENDAR. The date argument can be a datetime value or any value that can be implicitly converted to DATE. The integer argument can be an integer or any value that can be implicitly converted to an integer. The return type is always DATE, regardless of the data type of date. If date is the last day of the month or if the resulting month has fewer days than the day component of date, then the result is the last day of the resulting month. Otherwise, the result has the same day component as date.</Function>
    <Function Name="APPENDCHILDXML" Url="http://docs.oracle.com/database/121/SQLRF/functions012.htm">APPENDCHILDXML appends a user-supplied value onto the target XML as the child of the node indicated by an XPath expression.

XMLType_instance is an instance of XMLType.

XPath_string is an Xpath expression indicating one or more nodes onto which one or more child nodes are to be appended. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node.

value_expr specifies one or more nodes of XMLType. It must resolve to a string.

The optional namespace_string provides namespace information for the XPath_string. This parameter must be of type VARCHAR2.</Function>
    <Function Name="APPROX_COUNT_DISTINCT" Url="http://docs.oracle.com/database/121/SQLRF/functions013.htm">APPROX_COUNT_DISTINCT returns the approximate number of rows that contain distinct values of expr.
This function provides an alternative to the COUNT (DISTINCT expr) function, which returns the exact number of rows that contain distinct values of expr. APPROX_COUNT_DISTINCT processes large amounts of data significantly faster than COUNT, with negligible deviation from the exact result.
For expr, you can specify a column of any scalar data type other than BFILE, BLOB, CLOB, LONG, LONG RAW, or NCLOB.
APPROX_COUNT_DISTINCT ignores rows that contain a null value for expr. This function returns a NUMBER.</Function>
    <Function Name="ASCII" Url="http://docs.oracle.com/database/121/SQLRF/functions014.htm">ASCII returns the decimal representation in the database character set of the first character of char.
char can be of data type CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The value returned is of data type NUMBER. If your database character set is 7-bit ASCII, then this function returns an ASCII value. If your database character set is EBCDIC Code, then this function returns an EBCDIC value. There is no corresponding EBCDIC character function.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="ASCIISTR" Url="http://docs.oracle.com/database/121/SQLRF/functions015.htm">ASCIISTR takes as its argument a string, or an expression that resolves to a string, in any character set and returns an ASCII version of the string in the database character set. Non-ASCII characters are converted to the form \xxxx, where xxxx represents a UTF-16 code unit.</Function>
    <Function Name="ASIN" Url="http://docs.oracle.com/database/121/SQLRF/functions016.htm">ASIN returns the arc sine of n. The argument n must be in the range of -1 to 1, and the function returns a value in the range of -pi/2 to pi/2, expressed in radians.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="ATAN" Url="http://docs.oracle.com/database/121/SQLRF/functions017.htm">ATAN returns the arc tangent of n. The argument n can be in an unbounded range and returns a value in the range of -pi/2 to pi/2, expressed in radians.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="ATAN2" Url="http://docs.oracle.com/database/121/SQLRF/functions018.htm">ATAN2 returns the arc tangent of n1 and n2. The argument n1 can be in an unbounded range and returns a value in the range of -pi to pi, depending on the signs of n1 and n2, expressed in radians.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is BINARY_FLOAT or BINARY_DOUBLE, then the function returns BINARY_DOUBLE. Otherwise the function returns NUMBER.</Function>
    <Function Name="AVG" Url="http://docs.oracle.com/database/121/SQLRF/functions019.htm">AVG returns average value of expr.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="BFILENAME" Url="http://docs.oracle.com/database/121/SQLRF/functions020.htm">BFILENAME returns a BFILE locator that is associated with a physical LOB binary file on the server file system.

'directory' is a database object that serves as an alias for a full path name on the server file system where the files are actually located.

'filename' is the name of the file in the server file system.

You must create the directory object and associate a BFILE value with a physical file before you can use them as arguments to BFILENAME in a SQL or PL/SQL statement, DBMS_LOB package, or OCI operation.
You can use this function in two ways:

In a DML statement to initialize a BFILE column

In a programmatic interface to access BFILE data by assigning a value to the BFILE locator

The directory argument is case sensitive. You must ensure that you specify the directory object name exactly as it exists in the data dictionary. For example, if an "Admin" directory object was created using mixed case and a quoted identifier in the CREATE DIRECTORY statement, then when using the BFILENAME function you must refer to the directory object as 'Admin'. You must specify the filename argument according to the case and punctuation conventions for your operating system.</Function>
    <Function Name="BIN_TO_NUM" Url="http://docs.oracle.com/database/121/SQLRF/functions021.htm">BIN_TO_NUM converts a bit vector to its equivalent number. Each argument to this function represents a bit in the bit vector. This function takes as arguments any numeric data type, or any nonnumeric data type that can be implicitly converted to NUMBER. Each expr must evaluate to 0 or 1. This function returns Oracle NUMBER.
BIN_TO_NUM is useful in data warehousing applications for selecting groups of interest from a materialized view using grouping sets.</Function>
    <Function Name="BITAND" Url="http://docs.oracle.com/database/121/SQLRF/functions022.htm">The BITAND function treats its inputs and its output as vectors of bits; the output is the bitwise AND of the inputs.
The types of expr1 and expr2 are NUMBER, and the result is of type NUMBER. If either argument to BITAND is NULL, the result is NULL.
The arguments must be in the range -(2(n-1)) .. ((2(n-1))-1). If an argument is out of this range, the result is undefined.
The result is computed in several steps. First, each argument A is replaced with the value SIGN(A)*FLOOR(ABS(A)). This conversion has the effect of truncating each argument towards zero. Next, each argument A (which must now be an integer value) is converted to an n-bit two's complement binary integer value. The two bit values are combined using a bitwise AND operation. Finally, the resulting n-bit two's complement value is converted back to NUMBER.

Notes on the BITAND Function

The current implementation of BITAND defines n = 128.

PL/SQL supports an overload of BITAND for which the types of the inputs and of the result are all BINARY_INTEGER and for which n = 32.</Function>
    <Function Name="CARDINALITY" Url="http://docs.oracle.com/database/121/SQLRF/functions023.htm">CARDINALITY returns the number of elements in a nested table. The return type is NUMBER. If the nested table is empty, or is a null collection, then CARDINALITY returns NULL.</Function>
    <Function Name="CAST" Url="http://docs.oracle.com/database/121/SQLRF/functions024.htm">CAST converts one built-in data type or collection-typed value into another built-in data type or collection-typed value.
CAST lets you convert built-in data types or collection-typed values of one type into another built-in data type or collection type. You can cast an unnamed operand (such as a date or the result set of a subquery) or a named collection (such as a varray or a nested table) into a type-compatible data type or named collection. The type_name must be the name of a built-in data type or collection type and the operand must be a built-in data type or must evaluate to a collection value.
For the operand, expr can be either a built-in data type, a collection type, or an instance of an ANYDATA type. If expr is an instance of an ANYDATA type, then CAST tries to extract the value of the ANYDATA instance and return it if it matches the cast target type, otherwise, null will be returned. MULTISET informs Oracle Database to take the result set of the subquery and return a collection value. Table 7-1 shows which built-in data types can be cast into which other built-in data types. (CAST does not support LONG, LONG RAW, or the Oracle-supplied types.)
CAST does not directly support any of the LOB data types. When you use CAST to convert a CLOB value into a character data type or a BLOB value into the RAW data type, the database implicitly converts the LOB value to character or raw data and then explicitly casts the resulting value into the target data type. If the resulting value is larger than the target type, then the database returns an error.
When you use CAST ... MULTISET to get a collection value, each select list item in the query passed to the CAST function is converted to the corresponding attribute type of the target collection element type.</Function>
    <Function Name="CEIL" Url="http://docs.oracle.com/database/121/SQLRF/functions025.htm">CEIL returns the smallest integer that is greater than or equal to n. The number n can always be written as the difference of an integer k and a positive fraction f such that 0 &lt;= f &lt; 1 and n = k - f. The value of CEIL is the integer k. Thus, the value of CEIL is n itself if and only if n is precisely an integer.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="CHARTOROWID" Url="http://docs.oracle.com/database/121/SQLRF/functions026.htm">CHARTOROWID converts a value from CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to ROWID data type.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="CHR" Url="http://docs.oracle.com/database/121/SQLRF/functions027.htm">CHR returns the character having the binary equivalent to n as a VARCHAR2 value in either the database character set or, if you specify USING NCHAR_CS, the national character set.
For single-byte character sets, if n &gt; 256, then Oracle Database returns the binary equivalent of n mod 256. For multibyte character sets, n must resolve to one entire code point. Invalid code points are not validated, and the result of specifying invalid code points is indeterminate.
This function takes as an argument a NUMBER value, or any value that can be implicitly converted to NUMBER, and returns a character.</Function>
    <Function Name="CLUSTER_DETAILS" Url="http://docs.oracle.com/database/121/SQLRF/functions028.htm">CLUSTER_DETAILS returns cluster details for each row in the selection. The return value is an XML string that describes the attributes of the highest probability cluster or the specified cluster_id.

topN
If you specify a value for topN, the function returns the N attributes that most influence the cluster assignment (the score). If you do not specify topN, the function returns the 5 most influential attributes.

DESC, ASC, or ABS
The returned attributes are ordered by weight. The weight of an attribute expresses its positive or negative impact on cluster assignment. A positive weight indicates an increased likelihood of assignment. A negative weight indicates a decreased likelihood of assignment.
By default, CLUSTER_DETAILS returns the attributes with the highest positive weights (DESC). If you specify ASC, the attributes with the highest negative weights are returned. If you specify ABS, the attributes with the greatest weights, whether negative or positive, are returned. The results are ordered by absolute value from highest to lowest. Attributes with a zero weight are not included in the output.

Syntax Choice
CLUSTER_DETAILS can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="CLUSTER_DISTANCE" Url="http://docs.oracle.com/database/121/SQLRF/functions029.htm">CLUSTER_DISTANCE returns a cluster distance for each row in the selection. The cluster distance is the distance between the row and the centroid of the highest probability cluster or the specified cluster_id. The distance is returned as BINARY_DOUBLE.

Syntax Choice
CLUSTER_DISTANCE can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, this data is also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="CLUSTER_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions030.htm">CLUSTER_ID returns the identifier of the highest probability cluster for each row in the selection. The cluster identifier is returned as an Oracle NUMBER.

Syntax Choice
CLUSTER_ID can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="CLUSTER_PROBABILITY" Url="http://docs.oracle.com/database/121/SQLRF/functions031.htm">CLUSTER_PROBABILITY returns a probability for each row in the selection. The probability refers to the highest probability cluster or to the specified cluster_id. The cluster probability is returned as BINARY_DOUBLE.

Syntax Choice
CLUSTER_PROBABILITY can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="CLUSTER_SET" Url="http://docs.oracle.com/database/121/SQLRF/functions032.htm">CLUSTER_SET returns a set of cluster ID and probability pairs for each row in the selection. The return value is a varray of objects with field names CLUSTER_ID and PROBABILITY. The cluster identifier is an Oracle NUMBER; the probability is BINARY_DOUBLE.

topN and cutoff
You can specify topN and cutoff to limit the number of clusters returned by the function. By default, both topN and cutoff are null and all clusters are returned.

topN is the N most probable clusters. If multiple clusters share the Nth probability, then the function chooses one of them.

cutoff is a probability threshold. Only clusters with probability greater than or equal to cutoff are returned. To filter by cutoff only, specify NULL for topN.

To return up to the N most probable clusters that are greater than or equal to cutoff, specify both topN and cutoff.

Syntax Choice
CLUSTER_SET can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a clustering model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of clusters to compute, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="COALESCE" Url="http://docs.oracle.com/database/121/SQLRF/functions033.htm">COALESCE returns the first non-null expr in the expression list. You must specify at least two expressions. If all occurrences of expr evaluate to null, then the function returns null.
Oracle Database uses short-circuit evaluation. The database evaluates each expr value and determines whether it is NULL, rather than evaluating all of the expr values before determining whether any of them is NULL.
If all occurrences of expr are numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="COLLECT" Url="http://docs.oracle.com/database/121/SQLRF/functions034.htm">COLLECT is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a CAST function.
If column is itself a collection, then the output of COLLECT is a nested table of collections. If column is of a user-defined type, then column must have a MAP or ORDER method defined on it in order for you to use the optional DISTINCT, UNIQUE, and ORDER BY clauses.</Function>
    <Function Name="COMPOSE" Url="http://docs.oracle.com/database/121/SQLRF/functions035.htm">COMPOSE takes as its argument a string, or an expression that resolves to a string, in any data type, and returns a Unicode string in the same character set as the input. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. For example, an o code point qualified by an umlaut code point will be returned as the o-umlaut code point.
COMPOSE returns the string in NFC normal form. For a more exclusive setting, you can first call DECOMPOSE with the CANONICAL setting and then COMPOSE. This combination returns the string in NFKC normal form.
CLOB and NCLOB values are supported through implicit conversion. If char is a character LOB value, then it is converted to a VARCHAR value before the COMPOSE operation. The operation will fail if the size of the LOB value exceeds the supported length of the VARCHAR in the particular development environment.</Function>
    <Function Name="CONCAT" Url="http://docs.oracle.com/database/121/SQLRF/functions040.htm">CONCAT returns char1 concatenated with char2. Both char1 and char2 can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is in the same character set as char1. Its data type depends on the data types of the arguments.
In concatenations of two different data types, Oracle Database returns the data type that results in a lossless conversion. Therefore, if one of the arguments is a LOB, then the returned value is a LOB. If one of the arguments is a national data type, then the returned value is a national data type. For example:

CONCAT(CLOB, NCLOB) returns NCLOB

CONCAT(NCLOB, NCHAR) returns NCLOB

CONCAT(NCLOB, CHAR) returns NCLOB

CONCAT(NCHAR, CLOB) returns NCLOB

This function is equivalent to the concatenation operator (||).</Function>
    <Function Name="CONVERT" Url="http://docs.oracle.com/database/121/SQLRF/functions041.htm">CONVERT converts a character string from one character set to another.

The char argument is the value to be converted. It can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

The dest_char_set argument is the name of the character set to which char is converted.

The source_char_set argument is the name of the character set in which char is stored in the database. The default value is the database character set.

The return value for CHAR and VARCHAR2 is VARCHAR2. For NCHAR and NVARCHAR2, it is NVARCHAR2. For CLOB, it is CLOB, and for NCLOB, it is NCLOB.
Both the destination and source character set arguments can be either literals or columns containing the name of the character set.
For complete correspondence in character conversion, it is essential that the destination character set contains a representation of all the characters defined in the source character set. Where a character does not exist in the destination character set, a replacement character appears. Replacement characters can be defined as part of a character set definition.</Function>
    <Function Name="CORR" Url="http://docs.oracle.com/database/121/SQLRF/functions042.htm">CORR returns the coefficient of correlation of a set of number pairs. You can use it as an aggregate or analytic function.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="CORR" Url="http://docs.oracle.com/database/121/SQLRF/functions043.htm">The CORR function (see CORR) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The CORR_* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship.
These functions takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns NUMBER.</Function>
    <Function Name="COS" Url="http://docs.oracle.com/database/121/SQLRF/functions044.htm">COS returns the cosine of n (an angle expressed in radians).
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="COSH" Url="http://docs.oracle.com/database/121/SQLRF/functions045.htm">COSH returns the hyperbolic cosine of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="COUNT" Url="http://docs.oracle.com/database/121/SQLRF/functions046.htm">COUNT returns the number of rows returned by the query. You can use it as an aggregate or analytic function.
If you specify DISTINCT, then you can specify only the query_partition_clause of the analytic_clause. The order_by_clause and windowing_clause are not allowed.
If you specify expr, then COUNT returns the number of rows where expr is not null. You can count either all rows, or only distinct values of expr.
If you specify the asterisk (*), then this function returns all rows, including duplicates and nulls. COUNT never returns null.</Function>
    <Function Name="COVAR_POP" Url="http://docs.oracle.com/database/121/SQLRF/functions047.htm">COVAR_POP returns the population covariance of a set of number pairs. You can use it as an aggregate or analytic function.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="COVAR_SAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions048.htm">COVAR_SAMP returns the sample covariance of a set of number pairs. You can use it as an aggregate or analytic function.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="CUBE_TABLE" Url="http://docs.oracle.com/database/121/SQLRF/functions049.htm">CUBE_TABLE extracts data from a cube or dimension and returns it in the two-dimensional format of a relational table, which can be used by SQL-based applications.
The function takes a single VARCHAR2 argument. The optional hierarchy clause enables you to specify a dimension hierarchy. A cube can have multiple hierarchy clauses, one for each dimension.
You can generate these different types of tables:

A cube table contains a key column for each dimension and a column for each measure and calculated measure in the cube. To create a cube table, you can specify the cube with or without a cube hierarchy clause. For a dimension with multiple hierarchies, this clause limits the return values to the dimension members and levels in the specified hierarchy. Without a hierarchy clause, all dimension members and all levels are included.

A dimension table contains a key column, and a column for each level and each attribute. It also contains a MEMBER_TYPE column, which identifies each member with one of the following codes:

L - Loaded from a table, view, or synonym

A - Loaded member and the single root of all hierarchies in the dimension, that is, the "all" aggregate member

C - Calculated member

All dimension members and all levels are included in the table. To create a dimension table, specify the dimension without a dimension hierarchy clause.

A hierarchy table contains all the columns of a dimension table plus a column for the parent member and a column for each source level. It also contains a MEMBER_TYPE column, as described for dimension tables. Any dimension members and levels that are not part of the named hierarchy are excluded from the table. To create a hierarchy table, specify the dimension with a dimension hierarchy clause.

CUBE_TABLE is a table function and is always used in the context of a SELECT statement with this syntax:

SELECT ... FROM TABLE(CUBE_TABLE('arg'));</Function>
    <Function Name="CUME_DIST" Url="http://docs.oracle.com/database/121/SQLRF/functions050.htm">CUME_DIST calculates the cumulative distribution of a value in a group of values. The range of values returned by CUME_DIST is &gt;0 to &lt;=1. Tie values always evaluate to the same cumulative distribution value.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns NUMBER.</Function>
    <Function Name="CURRENT_DATE" Url="http://docs.oracle.com/database/121/SQLRF/functions051.htm">CURRENT_DATE returns the current date in the session time zone, in a value in the Gregorian calendar of data type DATE.</Function>
    <Function Name="CURRENT_TIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions052.htm">CURRENT_TIMESTAMP returns the current date and time in the session time zone, in a value of data type TIMESTAMP WITH TIME ZONE. The time zone offset reflects the current local time of the SQL session. If you omit precision, then the default is 6. The difference between this function and LOCALTIMESTAMP is that CURRENT_TIMESTAMP returns a TIMESTAMP WITH TIME ZONE value while LOCALTIMESTAMP returns a TIMESTAMP value.
In the optional argument, precision specifies the fractional second precision of the time value returned.</Function>
    <Function Name="CV" Url="http://docs.oracle.com/database/121/SQLRF/functions053.htm">The CV function can be used only in the model_clause of a SELECT statement and then only on the right-hand side of a model rule. It returns the current value of a dimension column or a partitioning column carried from the left-hand side to the right-hand side of a rule. This function is used in the model_clause to provide relative indexing with respect to the dimension column. The return type is that of the data type of the dimension column. If you omit the argument, then it defaults to the dimension column associated with the relative position of the function within the cell reference.
The CV function can be used outside a cell reference. In this case, dimension_column is required.</Function>
    <Function Name="DATAOBJ_TO_PARTITION" Url="http://docs.oracle.com/database/121/SQLRF/functions054.htm">DATAOBJ_TO_PARTITION is useful only to Data Cartridge developers who are performing data maintenance or query operations on system-partitioned tables that are used to store domain index data. The DML or query operations are triggered by corresponding operations on the base table of the domain index.
This function takes as arguments the name of the base table and the partition ID of the base table partition, both of which are passed to the function by the appropriate ODCIIndex method. The function returns the partition ID of the corresponding system-partitioned table, which can be used to perform the operation (DML or query) on that partition of the system-partitioned table.</Function>
    <Function Name="DBTIMEZONE" Url="http://docs.oracle.com/database/121/SQLRF/functions055.htm">DBTIMEZONE returns the value of the database time zone. The return type is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the user specified the database time zone value in the most recent CREATE DATABASE or ALTER DATABASE statement.</Function>
    <Function Name="DECODE" Url="http://docs.oracle.com/database/121/SQLRF/functions056.htm">DECODE compares expr to each search value one by one. If expr is equal to a search, then Oracle Database returns the corresponding result. If no match is found, then Oracle returns default. If default is omitted, then Oracle returns null.
The arguments can be any of the numeric types (NUMBER, BINARY_FLOAT, or BINARY_DOUBLE) or character types.

If expr and search are character data, then Oracle compares them using nonpadded comparison semantics. expr, search, and result can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The string returned is of VARCHAR2 data type and is in the same character set as the first result parameter.

If the first search-result pair are numeric, then Oracle compares all search-result expressions and the first expr to determine the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.

The search, result, and default values can be derived from expressions. Oracle Database uses short-circuit evaluation. The database evaluates each search value only before comparing it to expr, rather than evaluating all search values before comparing any of them with expr. Consequently, Oracle never evaluates a search if a previous search is equal to expr.
Oracle automatically converts expr and each search value to the data type of the first search value before comparing. Oracle automatically converts the return value to the same data type as the first result. If the first result has the data type CHAR or if the first result is null, then Oracle converts the return value to the data type VARCHAR2.
In a DECODE function, Oracle considers two nulls to be equivalent. If expr is null, then Oracle returns the result of the first search that is also null.
The maximum number of components in the DECODE function, including expr, searches, results, and default, is 255.</Function>
    <Function Name="DECOMPOSE" Url="http://docs.oracle.com/database/121/SQLRF/functions057.htm">DECOMPOSE is valid only for Unicode characters. DECOMPOSE takes as its argument a string in any data type and returns a Unicode string after decomposition in the same character set as the input. For example, an o-umlaut code point will be returned as the "o" code point followed by an umlaut code point.

string can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

CANONICAL causes canonical decomposition, which allows recomposition (for example, with the COMPOSE function) to the original string. This is the default and returns the string in NFD normal form.

COMPATIBILITY causes decomposition in compatibility mode. In this mode, recomposition is not possible. This mode is useful, for example, when decomposing half-width and full-width katakana characters, where recomposition might not be desirable without external formatting or style information. It returns the string in NFKD normal form.

CLOB and NCLOB values are supported through implicit conversion. If char is a character LOB value, then it is converted to a VARCHAR value before the COMPOSE operation. The operation will fail if the size of the LOB value exceeds the supported length of the VARCHAR in the particular development environment.</Function>
    <Function Name="DELETEXML" Url="http://docs.oracle.com/database/121/SQLRF/functions058.htm">DELETEXML deletes the node or nodes matched by the XPath expression in the target XML.

XMLType_instance is an instance of XMLType.

XPath_string is an Xpath expression indicating one or more nodes that are to be deleted. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. Any child nodes of the nodes specified by XPath_string are also deleted.

The optional namespace_string provides namespace information for the XPath_string. This parameter must be of type VARCHAR2.</Function>
    <Function Name="DENSE_RANK" Url="http://docs.oracle.com/database/121/SQLRF/functions059.htm">DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting.
This function accepts as arguments any numeric data type and returns NUMBER.

As an aggregate function, DENSE_RANK calculates the dense rank of a hypothetical row identified by the arguments of the function with respect to a given sort specification. The arguments of the function must all evaluate to constant expressions within each aggregate group, because they identify a single row within each group. The constant argument expressions and the expressions in the order_by_clause of the aggregate match by position. Therefore, the number of arguments must be the same and types must be compatible.

As an analytic function, DENSE_RANK computes the rank of each row returned from a query with respect to the other rows, based on the values of the value_exprs in the order_by_clause.</Function>
    <Function Name="DEPTH" Url="http://docs.oracle.com/database/121/SQLRF/functions060.htm">DEPTH is an ancillary function used only with the UNDER_PATH and EQUALS_PATH conditions. It returns the number of levels in the path specified by the UNDER_PATH condition with the same correlation variable.
The correlation_integer can be any NUMBER integer. Use it to correlate this ancillary function with its primary condition if the statement contains multiple primary conditions. Values less than 1 are treated as 1.</Function>
    <Function Name="DEREF" Url="http://docs.oracle.com/database/121/SQLRF/functions061.htm">DEREF returns the object reference of argument expr, where expr must return a REF to an object. If you do not use this function in a query, then Oracle Database returns the object ID of the REF instead, as shown in the example that follows.</Function>
    <Function Name="DUMP" Url="http://docs.oracle.com/database/121/SQLRF/functions062.htm">DUMP returns a VARCHAR2 value containing the data type code, length in bytes, and internal representation of expr. The returned result is always in the database character set. For the data type corresponding to each code, see Table 2-1, "Built-in Data Type Summary".
The argument return_fmt specifies the format of the return value and can have any of the following values:

8 returns result in octal notation.

10 returns result in decimal notation.

16 returns result in hexadecimal notation.

17 returns each byte printed as a character if and only if it can be interpreted as a printable character in the character set of the compiler—typically ASCII or EBCDIC. Some ASCII control characters may be printed in the form ^X as well. Otherwise the character is printed in hexadecimal notation. All NLS parameters are ignored. Do not depend on any particular output format for DUMP with return_fmt 17.

By default, the return value contains no character set information. To retrieve the character set name of expr, add 1000 to any of the preceding format values. For example, a return_fmt of 1008 returns the result in octal and provides the character set name of expr.
The arguments start_position and length combine to determine which portion of the internal representation to return. The default is to return the entire internal representation in decimal notation.
If expr is null, then this function returns NULL.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="EMPTY_BLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions063.htm">EMPTY_BLOB and EMPTY_CLOB return an empty LOB locator that can be used to initialize a LOB variable or, in an INSERT or UPDATE statement, to initialize a LOB column or attribute to EMPTY. EMPTY means that the LOB is initialized, but not populated with data.</Function>
    <Function Name="EXISTSNODE" Url="http://docs.oracle.com/database/121/SQLRF/functions064.htm">EXISTSNODE determines whether traversal of an XML document using a specified path results in any nodes. It takes as arguments the XMLType instance containing an XML document and a VARCHAR2 XPath string designating a path. The optional namespace_string must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).
The namespace_string argument defaults to the namespace of the root element. If you refer to any subelement in Xpath_string, then you must specify namespace_string, and you must specify the "who" prefix in both of these arguments.</Function>
    <Function Name="EXP" Url="http://docs.oracle.com/database/121/SQLRF/functions065.htm">EXP returns e raised to the nth power, where e = 2.71828183... . The function returns a value of the same type as the argument.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="EXTRACT" Url="http://docs.oracle.com/database/121/SQLRF/functions066.htm">EXTRACT extracts and returns the value of a specified datetime field from a datetime or interval expression. The expr can be any expression that evaluates to a datetime or interval data type compatible with the requested field:

If YEAR or MONTH is requested, then expr must evaluate to an expression of data type DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, or INTERVAL YEAR TO MONTH.

If DAY is requested, then expr must evaluate to an expression of data type DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, or INTERVAL DAY TO SECOND.

If HOUR, MINUTE, or SECOND is requested, then expr must evaluate to an expression of data type TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, or INTERVAL DAY TO SECOND. DATE is not valid here, because Oracle Database treats it as ANSI DATE data type, which has no time fields.

If TIMEZONE_HOUR, TIMEZONE_MINUTE, TIMEZONE_ABBR, TIMEZONE_REGION, or TIMEZONE_OFFSET is requested, then expr must evaluate to an expression of data type TIMESTAMP WITH TIME ZONE or TIMESTAMP WITH LOCAL TIME ZONE.

EXTRACT interprets expr as an ANSI datetime data type. For example, EXTRACT treats DATE not as legacy Oracle DATE but as ANSI DATE, without time elements. Therefore, you can extract only YEAR, MONTH, and DAY from a DATE value. Likewise, you can extract TIMEZONE_HOUR and TIMEZONE_MINUTE only from the TIMESTAMP WITH TIME ZONE data type.
When you specify TIMEZONE_REGION or TIMEZONE_ABBR (abbreviation), the value returned is a VARCHAR2 string containing the appropriate time zone region name or abbreviation. When you specify any of the other datetime fields, the value returned is an integer value of NUMBER data type representing the datetime value in the Gregorian calendar. When extracting from a datetime with a time zone value, the value returned is in UTC. For a listing of time zone region names and their corresponding abbreviations, query the V$TIMEZONE_NAMES dynamic performance view.
This function can be very useful for manipulating datetime field values in very large tables, as shown in the first example below.</Function>
    <Function Name="EXTRACT" Url="http://docs.oracle.com/database/121/SQLRF/functions067.htm">EXTRACT (XML) is similar to the EXISTSNODE function. It applies a VARCHAR2 XPath string and returns an XMLType instance containing an XML fragment. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. The optional namespace_string is required if the XML you are handling uses a namespace prefix. This argument must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).</Function>
    <Function Name="FEATURE_DETAILS" Url="http://docs.oracle.com/database/121/SQLRF/functions069.htm">FEATURE_DETAILS returns feature details for each row in the selection. The return value is an XML string that describes the attributes of the highest value feature or the specified feature_id.

topN
If you specify a value for topN, the function returns the N attributes that most influence the feature value. If you do not specify topN, the function returns the 5 most influential attributes.

DESC, ASC, or ABS
The returned attributes are ordered by weight. The weight of an attribute expresses its positive or negative impact on the value of the feature. A positive weight indicates a higher feature value. A negative weight indicates a lower feature value.
By default, FEATURE_DETAILS returns the attributes with the highest positive weight (DESC). If you specify ASC, the attributes with the highest negative weight are returned. If you specify ABS, the attributes with the greatest weight, whether negative or positive, are returned. The results are ordered by absolute value from highest to lowest. Attributes with a zero weight are not included in the output.

Syntax Choice
FEATURE_DETAILS can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a feature extraction model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of features to extract, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="FEATURE_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions070.htm">FEATURE_ID returns the identifier of the highest value feature for each row in the selection. The feature identifier is returned as an Oracle NUMBER.

Syntax Choice
FEATURE_ID can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a feature extraction model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of features to extract, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="FEATURE_SET" Url="http://docs.oracle.com/database/121/SQLRF/functions071.htm">FEATURE_SET returns a set of feature ID and feature value pairs for each row in the selection. The return value is a varray of objects with field names FEATURE_ID and VALUE. The data type of both fields is NUMBER.

topN and cutoff
You can specify topN and cutoff to limit the number of features returned by the function. By default, both topN and cutoff are null and all features are returned.

topN is the N highest value features. If multiple features have the Nth value, then the function chooses one of them.

cutoff is a value threshold. Only features that are greater than or equal to cutoff are returned. To filter by cutoff only, specify NULL for topN.

To return up to N features that are greater than or equal to cutoff, specify both topN and cutoff.

Syntax Choice
FEATURE_SET can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a feature extraction model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of features to extract, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="FEATURE_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions072.htm">FEATURE_VALUE returns a feature value for each row in the selection. The value refers to the highest value feature or to the specified feature_id. The feature value is returned as BINARY_DOUBLE.

Syntax Choice
FEATURE_VALUE can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a feature extraction model.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. Include INTO n, where n is the number of features to extract, and mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)


mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, this data is also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="FIRST" Url="http://docs.oracle.com/database/121/SQLRF/functions073.htm">FIRST and LAST are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the FIRST or LAST with respect to a given sorting specification. If only one row ranks as FIRST or LAST, then the aggregate operates on the set with only one element.
If you omit the OVER clause, then the FIRST and LAST functions are treated as aggregate functions. You can use these functions as analytic functions by specifying the OVER clause. The query_partition_clause is the only part of the OVER clause valid with these functions. If you include the OVER clause but omit the query_partition_clause, then the function is treated as an analytic function, but the window defined for analysis is the entire table.
These functions take as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.
When you need a value from the first or last row of a sorted group, but the needed value is not the sort key, the FIRST and LAST functions eliminate the need for self-joins or views and enable better performance.

The aggregate_function argument is any one of the MIN, MAX, SUM, AVG, COUNT, VARIANCE, or STDDEV functions. It operates on values from the rows that rank either FIRST or LAST. If only one row ranks as FIRST or LAST, then the aggregate operates on a singleton (nonaggregate) set.

The KEEP keyword is for semantic clarity. It qualifies aggregate_function, indicating that only the FIRST or LAST values of aggregate_function will be returned.

DENSE_RANK FIRST or DENSE_RANK LAST indicates that Oracle Database will aggregate over only those rows with the minimum (FIRST) or the maximum (LAST) dense rank (also called olympic rank).</Function>
    <Function Name="FIRST" Url="http://docs.oracle.com/database/121/SQLRF/functions094.htm">FIRST and LAST are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the FIRST or LAST with respect to a given sorting specification. If only one row ranks as FIRST or LAST, then the aggregate operates on the set with only one element.
Refer to FIRST for complete information on this function and for examples of its use.</Function>
    <Function Name="FIRST_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions074.htm">FIRST_VALUE is an analytic function. It returns the first value in an ordered set of values. If the first value in the set is null, then the function returns NULL unless you specify IGNORE NULLS. This setting is useful for data densification.</Function>
    <Function Name="FLOOR" Url="http://docs.oracle.com/database/121/SQLRF/functions075.htm">FLOOR returns the largest integer equal to or less than n. The number n can always be written as the sum of an integer k and a positive fraction f such that 0 &lt;= f &lt; 1 and n = k + f. The value of FLOOR is the integer k. Thus, the value of FLOOR is n itself if and only if n is precisely an integer.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="FROM_TZ" Url="http://docs.oracle.com/database/121/SQLRF/functions076.htm">FROM_TZ converts a timestamp value and a time zone to a TIMESTAMP WITH TIME ZONE value. time_zone_value is a character string in the format 'TZH:TZM' or a character expression that returns a string in TZR with optional TZD format.</Function>
    <Function Name="GREATEST" Url="http://docs.oracle.com/database/121/SQLRF/functions077.htm">GREATEST returns the greatest of a list of one or more expressions. Oracle Database uses the first expr to determine the return type. If the first expr is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first expr is not numeric, then each expr after the first is implicitly converted to the data type of the first expr before the comparison.
Oracle Database compares each expr using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the NLS_COMP parameter is set to LINGUISTIC and the NLS_SORT parameter has a setting other than BINARY. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is VARCHAR2 if the first expr is a character data type and NVARCHAR2 if the first expr is a national character data type.</Function>
    <Function Name="GROUP_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions078.htm">GROUP_ID distinguishes duplicate groups resulting from a GROUP BY specification. It is useful in filtering out duplicate groupings from the query result. It returns an Oracle NUMBER to uniquely identify duplicate groups. This function is applicable only in a SELECT statement that contains a GROUP BY clause.
If n duplicates exist for a particular grouping, then GROUP_ID returns numbers in the range 0 to n-1.</Function>
    <Function Name="GROUPING" Url="http://docs.oracle.com/database/121/SQLRF/functions079.htm">GROUPING distinguishes superaggregate rows from regular grouped rows. GROUP BY extensions such as ROLLUP and CUBE produce superaggregate rows where the set of all values is represented by null. Using the GROUPING function, you can distinguish a null representing the set of all values in a superaggregate row from a null in a regular row.
The expr in the GROUPING function must match one of the expressions in the GROUP BY clause. The function returns a value of 1 if the value of expr in the row is a null representing the set of all values. Otherwise, it returns zero. The data type of the value returned by the GROUPING function is Oracle NUMBER. Refer to the SELECT group_by_clause for a discussion of these terms.</Function>
    <Function Name="GROUPING_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions080.htm">GROUPING_ID returns a number corresponding to the GROUPING bit vector associated with a row. GROUPING_ID is applicable only in a SELECT statement that contains a GROUP BY extension, such as ROLLUP or CUBE, and a GROUPING function. In queries with many GROUP BY expressions, determining the GROUP BY level of a particular row requires many GROUPING functions, which leads to cumbersome SQL. GROUPING_ID is useful in these cases.
GROUPING_ID is functionally equivalent to taking the results of multiple GROUPING functions and concatenating them into a bit vector (a string of ones and zeros). By using GROUPING_ID you can avoid the need for multiple GROUPING functions and make row filtering conditions easier to express. Row filtering is easier with GROUPING_ID because the desired rows can be identified with a single condition of GROUPING_ID = n. The function is especially useful when storing multiple levels of aggregation in a single table.</Function>
    <Function Name="HEXTORAW" Url="http://docs.oracle.com/database/121/SQLRF/functions081.htm">HEXTORAW converts char containing hexadecimal digits in the CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to a raw value.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="INITCAP" Url="http://docs.oracle.com/database/121/SQLRF/functions082.htm">INITCAP returns char, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric.
char can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The return value is the same data type as char. The database sets the case of the initial characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase and lowercase, refer to NLS_INITCAP.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="INSERTCHILDXML" Url="http://docs.oracle.com/database/121/SQLRF/functions083.htm">INSERTCHILDXML inserts a user-supplied value into the target XML at the node indicated by the XPath expression. Compare this function with INSERTXMLBEFORE.

XMLType_instance is an instance of XMLType.

XPath_string is an Xpath expression indicating one or more nodes into which the one or more child nodes are to be inserted. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node.

child_expr specifies the one or more element or attribute nodes to be inserted.

value_expr is an fragment of XMLType that specifies one or more notes being inserted. It must resolve to a string.

The optional namespace_string provides namespace information for the XPath_string. This parameter must be of type VARCHAR2.</Function>
    <Function Name="INSERTXMLAFTER" Url="http://docs.oracle.com/database/121/SQLRF/functions086.htm">INSERTXMLAFTER inserts one or more nodes of any kind immediately after a target node that is not an attribute node. The XML document that is the target of the insertion can be schema-based or non-schema-based. This function is similar to insertXMLbefore, but it inserts after, not before, the target node.

XMLType_instance specifies the target node of the of the insertion.

XPath_string is an XPath 1.0 expression that locates in the target node zero or more nodes of any kind except attribute nodes. XML-data is inserted immediately after each of these nodes; that is, each node specified becomes the preceding sibling node of a node specified in value_expr.

value_expr is the XML data to be inserted. You can specify one or more nodes of any kind. The order of the nodes is preserved after the insertion.

The optional namespace_string is the namespace for the target node.</Function>
    <Function Name="INSERTXMLBEFORE" Url="http://docs.oracle.com/database/121/SQLRF/functions087.htm">INSERTXMLBEFORE inserts a user-supplied value into the target XML before the node indicated by the XPath expression. This function is similar to INSERTXMLAFTER, but it inserts before, not after, the target node. Compare this function with INSERTCHILDXML.

XMLType_instance is an instance of XMLType.

XPath_string is an Xpath expression indicating one or more nodes into which one or more child nodes are to be inserted. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node.

value_expr is a fragment of XMLType that defines one or more nodes being inserted and their position within the parent node. It must resolve to a string.

The optional namespace_string provides namespace information for the XPath_string. This parameter must be of type VARCHAR2.</Function>
    <Function Name="INSERTXMLCHILDAFTER" Url="http://docs.oracle.com/database/121/SQLRF/functions084.htm">INSERTXMLCHILDAFTER inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately after a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based.

XMLType_instance identifies the XML data that is the target of the insertion.

XPath_string locates the parent elements within target-data; child-data is inserted under each parent element.

child_expr is a relative XPath 1.0 expression that locates the existing child that will precede the inserted child-data. It must name a child element of the element indicated by parent-xpath, and it can include a predicate.

value_expr is the XMLType child element data to insert. Each top-level element node in this argument must have the same data type as the element indicated by child_expr.

The optional namespace_string specifies the namespace for the parent elements, existing child element, and child element XML data to be inserted.</Function>
    <Function Name="INSERTXMLCHILDBEFORE" Url="http://docs.oracle.com/database/121/SQLRF/functions085.htm">INSERTXMLCHILDBEFORE inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately before a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based.

XMLType_instance identifies the XML data that is the target of the insertion.

XPath_string locates the parent elements within target-data; child-data is inserted under each parent element.

child_expr is a relative XPath 1.0 expression that locates the existing child that will follow the inserted child-data. It must name a child element of the element indicated by parent-xpath, and it can include a predicate.

value_expr is the XMLType child element data to insert. Each top-level element node in this argument must have the same data type as the element indicated by child_expr.

The optional namespace_string specifies the namespace for the parent elements, existing child element, and child element XML data to be inserted.</Function>
    <Function Name="INSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions088.htm">The INSTR functions search string for substring. The search operation is defined as comparing the substring argument with substrings of string of the same length for equality until a match is found or there are no more substrings left. Each consecutive compared substring of string begins one character to the right (for forward searches) or one character to the left (for backward searches) from the first character of the previous compared substring. If a substring that is equal to substring is found, then the function returns an integer indicating the position of the first character of this substring. If no such substring is found, then the function returns zero.

position is an nonzero integer indicating the character of string where Oracle Database begins the search—that is, the position of the first character of the first substring to compare with substring. If position is negative, then Oracle counts backward from the end of string and then searches backward from the resulting position.

occurrence is an integer indicating which occurrence of substring in string Oracle should search for. The value of occurrence must be positive. If occurrence is greater than 1, then the database does not return on the first match but continues comparing consecutive substrings of string, as described above, until match number occurrence has been found.

INSTR accepts and returns positions in characters as defined by the input character set, with the first character of string having position 1. INSTRB uses bytes instead of characters. INSTRC uses Unicode complete characters. INSTR2 uses UCS2 code points. INSTR4 uses UCS4 code points.
string can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The exceptions are INSTRC, INSTR2, and INSTR4, which do not allow string to be a CLOB or NCLOB.
substring can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.
The value returned is of NUMBER data type.
Both position and occurrence must be of data type NUMBER, or any data type that can be implicitly converted to NUMBER, and must resolve to an integer. The default values of both position and occurrence are 1, meaning Oracle begins searching at the first character of string for the first occurrence of substring. The return value is relative to the beginning of string, regardless of the value of position.</Function>
    <Function Name="ITERATION_NUMBER" Url="http://docs.oracle.com/database/121/SQLRF/functions089.htm">The ITERATION_NUMBER function can be used only in the model_clause of the SELECT statement and then only when ITERATE(number) is specified in the model_rules_clause. It returns an integer representing the completed iteration through the model rules. The ITERATION_NUMBER function returns 0 during the first iteration. For each subsequent iteration, the ITERATION_NUMBER function returns the equivalent of iteration_number plus one.</Function>
    <Function Name="JSON_QUERY" Url="http://docs.oracle.com/database/121/SQLRF/functions090.htm">JSON_QUERY finds one or more specified JSON values in JSON data and returns the values in a character string.

expr
Use this clause to specify the JSON data to be evaluated. For expr, specify an expression that evaluates to a text literal. If expr is a column, then the column must be of data type VARCHAR2, CLOB, or BLOB. If expr is null, then the function returns null.
If expr is not a text literal of well-formed JSON data using strict or lax syntax, then the function returns null by default. You can use the JSON_query_on_error_clause to override this default behavior. Refer to JSON_query_on_error_clause.

FORMAT JSON
You must specify FORMAT JSON if expr is a column of data type BLOB.


JSON_path_expression
Use this clause to specify a JSON path expression. The function uses the path expression to evaluate expr and find one or more JSON values that match, or satisfy, the path expression. The path expression must be a text literal.
The path expression must begin with a dollar sign ($), which represents the context item, that is, the expression specified by expr. The dollar sign is followed by zero or more steps, each of which can be an object step or an array step.
The function attempts to match the first step in the path expression to the context item. If the first step results in a match, then the function attempts to match the second step to the JSON value(s) that matched the first step. If the second step results in a match, then the function attempts to match the third step to the JSON values(s) that matched the second step, and so on. The function returns the value(s) matched in the final step as a comma-separated sequence of values in a character string. The order of the sequence is nondeterministic. All values are returned using strict JSON syntax, regardless of whether the original JSON data used strict or lax JSON syntax. A path expression that consists of a dollar sign followed by zero steps ('$') matches the entire context item.
You can specify the JSON_query_returning_clause to control the data type and format of the return character string. Refer to the JSON_query_returning_clause.
If multiple values match the path expression, or if only one scalar value matches the path expression, then you must wrap the value(s) in an array wrapper. Refer to the JSON_query_wrapper_clause.
If any step in the path expression does not result in a match, then the function returns null by default. You can use the JSON_query_on_error_clause to override this default behavior. Refer to the JSON_query_on_error_clause.


object_step Use this clause to specify an object step.

Use simple_name or complex_name to specify a property name. If a member with that property name exists in the JSON object being evaluated, then the object step results in a match to the property value of that member. Otherwise, the object step does not result in a match. Both types of names are case-sensitive. Therefore, a match will result only if the alphabetic character cases match in the object step and the JSON data.
A simple_name can contain only alphanumeric characters and must begin with an alphabetic character. A complex_name can contain only alphanumeric characters and spaces, and must begin with an alphanumeric character. A complex_name must be enclosed in double quotation marks.

Use the asterisk wildcard symbol (*) to specify all property names. If the JSON object being evaluated contains at least one member, then the object step results in a match to the values of all members. Otherwise, the object step does not result in a match.

If you apply an object step to a JSON array, then the array is implicitly unwrapped and the elements of the array are evaluated using the object step. This is called JSON path expression relaxation. Refer to Oracle XML DB Developer's Guide for more information.
If the JSON data being evaluated is not a JSON object, then the object step does not result in a match.


array_step Use this clause to specify an array step.

Use integer to specify the element at index integer in a JSON array. Use integer TO integer to specify the range of elements between the two index integer values, inclusive. If the specified elements exist in the JSON array being evaluated, then the array step results in a match to those elements. Otherwise, the array step does not result in a match. The first element in a JSON array had index 0.

Use the asterisk wildcard symbol (*) to specify all elements in a JSON array. If the JSON array being evaluated contains at least one element, then the array step results in a match to all elements in the JSON array. Otherwise, the array step does not result in a match.

If the JSON data being evaluated is not a JSON array, then the data is implicitly wrapped in an array and then evaluated using the array step. This is called JSON path expression relaxation. Refer to Oracle XML DB Developer's Guide for more information.


JSON_query_returning_clause
Use this clause to specify the data type and format of the character string returned by this function.

RETURNING Use the RETURNING clause to specify the data type of the character string. If you omit this clause, then JSON_QUERY returns a character string of type VARCHAR2(4000).
You can use the JSON_return_type_clause to specify the following data type:

VARCHAR2[(size [BYTE,CHAR])]
When specifying the VARCHAR2 data type elsewhere in SQL, you are required to specify a size. However, in this clause you can omit the size. In this case, JSON_QUERY returns a character string of type VARCHAR2(4000).
Refer to "VARCHAR2 Data Type" for more information.

If the data type is not large enough to hold the return character string, then this function returns null by default. You can use the JSON_query_on_error_clause to override this default behavior. Refer to the JSON_query_on_error_clause.

PRETTY Specify PRETTY to pretty-print the return character string by inserting newline characters and indenting.

ASCII Specify ASCII to automatically escape any non-ASCII Unicode characters in the return character string, using standard ASCII Unicode escape sequences.


JSON_query_wrapper_clause
Use this clause to control whether this function wraps the values matched by the path expression in an array wrapper—that is, encloses the sequence of values in square brackets ([]).

Specify WITHOUT WRAPPER to omit the array wrapper. You can specify this clause only if the path expression matches a single JSON object or JSON array. This is the default.

Specify WITH WRAPPER to include the array wrapper. You must specify this clause if the path expression matches a single scalar value (a value that is not a JSON object or JSON array) or multiple values of any type.

Specifying the WITH UNCONDITIONAL WRAPPER clause is equivalent to specifying the WITH WRAPPER clause. The UNCONDITIONAL keyword is provided for semantic clarity.

Specify WITH CONDITIONAL WRAPPER to include the array wrapper only if the path expression matches a single scalar value or multiple values of any type. If the path expression matches a single JSON object or JSON array, then the array wrapper is omitted.

The ARRAY keyword is optional and is provided for semantic clarity.
If the function returns a single scalar value, or multiple values of any type, and you do not specify WITH [UNCONDITIONAL | CONDITIONAL] WRAPPER, then the function returns null by default. You can use the JSON_query_on_error_clause to override this default behavior. Refer to the JSON_query_on_error_clause.


JSON_query_on_error_clause
Use this clause to specify the value returned by this function when the following errors occur:

expr is not well-formed JSON data using strict or lax JSON syntax

No match is found when the JSON data is evaluated using the JSON path expression

The return value data type is not large enough to hold the return character string

The function matches a single scalar value or, multiple values of any type, and the WITH [UNCONDITIONAL | CONDITIONAL] WRAPPER clause is not specified

You can specify the following clauses:

NULL ON ERROR - Returns null when an error occurs. This is the default.

ERROR ON ERROR - Returns the appropriate Oracle error when an error occurs.

EMPTY ON ERROR - Returns an empty JSON array ('[]') when an error occurs.</Function>
    <Function Name="JSON_TABLE" Url="http://docs.oracle.com/database/121/SQLRF/functions091.htm">JSON_TABLE creates a relational view of JSON data. It maps the result of a JSON data evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL. The main purpose of JSON_TABLE is to create a row of relational data for each object inside a JSON array and output JSON values from within that object as individual SQL column values.
You must specify JSON_TABLE only in the FROM clause of a SELECT statement. The function first applies a JSON path expression, called a row path expression, to the supplied JSON data. The JSON value that matches the row path expression is called a row source in that it generates a row of relational data. The COLUMNS clause evaluates the row source, finds specific JSON values within the row source, and returns those JSON values as SQL values in individual columns of a row of relational data.
The COLUMNS clause enables you to search for JSON values in different ways by using the following clauses:

JSON_exists_column - Evaluates JSON data in the same manner as the JSON_EXISTS condition, that is, determines if a specified JSON value exists, and returns either a VARCHAR2 column of values 'true' or 'false', or a NUMBER column of values 1 or 0.

JSON_query_column - Evaluates JSON data in the same manner as the JSON_QUERY function, that is, finds one or more specified JSON values, and returns a column of character strings that contain those JSON values.

JSON_value_column - Evaluates JSON data in the same manner as the JSON_VALUE function, that is, finds a specified scalar JSON value, and returns a column of those JSON values as SQL values.

JSON_nested_path - Allows you to flatten JSON values in a nested JSON object or JSON array into individual columns in a single row along with JSON values from the parent object or array. You can use this clause recursively to project data from multiple layers of nested objects or arrays into a single row.

ordinality_column - Returns a column of generated row numbers.

The column definition clauses allow you to specify a name for each column of data that they return. You can reference these column names elsewhere in the SELECT statement, such as in the SELECT list and the WHERE clause.

expr
Use this clause to specify the JSON data to be evaluated. For expr, specify an expression that evaluates to a text literal. If expr is a column, then the column must be of data type VARCHAR2, CLOB, or BLOB. If expr is null, then the function returns null.
If expr is not a text literal of well-formed JSON data using strict or lax syntax, then the function returns null by default. You can use the JSON_table_on_error_clause to override this default behavior. Refer to JSON_table_on_error_clause.

FORMAT JSON
You must specify FORMAT JSON if expr is a column of data type BLOB.

JSON_path_expression
Use this clause to specify the row path expression. The function uses the row path expression to evaluate expr and find the a JSON value, called the row source, that matches, or satisfy, the path expression. This row source is then evaluated by the COLUMNS clause. The path expression must be a text literal.
The JSON_path_expression clause has the same semantics for JSON_TABLE and JSON_QUERY. For the full semantics of this clause, refer to JSON_path_expression in the documentation on JSON_QUERY.


JSON_table_on_error_clause
Use this clause to specify the value returned by this function when the following errors occur:

expr is not well-formed JSON data using strict or lax JSON syntax

No match is found when the JSON data is evaluated using the row path expression

You can specify the following clauses:

NULL ON ERROR - Returns null when an error occurs. This is the default.

ERROR ON ERROR - Returns the appropriate Oracle error when an error occurs.

DEFAULT literal ON ERROR - Returns literal when an error occurs. If the data type of the value returned by this function is VARCHAR2, then you must specify a text literal. If the data type is NUMBER, then you must specify a numeric literal.



JSON_columns_clause
Use the COLUMNS clause to define the columns in the virtual relational table returned by the JSON_TABLE function.


JSON_exists_column This clause evaluates JSON data in the same manner as the JSON_EXISTS condition, that is, it determines if a specified JSON value exists. It returns either a VARCHAR2 column of values 'true' or 'false', or a NUMBER column of values 1 or 0. A value of 'true' or 1 indicates that the JSON value exists and a value of 'false' or 0 indicates that the JSON value does not exist.
You can use the JSON_value_return_type clause to control the data type of the returned column. If you omit this clause, then the data type is VARCHAR2(4000). Use column_name to specify the name of the returned column. The rest of the clauses of JSON_exists_column have the same semantics here as they have for the JSON_EXISTS condition. For full information on these clauses, refer to "JSON_EXISTS Condition". Also see "Using JSON_exists_column: Examples" for an example.


JSON_query_column This clause evaluates JSON data in the same manner as the JSON_QUERY function, that is, it finds one or more specified JSON values, and returns a column of character strings that contain those JSON values.
Use column_name to specify the name of the returned column. The rest of the clauses of JSON_query_column have the same semantics here as they have for the JSON_QUERY function. For full information on these clauses, refer to JSON_QUERY. Also see "Using JSON_query_column: Example" for an example.


JSON_value_column This clause evaluates JSON data in the same manner as the JSON_VALUE function, that is, it finds a specified scalar JSON value, and returns a column of those JSON values as SQL values.
Use column_name to specify the name of the returned column. The rest of the clauses of JSON_value_column have the same semantics here as they have for the JSON_VALUE function. For full information on these clauses, refer to JSON_VALUE. Also see "Using JSON_value_column: Example" for an example.


nested_path_column Use this clause to flatten JSON values in a nested JSON object or JSON array into individual columns in a single row along with JSON values from the parent object or array. You can use this clause recursively to project data from multiple layers of nested objects or arrays into a single row.
Specify the JSON_path_expression clause to match the nested object or array. This path expression is relative to the row path expression specified in the JSON_TABLE function.
Use the COLUMNS clause to define the columns of the nested object or array to be returned. This clause is recursive—you can specify the nested_path_column clause within another nested_path_column clause. Also see "Using nested_path_column: Examples" for an example.


ordinality_column This clause returns a column of generated row numbers of data type NUMBER. You can specify at most one ordinality_column. Also see "Using JSON_value_column: Example" for an example of using the ordinality_column clause.</Function>
    <Function Name="JSON_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions092.htm">JSON_VALUE finds a specified scalar JSON value in JSON data and returns it as a SQL value.

expr
Use this clause to specify the JSON data to be evaluated. For expr, specify an expression that evaluates to a text literal. If expr is a column, then the column must be of data type VARCHAR2, CLOB, or BLOB. If expr is null, then the function returns null.
If expr is not a text literal of well-formed JSON data using strict or lax syntax, then the function returns null by default. You can use the JSON_value_on_error_clause to override this default behavior. Refer to the JSON_value_on_error_clause.

FORMAT JSON
You must specify FORMAT JSON if expr is a column of data type BLOB.


JSON_path_expression
Use this clause to specify a JSON path expression. The function uses the path expression to evaluate expr and find a scalar JSON value that matches, or satisfies, the path expression. The path expression must be a text literal.
The path expression must begin with a dollar sign ($), which represents the context item, that is, the expression specified by expr. The dollar sign is followed by zero or more steps, each of which can be an object step or an array step.
The function attempts to match the first step in the path expression to the context item. If the first step results in a match, then the function attempts to match the second step to the JSON value(s) that matched the first step. If the second step results in a match, then the function attempts to match the third step to the JSON value(s) that matched the second step, and so on. If the final step matches a scalar JSON value, then the function returns that value as a SQL value. A path expression that consists of a dollar sign followed by zero steps ('$') matches the entire context item.
You can specify the JSON_value_returning_clause to control the data type and format of the returned SQL value. Refer to the JSON_value_returning_clause.
If any step in the path expression does not result in a match, or if the final step matches a nonscalar value, then the function returns null by default. You can use the JSON_value_on_error_clause to override this default behavior. Refer to the JSON_value_on_error_clause.


object_step Use this clause to specify an object step.

Use simple_name or complex_name to specify a property name. If a member with that property name exists in the JSON object being evaluated, then the object step results in a match to the property value of that member. Otherwise, the object step does not result in a match. Both types of names are case-sensitive. Therefore, a match will result only if the alphabetic character cases match in the object step and the JSON data.
A simple_name can contain only alphanumeric characters and must begin with an alphabetic character. A complex_name can contain only alphanumeric characters and spaces, and must begin with an alphanumeric character. A complex_name must be enclosed in double quotation marks.

Use the asterisk wildcard symbol (*) to specify all property names. If the JSON object being evaluated contains at least one member, then the object step results in a match to the values of all members. Otherwise, the object step does not result in a match.

If you apply an object step to a JSON array, then the array is implicitly unwrapped and the elements of the array are evaluated using the object step. This is called JSON path expression relaxation. Refer to Oracle XML DB Developer's Guide for more information.
If the JSON value being evaluated is not a JSON object, then the object step does not result in a match.


array_step Use this clause to specify an array step.

Use integer to specify the element at index integer in a JSON array. Use integer TO integer to specify the range of elements between the two index integer values, inclusive. If the specified elements exist in the JSON array being evaluated, then the array step results in a match to those elements. Otherwise, the array step does not result in a match. The first element in a JSON array has index 0.

Use the asterisk wildcard symbol (*) to specify all elements in a JSON array. If the JSON array being evaluated contains at least one element, then the array step results in a match to all elements in the JSON array. Otherwise, the array step does not result in a match.

If the JSON data being evaluated is not a JSON array, then the data is implicitly wrapped in an array and then evaluated using the array step. This is called JSON path expression relaxation. Refer to Oracle XML DB Developer's Guide for more information.


JSON_value_returning_clause
Use this clause to specify the data type and format of the value returned by this function.

RETURNING Use the RETURNING clause to specify the data type of the return value. If you omit this clause, then JSON_VALUE returns a value of type VARCHAR2(4000).
You can use JSON_value_return_type to specify the following data types:

VARCHAR2[(size [BYTE,CHAR])]
If you specify this data type, then the scalar value returned by this function can be a character or number value. A number value will be implicitly converted to a VARCHAR2. When specifying the VARCHAR2 data type elsewhere in SQL, you are required to specify a size. However, in this clause you can omit the size. In this case, JSON_VALUE returns a value of type VARCHAR2(4000).
Refer to "VARCHAR2 Data Type" for more information.

NUMBER[(precision [, scale])]
If you specify this data type, then the scalar value returned by this function must be a number value.
Refer to "NUMBER Data Type" for more information.

If the data type is not large enough to hold the return value, then this function returns null by default. You can use the JSON_value_on_error_clause to override this default behavior. Refer to the JSON_value_on_error_clause.

ASCII Specify ASCII to automatically escape any non-ASCII Unicode characters in the return value, using standard ASCII Unicode escape sequences.


JSON_value_on_error_clause
Use this clause to specify the value returned by this function when the following errors occur:

expr is not well-formed JSON data using strict or lax JSON syntax

A nonscalar value or no match is found when the JSON data is evaluated using the JSON path expression

The return value data type is not large enough to hold the return value

You can specify the following clauses:

NULL ON ERROR - Returns null when an error occurs. This is the default.

ERROR ON ERROR - Returns the appropriate Oracle error when an error occurs.

DEFAULT literal ON ERROR - Returns literal when an error occurs. If the data type of the value returned by this function is VARCHAR2, then you must specify a text literal. If the data type is NUMBER, then you must specify a numeric literal.</Function>
    <Function Name="LAG" Url="http://docs.oracle.com/database/121/SQLRF/functions093.htm">LAG is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, LAG provides access to a row at a given physical offset prior to that position.
For the optional offset argument, specify an integer that is greater than zero. If you do not specify offset, then its default is 1. The optional default value is returned if the offset goes beyond the scope of the window. If you do not specify default, then its default is null.
{RESPECT | IGNORE} NULLS determines whether null values of value_expr are included in or eliminated from the calculation. The default is RESPECT NULLS.
You cannot nest analytic functions by using LAG or any other analytic function for value_expr. However, you can use other built-in function expressions for value_expr.</Function>
    <Function Name="LAST_DAY" Url="http://docs.oracle.com/database/121/SQLRF/functions095.htm">LAST_DAY returns the date of the last day of the month that contains date. The last day of the month is defined by the session parameter NLS_CALENDAR. The return type is always DATE, regardless of the data type of date.</Function>
    <Function Name="LAST_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions096.htm">LAST_VALUE is an analytic function that is useful for data densification. It returns the last value in an ordered set of values.</Function>
    <Function Name="LEAD" Url="http://docs.oracle.com/database/121/SQLRF/functions097.htm">LEAD is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, LEAD provides access to a row at a given physical offset beyond that position.
If you do not specify offset, then its default is 1. The optional default value is returned if the offset goes beyond the scope of the table. If you do not specify default, then its default value is null.
{RESPECT | IGNORE} NULLS determines whether null values of value_expr are included in or eliminated from the calculation. The default is RESPECT NULLS.
You cannot nest analytic functions by using LEAD or any other analytic function for value_expr. However, you can use other built-in function expressions for value_expr.</Function>
    <Function Name="LEAST" Url="http://docs.oracle.com/database/121/SQLRF/functions098.htm">LEAST returns the least of a list of one or more expressions. Oracle Database uses the first expr to determine the return type. If the first expr is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first expr is not numeric, then each expr after the first is implicitly converted to the data type of the first expr before the comparison.
Oracle Database compares each expr using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the NLS_COMP parameter is set to LINGUISTIC and the NLS_SORT parameter has a setting other than BINARY. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is VARCHAR2 if the first expr is a character data type and NVARCHAR2 if the first expr is a national character data type.</Function>
    <Function Name="LENGTH" Url="http://docs.oracle.com/database/121/SQLRF/functions099.htm">The LENGTH functions return the length of char. LENGTH calculates length using characters as defined by the input character set. LENGTHB uses bytes instead of characters. LENGTHC uses Unicode complete characters. LENGTH2 uses UCS2 code points. LENGTH4 uses UCS4 code points.
char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The exceptions are LENGTHC, LENGTH2, and LENGTH4, which do not allow char to be a CLOB or NCLOB. The return value is of data type NUMBER. If char has data type CHAR, then the length includes all trailing blanks. If char is null, then this function returns null.

Restriction on LENGTHB The LENGTHB function is supported for single-byte LOBs only. It cannot be used with CLOB and NCLOB data in a multibyte character set.</Function>
    <Function Name="LISTAGG" Url="http://docs.oracle.com/database/121/SQLRF/functions100.htm">For a specified measure, LISTAGG orders data within each group specified in the ORDER BY clause and then concatenates the values of the measure column.

As a single-set aggregate function, LISTAGG operates on all rows and returns a single output row.

As a group-set aggregate, the function operates on and returns an output row for each group defined by the GROUP BY clause.

As an analytic function, LISTAGG partitions the query result set into groups based on one or more expression in the query_partition_clause.

The arguments to the function are subject to the following rules:

The measure_expr can be any expression. Null values in the measure column are ignored.

The delimiter_expr designates the string that is to separate the measure values. This clause is optional and defaults to NULL.

The order_by_clause determines the order in which the concatenated values are returned. The function is deterministic only if the ORDER BY column list achieved unique ordering.

The return data type is RAW if the measure column is RAW; otherwise the return value is VARCHAR2.</Function>
    <Function Name="LN" Url="http://docs.oracle.com/database/121/SQLRF/functions101.htm">LN returns the natural logarithm of n, where n is greater than 0.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="LNNVL" Url="http://docs.oracle.com/database/121/SQLRF/functions102.htm">LNNVL provides a concise way to evaluate a condition when one or both operands of the condition may be null. The function can be used in the WHERE clause of a query, or as the WHEN condition in a searched CASE expression. It takes as an argument a condition and returns TRUE if the condition is FALSE or UNKNOWN and FALSE if the condition is TRUE. LNNVL can be used anywhere a scalar expression can appear, even in contexts where the IS [NOT] NULL, AND, or OR conditions are not valid but would otherwise be required to account for potential nulls.
Oracle Database sometimes uses the LNNVL function internally in this way to rewrite NOT IN conditions as NOT EXISTS conditions. In such cases, output from EXPLAIN PLAN shows this operation in the plan table output. The condition can evaluate any scalar values but cannot be a compound condition containing AND, OR, or BETWEEN.
The table that follows shows what LNNVL returns given that a = 2 and b is null.</Function>
    <Function Name="LOCALTIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions103.htm">LOCALTIMESTAMP returns the current date and time in the session time zone in a value of data type TIMESTAMP. The difference between this function and CURRENT_TIMESTAMP is that LOCALTIMESTAMP returns a TIMESTAMP value while CURRENT_TIMESTAMP returns a TIMESTAMP WITH TIME ZONE value.
The optional argument timestamp_precision specifies the fractional second precision of the time value returned.</Function>
    <Function Name="LOG" Url="http://docs.oracle.com/database/121/SQLRF/functions104.htm">LOG returns the logarithm, base n2, of n1. The base n2 can be any positive value other than 0 or 1 and n1 can be any positive value.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is BINARY_FLOAT or BINARY_DOUBLE, then the function returns BINARY_DOUBLE. Otherwise the function returns NUMBER.</Function>
    <Function Name="LOWER" Url="http://docs.oracle.com/database/121/SQLRF/functions105.htm">LOWER returns char, with all letters lowercase. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The return value is the same data type as char. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive lowercase, refer to NLS_LOWER.</Function>
    <Function Name="LPAD" Url="http://docs.oracle.com/database/121/SQLRF/functions106.htm">LPAD returns expr1, left-padded to length n characters with the sequence of characters in expr2. This function is useful for formatting the output of a query.
Both expr1 and expr2 can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if expr1 is a character data type, NVARCHAR2 if expr1 is a national character data type, and a LOB if expr1 is a LOB data type. The string returned is in the same character set as expr1. The argument n must be a NUMBER integer or a value that can be implicitly converted to a NUMBER integer.
If you do not specify expr2, then the default is a single blank. If expr1 is longer than n, then this function returns the portion of expr1 that fits in n.
The argument n is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string.</Function>
    <Function Name="LTRIM" Url="http://docs.oracle.com/database/121/SQLRF/functions107.htm">LTRIM removes from the left end of char all of the characters contained in set. If you do not specify set, then it defaults to a single blank. If char is a character literal, then you must enclose it in single quotation marks. Oracle Database begins scanning char from its first character and removes all characters that appear in set until reaching a character not in set and then returns the result.
Both char and set can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type, NVARCHAR2 if char is a national character data type, and a LOB if char is a LOB data type.</Function>
    <Function Name="MAKE_REF" Url="http://docs.oracle.com/database/121/SQLRF/functions108.htm">MAKE_REF creates a REF to a row of an object view or a row in an object table whose object identifier is primary key based. This function is useful, for example, if you are creating an object view</Function>
    <Function Name="MAX" Url="http://docs.oracle.com/database/121/SQLRF/functions109.htm">MAX returns maximum value of expr. You can use it as an aggregate or analytic function.</Function>
    <Function Name="MEDIAN" Url="http://docs.oracle.com/database/121/SQLRF/functions110.htm">MEDIAN is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you specify only expr, then the function returns the same data type as the numeric data type of the argument. If you specify the OVER clause, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="MIN" Url="http://docs.oracle.com/database/121/SQLRF/functions111.htm">MIN returns minimum value of expr. You can use it as an aggregate or analytic function.</Function>
    <Function Name="MOD" Url="http://docs.oracle.com/database/121/SQLRF/functions112.htm">MOD returns the remainder of n2 divided by n1. Returns n2 if n1 is 0.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="MONTHS_BETWEEN" Url="http://docs.oracle.com/database/121/SQLRF/functions113.htm">MONTHS_BETWEEN returns number of months between dates date1 and date2. The month and the last day of the month are defined by the parameter NLS_CALENDAR. If date1 is later than date2, then the result is positive. If date1 is earlier than date2, then the result is negative. If date1 and date2 are either the same days of the month or both last days of months, then the result is always an integer. Otherwise Oracle Database calculates the fractional portion of the result based on a 31-day month and considers the difference in time components date1 and date2.</Function>
    <Function Name="NANVL" Url="http://docs.oracle.com/database/121/SQLRF/functions114.htm">The NANVL function is useful only for floating-point numbers of type BINARY_FLOAT or BINARY_DOUBLE. It instructs Oracle Database to return an alternative value n1 if the input value n2 is NaN (not a number). If n2 is not NaN, then Oracle returns n2.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</Function>
    <Function Name="NCHR" Url="http://docs.oracle.com/database/121/SQLRF/functions115.htm">NCHR returns the character having the binary equivalent to number in the national character set. The value returned is always NVARCHAR2. This function is equivalent to using the CHR function with the USING NCHAR_CS clause.
This function takes as an argument a NUMBER value, or any value that can be implicitly converted to NUMBER, and returns a character.</Function>
    <Function Name="NEW_TIME" Url="http://docs.oracle.com/database/121/SQLRF/functions116.htm">NEW_TIME returns the date and time in time zone timezone2 when date and time in time zone timezone1 are date. Before using this function, you must set the NLS_DATE_FORMAT parameter to display 24-hour time. The return type is always DATE, regardless of the data type of date.</Function>
    <Function Name="NEXT_DAY" Url="http://docs.oracle.com/database/121/SQLRF/functions117.htm">NEXT_DAY returns the date of the first weekday named by char that is later than the date date. The return type is always DATE, regardless of the data type of date. The argument char must be a day of the week in the date language of your session, either the full name or the abbreviation. The minimum number of letters required is the number of letters in the abbreviated version. Any characters immediately following the valid abbreviation are ignored. The return value has the same hours, minutes, and seconds component as the argument date.</Function>
    <Function Name="NLS_CHARSET_DECL_LEN" Url="http://docs.oracle.com/database/121/SQLRF/functions118.htm">NLS_CHARSET_DECL_LEN returns the declaration length (in number of characters) of an NCHAR column. The byte_count argument is the width of the column. The char_set_id argument is the character set ID of the column.</Function>
    <Function Name="NLS_CHARSET_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions119.htm">NLS_CHARSET_ID returns the character set ID number corresponding to character set name string. The string argument is a run-time VARCHAR2 value. The string value 'CHAR_CS' returns the database character set ID number of the server. The string value 'NCHAR_CS' returns the national character set ID number of the server.
Invalid character set names return null.</Function>
    <Function Name="NLS_CHARSET_NAME" Url="http://docs.oracle.com/database/121/SQLRF/functions120.htm">NLS_CHARSET_NAME returns the name of the character set corresponding to ID number number. The character set name is returned as a VARCHAR2 value in the database character set.
If number is not recognized as a valid character set ID, then this function returns null.</Function>
    <Function Name="NLS_INITCAP" Url="http://docs.oracle.com/database/121/SQLRF/functions121.htm">NLS_INITCAP returns char, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The string returned is of VARCHAR2 data type and is in the same character set as char.
The value of 'nlsparam' can have this form:

'NLS_SORT = sort'

where sort is either a linguistic sort sequence or BINARY. The linguistic sort sequence handles special linguistic requirements for case conversions. These requirements can result in a return value of a different length than the char. If you omit 'nlsparam', then this function uses the default sort sequence for your session.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="NLS_LOWER" Url="http://docs.oracle.com/database/121/SQLRF/functions122.htm">NLS_LOWER returns char, with all letters lowercase.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type and a LOB if char is a LOB data type. The return string is in the same character set as char.
The 'nlsparam' can have the same form and serve the same purpose as in the NLS_INITCAP function.</Function>
    <Function Name="NLS_UPPER" Url="http://docs.oracle.com/database/121/SQLRF/functions123.htm">NLS_UPPER returns char, with all letters uppercase.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type and a LOB if char is a LOB data type. The return string is in the same character set as char.
The 'nlsparam' can have the same form and serve the same purpose as in the NLS_INITCAP function.</Function>
    <Function Name="NLSSORT" Url="http://docs.oracle.com/database/121/SQLRF/functions124.htm">NLSSORT returns a collation key for the character value char and an explicitly or implicitly specified collation. A collation key is a string of bytes used to sort char according to the specified collation. The property of the collation keys is that mutual ordering of two such keys generated for the given collation when compared according to their binary order is the same as mutual ordering of the source character values when compared according to the given collation.
Both char and 'nlsparam' can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2.
The value of 'nlsparam' must have the form

'NLS_SORT = collation'

where collation is the name of a linguistic collation or BINARY. NLSSORT uses the specified collation to generate the collation key. If you omit 'nlsparam', then this function uses the default collation for your session, which is specified in the session parameter NLS_SORT. If you specify BINARY, then this function returns the char value itself cast to RAW and possibly truncated as described below.
If you specify 'nlsparam', then you can append to the linguistic collation name the suffix _ai to request an accent-insensitive collation or _ci to request a case-insensitive collation. Refer to Oracle Database Globalization Support Guide for more information on accent- and case-insensitive sorting. Using accent-insensitive or case-insensitive collations with the ORDER BY query clause is not recommended as it leads to a nondeterministic sort order.
The returned collation key is of RAW data type. The length of the collation key resulting from a given char value for a given collation may exceed the maximum length of the RAW value returned by NLSSORT. In this case, the behavior of NLSSORT depends on the value of the initialization parameter MAX_STRING_SIZE. If MAX_STRING_SIZE = EXTENDED, then the maximum length of the return value is 32767 bytes. If the collation key exceeds this limit, then the function fails with the error "ORA-12742: unable to create the collation key". This error may also be reported for short input strings if they contain a high percentage of Unicode characters with very high decomposition ratios.
If MAX_STRING_SIZE = STANDARD, then the maximum length of the return value is 2000 bytes. If the value to be returned exceeds the limit, then NLSSORT calculates the collation key for a maximum prefix, or initial substring, of char so that the calculated result does not exceed the maximum length. For monolingual collations, for example FRENCH, the prefix length is typically 1000 characters. For multilingual collations, for example GENERIC_M, the prefix is typically 500 characters. For Unicode Collation Algorithm (UCA) collations, for example UCA0610_DUCET, the prefix is typically 285 characters. The exact length may be lower or higher depending on the collation and the characters contained in char.
The behavior when MAX_STRING_SIZE = STANDARD implies that two character values whose collation keys (NLSSORT results) are compared to find the linguistic ordering are considered equal if they do not differ in the prefix even though they may differ at some further character position. Because the NLSSORT function is used implicitly to find linguistic ordering for comparison conditions, the BETWEEN condition, the IN condition, ORDER BY, GROUP BY, and COUNT(DISTINCT), those operations may return results that are only approximate for long character values. If you want guarantee that the results of those operations are exact, then migrate your database to use MAX_STRING_SIZE = EXTENDED.
Refer to "Extended Data Types" for more information on the MAX_STRING_SIZE initialization parameter.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="NTH_VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions125.htm">NTH_VALUE returns the measure_expr value of the nth row in the window defined by the analytic_clause. The returned value has the data type of the measure_expr.

{RESPECT | IGNORE} NULLS determines whether null values of measure_expr are included in or eliminated from the calculation. The default is RESPECT NULLS.

n determines the nth row for which the measure value is to be returned. n can be a constant, bind variable, column, or an expression involving them, as long as it resolves to a positive integer. The function returns NULL if the data source window has fewer than n rows. If n is null, then the function returns an error.

FROM {FIRST | LAST} determines whether the calculation begins at the first or last row of the window. The default is FROM FIRST.

If you omit the windowing_clause of the analytic_clause, it defaults to RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. This default sometimes returns an unexpected value for NTH_VALUE ... FROM LAST ... , because the last value in the window is at the bottom of the window, which is not fixed. It keeps changing as the current row changes. For expected results, specify the windowing_clause as RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING. Alternatively, you can specify the windowing_clause as RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING.</Function>
    <Function Name="NTILE" Url="http://docs.oracle.com/database/121/SQLRF/functions126.htm">NTILE is an analytic function. It divides an ordered data set into a number of buckets indicated by expr and assigns the appropriate bucket number to each row. The buckets are numbered 1 through expr. The expr value must resolve to a positive constant for each partition. Oracle Database expects an integer, and if expr is a noninteger constant, then Oracle truncates the value to an integer. The return value is NUMBER.
The number of rows in the buckets can differ by at most 1. The remainder values (the remainder of number of rows divided by buckets) are distributed one for each bucket, starting with bucket 1.
If expr is greater than the number of rows, then a number of buckets equal to the number of rows will be filled, and the remaining buckets will be empty.
You cannot nest analytic functions by using NTILE or any other analytic function for expr. However, you can use other built-in function expressions for expr.</Function>
    <Function Name="NULLIF" Url="http://docs.oracle.com/database/121/SQLRF/functions127.htm">NULLIF compares expr1 and expr2. If they are equal, then the function returns null. If they are not equal, then the function returns expr1. You cannot specify the literal NULL for expr1.
If both arguments are numeric data types, then Oracle Database determines the argument with the higher numeric precedence, implicitly converts the other argument to that data type, and returns that data type. If the arguments are not numeric, then they must be of the same data type, or Oracle returns an error.
The NULLIF function is logically equivalent to the following CASE expression:

CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END</Function>
    <Function Name="NUMTODSINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions128.htm">NUMTODSINTERVAL converts n to an INTERVAL DAY TO SECOND literal. The argument n can be any NUMBER value or an expression that can be implicitly converted to a NUMBER value. The argument interval_unit can be of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type. The value for interval_unit specifies the unit of n and must resolve to one of the following string values:

'DAY'

'HOUR'

'MINUTE'

'SECOND'

interval_unit is case insensitive. Leading and trailing values within the parentheses are ignored. By default, the precision of the return is 9.</Function>
    <Function Name="NUMTOYMINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions129.htm">NUMTOYMINTERVAL converts number n to an INTERVAL YEAR TO MONTH literal. The argument n can be any NUMBER value or an expression that can be implicitly converted to a NUMBER value. The argument interval_unit can be of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type. The value for interval_unit specifies the unit of n and must resolve to one of the following string values:

'YEAR'

'MONTH'

interval_unit is case insensitive. Leading and trailing values within the parentheses are ignored. By default, the precision of the return is 9.</Function>
    <Function Name="NVL" Url="http://docs.oracle.com/database/121/SQLRF/functions130.htm">NVL lets you replace null (returned as a blank) with a string in the results of a query. If expr1 is null, then NVL returns expr2. If expr1 is not null, then NVL returns expr1.
The arguments expr1 and expr2 can have any data type. If their data types are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. The implicit conversion is implemented as follows:

If expr1 is character data, then Oracle Database converts expr2 to the data type of expr1 before comparing them and returns VARCHAR2 in the character set of expr1.

If expr1 is numeric, then Oracle Database determines which argument has the highest numeric precedence, implicitly converts the other argument to that data type, and returns that data type.


See Also:

Table 2-10, "Implicit Type Conversion Matrix" for more information on implicit conversion and "Numeric Precedence" for information on numeric precedence

"COALESCE" and "CASE Expressions", which provide functionality similar to that of NVL</Function>
    <Function Name="NVL2" Url="http://docs.oracle.com/database/121/SQLRF/functions131.htm">NVL2 lets you determine the value returned by a query based on whether a specified expression is null or not null. If expr1 is not null, then NVL2 returns expr2. If expr1 is null, then NVL2 returns expr3.
The argument expr1 can have any data type. The arguments expr2 and expr3 can have any data types except LONG.
If the data types of expr2 and expr3 are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. If expr2 is character or numeric data, then the implicit conversion is implemented as follows:

If expr2 is character data, then Oracle Database converts expr3 to the data type of expr2 before returning a value unless expr3 is a null constant. In that case, a data type conversion is not necessary, and the database returns VARCHAR2 in the character set of expr2.

If expr2 is numeric data, then Oracle Database determines which argument has the highest numeric precedence, implicitly converts the other argument to that data type, and returns that data type.


See Also:
Table 2-10, "Implicit Type Conversion Matrix" for more information on implicit conversion and "Numeric Precedence" for information on numeric precedence</Function>
    <Function Name="ORA_DST_AFFECTED" Url="http://docs.oracle.com/database/121/SQLRF/functions132.htm">ORA_DST_AFFECTED is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values. The function returns 1 if the datetime value is affected by or will result in a "nonexisting time" or "duplicate time" error with the new time zone data. Otherwise, it returns 0.
This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the DBMS_DST.BEGIN_PREPARE and the DBMS_DST.END_PREPARE procedures or between the execution of the DBMS_DST.BEGIN_UPGRADE and the DBMS_DST.END_UPGRADE procedures.</Function>
    <Function Name="ORA_DST_CONVERT" Url="http://docs.oracle.com/database/121/SQLRF/functions133.htm">ORA_DST_CONVERT is useful when you are changing the time zone data file for your database. The function lets you specify error handling for a specified datetime expression.

For datetime_expr, specify a datetime expression that resolves to a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values.

The optional second argument specifies handling of "duplicate time" errors. Specify 0 (false) to suppress the error by returning the source datetime value. This is the default. Specify 1 (true) to allow the database to return the duplicate time error.

The optional third argument specifies handling of "nonexisting time" errors. Specify 0 (false) to suppress the error by returning the source datetime value. This is the default. Specify 1 (true) to allow the database to return the nonexisting time error.

If no error occurs, this function returns a value of the same data type as datetime_expr (a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values). The returned datetime value when interpreted with the new time zone file corresponds to datetime_expr interpreted with the old time zone file.
This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the DBMS_DST.BEGIN_UPGRADE and the DBMS_DST.END_UPGRADE procedures.</Function>
    <Function Name="ORA_DST_ERROR" Url="http://docs.oracle.com/database/121/SQLRF/functions134.htm">ORA_DST_ERROR is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a TIMESTAMP WITH TIME ZONE value or a VARRAY object that contains TIMESTAMP WITH TIME ZONE values, and indicates whether the datetime value will result in an error with the new time zone data. The return values are:

0: the datetime value does not result in an error with the new time zone data.

1878: the datetime value results in a "nonexisting time" error.

1883: the datetime value results in a "duplicate time" error.

This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the DBMS_DST.BEGIN_PREPARE and the DBMS_DST.END_PREPARE procedures or between the execution of the DBMS_DST.BEGIN_UPGRADE and the DBMS_DST.END_UPGRADE procedures.</Function>
    <Function Name="ORA_HASH" Url="http://docs.oracle.com/database/121/SQLRF/functions135.htm">ORA_HASH is a function that computes a hash value for a given expression. This function is useful for operations such as analyzing a subset of data and generating a random sample.

The expr argument determines the data for which you want Oracle Database to compute a hash value. There are no restrictions on the length of data represented by expr, which commonly resolves to a column name. The expr cannot be a LONG or LOB type. It cannot be a user-defined object type unless it is a nested table type. The hash value for nested table types does not depend on the order of elements in the collection. All other data types are supported for expr.

The optional max_bucket argument determines the maximum bucket value returned by the hash function. You can specify any value between 0 and 4294967295. The default is 4294967295.

The optional seed_value argument enables Oracle to produce many different results for the same set of data. Oracle applies the hash function to the combination of expr and seed_value. You can specify any value between 0 and 4294967295. The default is 0.

The function returns a NUMBER value.</Function>
    <Function Name="ORA_INVOKING_USER" Url="http://docs.oracle.com/database/121/SQLRF/functions136.htm">ORA_INVOKING_USER returns the name of the database user who invoked the current statement or view. This function takes into account the BEQUEATH property of intervening views referenced in the statement. If this function is invoked from within a definer's rights context, then it returns the name of the owner of the definer's rights object. If the invoking user is a Real Application Security user, then it returns user XS$NULL.
This function returns a VARCHAR2 value.</Function>
    <Function Name="ORA_INVOKING_USERID" Url="http://docs.oracle.com/database/121/SQLRF/functions137.htm">ORA_INVOKING_USERID returns the identifier of the database user who invoked the current statement or view. This function takes into account the BEQUEATH property of intervening views referenced in the statement.
This function returns a NUMBER value.</Function>
    <Function Name="PATH" Url="http://docs.oracle.com/database/121/SQLRF/functions138.htm">PATH is an ancillary function used only with the UNDER_PATH and EQUALS_PATH conditions. It returns the relative path that leads to the resource specified in the parent condition.
The correlation_integer can be any NUMBER integer and is used to correlate this ancillary function with its primary condition. Values less than 1 are treated as 1.</Function>
    <Function Name="PERCENT_RANK" Url="http://docs.oracle.com/database/121/SQLRF/functions139.htm">PERCENT_RANK is similar to the CUME_DIST (cumulative distribution) function. The range of values returned by PERCENT_RANK is 0 to 1, inclusive. The first row in any set has a PERCENT_RANK of 0. The return value is NUMBER.</Function>
    <Function Name="PERCENTILE_CONT" Url="http://docs.oracle.com/database/121/SQLRF/functions140.htm">PERCENTILE_CONT is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="PERCENTILE_DISC" Url="http://docs.oracle.com/database/121/SQLRF/functions141.htm">PERCENTILE_DISC is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="POWER" Url="http://docs.oracle.com/database/121/SQLRF/functions142.htm">POWER returns n2 raised to the n1 power. The base n2 and the exponent n1 can be any numbers, but if n2 is negative, then n1 must be an integer.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is BINARY_FLOAT or BINARY_DOUBLE, then the function returns BINARY_DOUBLE. Otherwise, the function returns NUMBER.</Function>
    <Function Name="POWERMULTISET" Url="http://docs.oracle.com/database/121/SQLRF/functions143.htm">POWERMULTISET takes as input a nested table and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the input nested table.

expr can be any expression that evaluates to a nested table.

If expr resolves to null, then Oracle Database returns NULL.

If expr resolves to a nested table that is empty, then Oracle returns an error.

The element types of the nested table must be comparable. Refer to "Comparison Conditions" for information on the comparability of nonscalar types.


Note:
This function is not supported in PL/SQL.</Function>
    <Function Name="POWERMULTISET_BY_CARDINALITY" Url="http://docs.oracle.com/database/121/SQLRF/functions144.htm">POWERMULTISET_BY_CARDINALITY takes as input a nested table and a cardinality and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the nested table of the specified cardinality.

expr can be any expression that evaluates to a nested table.

cardinality can be any positive integer.

If expr resolves to null, then Oracle Database returns NULL.

If expr resolves to a nested table that is empty, then Oracle returns an error.

The element types of the nested table must be comparable. Refer to "Comparison Conditions" for information on the comparability of nonscalar types.


Note:
This function is not supported in PL/SQL.</Function>
    <Function Name="PREDICTION" Url="http://docs.oracle.com/database/121/SQLRF/functions145.htm">PREDICTION returns a prediction for each row in the selection. The data type of the returned prediction depends on whether the function performs regression, classification, or anomaly detection.

Regression — Returns the expected target value for each row. The data type of the return value is the data type of the target.

Classification — Returns the most probable target class (or lowest cost target class, if costs are specified) for each row. The data type of the return value is the data type of the target.

Anomaly Detection — Returns 1 or 0 for each row. Typical rows are classified as 1. Rows that differ significantly from the rest of the data are classified as 0.


cost_matrix_clause
Costs are a biasing factor for minimizing the most harmful kinds of misclassifications. You can specify cost_matrix_clause for classification or anomaly detection. Costs are not relevant for regression. The cost_matrix_clause behaves as described for "PREDICTION_COST".

Syntax Choice
PREDICTION can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically score the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification, regression, or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause , which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For regression, specify FOR expr, where expr is an expression that identifies a target column that has a numeric data type.

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For anomaly detection, specify the keywords OF ANOMALY.




mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring.

If you specify USING *, all the relevant attributes present in the input row are used.

If you invoke the function with the analytic syntax, the mining_attribute_clause is used both for building the transient models and for scoring.

It you invoke the function with a pre-defined model, the mining_attribute_clause should include all or some of the attributes that were used to create the model. The following conditions apply:

If mining_attribute_clause includes an attribute with the same name but a different data type from the one that was used to create the model, then the data type is converted to the type expected by the model.

If you specify more attributes for scoring than were used to create the model, then the extra attributes are silently ignored.

If you specify fewer attributes for scoring than were used to create the model, then scoring is performed on a best-effort basis.</Function>
    <Function Name="PREDICTION_BOUNDS" Url="http://docs.oracle.com/database/121/SQLRF/functions146.htm">PREDICTION_BOUNDS applies a Generalized Linear Model (GLM) to predict a class or a value for each row in the selection. The function returns the upper and lower bounds of each prediction in a varray of objects with fields UPPER and LOWER.
GLM can perform either regression or binary classification:

The bounds for regression refer to the predicted target value. The data type of UPPER and LOWER is the data type of the target.

The bounds for binary classification refer to the probability of either the predicted target class or the specified class_value. The data type of UPPER and LOWER is BINARY_DOUBLE.

If the model was built using ridge regression, or if the covariance matrix is found to be singular during the build, then PREDICTION_BOUNDS returns NULL for both bounds.
confidence_level is a number in the range (0,1). The default value is 0.95. You can specify class_value while leaving confidence_level at its default by specifying NULL for confidence_level.

mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. This clause behaves as described for the PREDICTION function. (Note that the reference to analytic syntax does not apply.) See "mining_attribute_clause::=".</Function>
    <Function Name="PREDICTION_COST" Url="http://docs.oracle.com/database/121/SQLRF/functions147.htm">PREDICTION_COST returns a cost for each row in the selection. The cost refers to the lowest cost class or to the specified class. The cost is returned as BINARY_DOUBLE.
PREDICTION_COST can perform classification or anomaly detection. For classification, the returned cost refers to a predicted target class. For anomaly detection, the returned cost refers to a classification of 1 (for typical rows) or 0 (for anomalous rows).
You can use PREDICTION_COST in conjunction with the PREDICTION function to obtain the prediction and the cost of the prediction.


cost_matrix_clause
Costs are a biasing factor for minimizing the most harmful kinds of misclassifications. For example, false positives might be considered more costly than false negatives. Costs are specified in a cost matrix that can be associated with the model or defined inline in a VALUES clause. All classification algorithms can use costs to influence scoring.
Decision Tree is the only algorithm that can use costs to influence the model build. The cost matrix used to build a Decision Tree model is also the default scoring cost matrix for the model.
The following cost matrix table specifies that the misclassification of 1 is five times more costly than the misclassification of 0.

ACTUAL_TARGET_VALUE PREDICTED_TARGET_VALUE       COST
------------------- ---------------------- ----------
                  0                      0          0
                  0                      1          1
                  1                      0          5
                  1                      1          0

In cost_matrix_clause:

COST MODEL indicates that scoring should be performed by taking into account the scoring cost matrix associated with the model. If the cost matrix does not exist, then the function returns an error.

COST MODEL AUTO indicates that the existence of a cost matrix is unknown. If a cost matrix exists, then the function uses it to return the lowest cost prediction. Otherwise the function returns the highest probability prediction.

The VALUES clause specifies an inline cost matrix for class_value. For example, you could specify that the misclassification of 1 is five times more costly than the misclassification of 0 as follows:

   PREDICTION (nb_model COST (0,1) VALUES ((0, 1),(1, 5)) USING *)

If a model that has a scoring cost matrix is invoked with an inline cost matrix, then the inline costs are used.



See Also:
Oracle Data Mining User's Guide for more information about cost-sensitive prediction.




Syntax Choice
PREDICTION_COST can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause , which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For anomaly detection, specify the keywords OF ANOMALY.



mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="PREDICTION_DETAILS" Url="http://docs.oracle.com/database/121/SQLRF/functions148.htm">PREDICTION_DETAILS returns prediction details for each row in the selection. The return value is an XML string that describes the attributes of the prediction.
For regression, the returned details refer to the predicted target value. For classification and anomaly detection, the returned details refer to the highest probability class or the specified class_value.

topN
If you specify a value for topN, the function returns the N attributes that have the most influence on the prediction (the score). If you do not specify topN, the function returns the 5 most influential attributes.

DESC, ASC, or ABS
The returned attributes are ordered by weight. The weight of an attribute expresses its positive or negative impact on the prediction. For regression, a positive weight indicates a higher value prediction; a negative weight indicates a lower value prediction. For classification and anomaly detection, a positive weight indicates a higher probability prediction; a negative weight indicates a lower probability prediction.
By default, PREDICTION_DETAILS returns the attributes with the highest positive weight (DESC). If you specify ASC, the attributes with the highest negative weight are returned. If you specify ABS, the attributes with the greatest weight, whether negative or positive, are returned. The results are ordered by absolute value from highest to lowest. Attributes with a zero weight are not included in the output.

Syntax Choice
PREDICTION_DETAILS can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification, regression, or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For regression, specify FOR expr, where expr is an expression that identifies a target column that has a numeric data type.

For anomaly detection, specify the keywords OF ANOMALY.



mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="PREDICTION_PROBABILITY" Url="http://docs.oracle.com/database/121/SQLRF/functions149.htm">PREDICTION_PROBABILITY returns a probability for each row in the selection. The probability refers to the highest probability class or to the specified class. The data type of the returned probability is BINARY_DOUBLE.
PREDICTION_PROBABILITY can perform classification or anomaly detection. For classification, the returned probability refers to a predicted target class. For anomaly detection, the returned probability refers to a classification of 1 (for typical rows) or 0 (for anomalous rows).
You can use PREDICTION_PROBABILITY in conjunction with the PREDICTION function to obtain the prediction and the probability of the prediction.

Syntax Choice
PREDICTION_PROBABILITY can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For anomaly detection, specify the keywords OF ANOMALY.



mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="PREDICTION_SET" Url="http://docs.oracle.com/database/121/SQLRF/functions150.htm">PREDICTION_SET returns a set of predictions with either probabilities or costs for each row in the selection. The return value is a varray of objects with field names PREDICTION_ID and PROBABILITY or COST. The prediction identifier is an Oracle NUMBER; the probability and cost fields are BINARY_DOUBLE.
PREDICTION_SET can perform classification or anomaly detection. For classification, the return value refers to a predicted target class. For anomaly detection, the return value refers to a classification of 1 (for typical rows) or 0 (for anomalous rows).

bestN and cutoff
You can specify bestN and cutoff to limit the number of predictions returned by the function. By default, both bestN and cutoff are null and all predictions are returned.

bestN is the N predictions that are either the most probable or the least costly. If multiple predictions share the Nth probability or cost, then the function chooses one of them.

cutoff is a value threshold. Only predictions with probability greater than or equal to cutoff, or with cost less than or equal to cutoff, are returned. To filter by cutoff only, specify NULL for bestN. If the function uses a cost_matrix_clause with COST MODEL AUTO, then cutoff is ignored.

You can specify bestN with cutoff to return up to the N most probable predictions that are greater than or equal to cutoff. If costs are used, specify bestN with cutoff to return up to the N least costly predictions that are less than or equal to cutoff.

cost_matrix_clause
You can specify cost_matrix_clause as a biasing factor for minimizing the most harmful kinds of misclassifications. cost_matrix_clause behaves as described for "PREDICTION_COST".

Syntax Choice
PREDICTION_SET can score the data in one of two ways: It can apply a mining model object to the data, or it can dynamically mine the data by executing an analytic clause that builds and applies one or more transient mining models. Choose Syntax or Analytic Syntax:

Syntax — Use the first syntax to score the data with a pre-defined model. Supply the name of a model that performs classification or anomaly detection.

Analytic Syntax — Use the analytic syntax to score the data without a pre-defined model. The analytic syntax uses mining_analytic_clause, which specifies if the data should be partitioned for multiple model builds. The mining_analytic_clause supports a query_partition_clause and an order_by_clause. (See "analytic_clause::=".)

For classification, specify FOR expr, where expr is an expression that identifies a target column that has a character data type.

For anomaly detection, specify the keywords OF ANOMALY.



mining_attribute_clause
mining_attribute_clause identifies the column attributes to use as predictors for scoring. When the function is invoked with the analytic syntax, these predictors are also used for building the transient models. The mining_attribute_clause behaves as described for the PREDICTION function. (See "mining_attribute_clause::=".)</Function>
    <Function Name="PRESENTNNV" Url="http://docs.oracle.com/database/121/SQLRF/functions151.htm">The PRESENTNNV function can be used only in the model_clause of the SELECT statement and then only on the right-hand side of a model rule. It returns expr1 when cell_reference exists prior to the execution of the model_clause and is not null when PRESENTNNV is evaluated. Otherwise it returns expr2. This function differs from NVL2 in that NVL2 evaluates the data at the time it is executed, rather than evaluating the data as it was prior to the execution of the model_clause.</Function>
    <Function Name="PRESENTV" Url="http://docs.oracle.com/database/121/SQLRF/functions152.htm">The PRESENTV function can be used only within the model_clause of the SELECT statement and then only on the right-hand side of a model rule. It returns expr1 when, prior to the execution of the model_clause, cell_reference exists. Otherwise it returns expr2.</Function>
    <Function Name="PREVIOUS" Url="http://docs.oracle.com/database/121/SQLRF/functions153.htm">The PREVIOUS function can be used only in the model_clause of the SELECT statement and then only in the ITERATE ... [ UNTIL ] clause of the model_rules_clause. It returns the value of cell_reference at the beginning of each iteration.</Function>
    <Function Name="RANK" Url="http://docs.oracle.com/database/121/SQLRF/functions154.htm">RANK calculates the rank of a value in a group of values. The return type is NUMBER.</Function>
    <Function Name="RATIO_TO_REPORT" Url="http://docs.oracle.com/database/121/SQLRF/functions155.htm">RATIO_TO_REPORT is an analytic function. It computes the ratio of a value to the sum of a set of values. If expr evaluates to null, then the ratio-to-report value also evaluates to null.
The set of values is determined by the query_partition_clause. If you omit that clause, then the ratio-to-report is computed over all rows returned by the query.
You cannot nest analytic functions by using RATIO_TO_REPORT or any other analytic function for expr. However, you can use other built-in function expressions for expr. Refer to "About SQL Expressions" for information on valid forms of expr.</Function>
    <Function Name="RAWTOHEX" Url="http://docs.oracle.com/database/121/SQLRF/functions156.htm">RAWTOHEX converts raw to a character value containing its hexadecimal representation.
As a SQL built-in function, RAWTOHEX accepts an argument of any scalar data type other than LONG, LONG RAW, CLOB, BLOB, or BFILE. It returns a VARCHAR2 value with the hexadecimal representation of bytes that make up the value of raw. Each byte is represented by two hexadecimal digits.</Function>
    <Function Name="RAWTONHEX" Url="http://docs.oracle.com/database/121/SQLRF/functions157.htm">RAWTONHEX converts raw to a character value containing its hexadecimal representation. RAWTONHEX (raw) is equivalent to TO_NCHAR(RAWTOHEX(raw)). The value returned is always in the national character set.</Function>
    <Function Name="REF" Url="http://docs.oracle.com/database/121/SQLRF/functions158.htm">REF takes as its argument a correlation variable (table alias) associated with a row of an object table or an object view. A REF value is returned for the object instance that is bound to the variable or row.</Function>
    <Function Name="REFTOHEX" Url="http://docs.oracle.com/database/121/SQLRF/functions159.htm">REFTOHEX converts argument expr to a character value containing its hexadecimal equivalent. expr must return a REF.</Function>
    <Function Name="REGEXP_COUNT" Url="http://docs.oracle.com/database/121/SQLRF/functions160.htm">REGEXP_COUNT complements the functionality of the REGEXP_INSTR function by returning the number of times a pattern occurs in a source string. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the number of occurrences of pattern. If no match is found, then the function returns 0.

source_char is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

pattern is the regular expression. It is usually a text literal and can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. It can contain up to 512 bytes. If the data type of pattern is different from the data type of source_char, then Oracle Database converts pattern to the data type of source_char.
REGEXP_COUNT ignores subexpression parentheses in pattern. For example, the pattern '(123(45))' is equivalent to '12345'. For a listing of the operators you can specify in pattern, refer to Appendix D, "Oracle Regular Expression Support".

position is a positive integer indicating the character of source_char where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of source_char. After finding the first occurrence of pattern, the database searches for a second occurrence beginning with the first character following the first occurrence.

match_param is a text literal that lets you change the default matching behavior of the function. You can specify one or more of the following values for match_param:

'i' specifies case-insensitive matching.

'c' specifies case-sensitive matching.

'n' allows the period (.), which is the match-any-character character, to match the newline character. If you omit this parameter, then the period does not match the newline character.

'm' treats the source string as multiple lines. Oracle interprets the caret (^) and dollar sign ($) as the start and end, respectively, of any line anywhere in the source string, rather than only at the start or end of the entire source string. If you omit this parameter, then Oracle treats the source string as a single line.

'x' ignores whitespace characters. By default, whitespace characters match themselves.

If you specify multiple contradictory values, then Oracle uses the last value. For example, if you specify 'ic', then Oracle uses case-sensitive matching. If you specify a character other than those shown above, then Oracle returns an error.
If you omit match_param, then:

The default case sensitivity is determined by the value of the NLS_SORT parameter.

A period (.) does not match the newline character.

The source string is treated as a single line.</Function>
    <Function Name="REGEXP_INSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions161.htm">REGEXP_INSTR extends the functionality of the INSTR function by letting you search a string for a regular expression pattern. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the beginning or ending position of the matched substring, depending on the value of the return_option argument. If no match is found, then the function returns 0.
This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to Appendix D, "Oracle Regular Expression Support".

source_char is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

pattern is the regular expression. It is usually a text literal and can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. It can contain up to 512 bytes. If the data type of pattern is different from the data type of source_char, then Oracle Database converts pattern to the data type of source_char. For a listing of the operators you can specify in pattern, refer to Appendix D, "Oracle Regular Expression Support".

position is a positive integer indicating the character of source_char where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of source_char.

occurrence is a positive integer indicating which occurrence of pattern in source_char Oracle should search for. The default is 1, meaning that Oracle searches for the first occurrence of pattern. If occurrence is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of pattern, and so forth. This behavior is different from the INSTR function, which begins its search for the second occurrence at the second character of the first occurrence.

return_option lets you specify what Oracle should return in relation to the occurrence:

If you specify 0, then Oracle returns the position of the first character of the occurrence. This is the default.

If you specify 1, then Oracle returns the position of the character following the occurrence.


match_parameter is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for REGEXP_COUNT. Refer to REGEXP_COUNT for detailed information.

For a pattern with subexpressions, subexpr is an integer from 0 to 9 indicating which subexpression in pattern is the target of the function. The subexpr is a fragment of pattern enclosed in parentheses. Subexpressions can be nested. Subexpressions are numbered in order in which their left parentheses appear in pattern. For example, consider the following expression:

0123(((abc)(de)f)ghi)45(678)

This expression has five subexpressions in the following order: "abcdefghi" followed by "abcdef", "abc", "de" and "678".
If subexpr is zero, then the position of the entire substring that matches the pattern is returned. If subexpr is greater than zero, then the position of the substring fragment that corresponds to subexpression number subexpr in the matched substring is returned. If pattern does not have at least subexpr subexpressions, the function returns zero. A null subexpr value returns NULL. The default value for subexpr is zero.</Function>
    <Function Name="REGEXP_REPLACE" Url="http://docs.oracle.com/database/121/SQLRF/functions162.htm">REGEXP_REPLACE extends the functionality of the REPLACE function by letting you search a string for a regular expression pattern. By default, the function returns source_char with every occurrence of the regular expression pattern replaced with replace_string. The string returned is in the same character set as source_char. The function returns VARCHAR2 if the first argument is not a LOB and returns CLOB if the first argument is a LOB.
This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to Appendix D, "Oracle Regular Expression Support".

source_char is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB or NCLOB.

pattern is the regular expression. It is usually a text literal and can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. It can contain up to 512 bytes. If the data type of pattern is different from the data type of source_char, then Oracle Database converts pattern to the data type of source_char. For a listing of the operators you can specify in pattern, refer to Appendix D, "Oracle Regular Expression Support".

replace_string can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. If replace_string is a CLOB or NCLOB, then Oracle truncates replace_string to 32K. The replace_string can contain up to 500 backreferences to subexpressions in the form \n, where n is a number from 1 to 9. If you want to include a backslash (\) in replace_string, then you must precede it with the escape character, which is also a backslash. For example, to replace \2 you would enter \\2. For more information on backreference expressions, refer to the notes to "Oracle Regular Expression Support", Table D-1.

position is a positive integer indicating the character of source_char where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of source_char.

occurrence is a nonnegative integer indicating the occurrence of the replace operation:

If you specify 0, then Oracle replaces all occurrences of the match.

If you specify a positive integer n, then Oracle replaces the nth occurrence.

If occurrence is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of pattern, and so forth. This behavior is different from the INSTR function, which begins its search for the second occurrence at the second character of the first occurrence.

match_parameter is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for REGEXP_COUNT. Refer to REGEXP_COUNT for detailed information.</Function>
    <Function Name="REGEXP_SUBSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions163.htm">REGEXP_SUBSTR extends the functionality of the SUBSTR function by letting you search a string for a regular expression pattern. It is also similar to REGEXP_INSTR, but instead of returning the position of the substring, it returns the substring itself. This function is useful if you need the contents of a match string but not its position in the source string. The function returns the string as VARCHAR2 or CLOB data in the same character set as source_char.
This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to Appendix D, "Oracle Regular Expression Support".

source_char is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.

pattern is the regular expression. It is usually a text literal and can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. It can contain up to 512 bytes. If the data type of pattern is different from the data type of source_char, then Oracle Database converts pattern to the data type of source_char. For a listing of the operators you can specify in pattern, refer to Appendix D, "Oracle Regular Expression Support".

position is a positive integer indicating the character of source_char where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of source_char.

occurrence is a positive integer indicating which occurrence of pattern in source_char Oracle should search for. The default is 1, meaning that Oracle searches for the first occurrence of pattern.
If occurrence is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of pattern, and so forth. This behavior is different from the SUBSTR function, which begins its search for the second occurrence at the second character of the first occurrence.

match_parameter is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for REGEXP_COUNT. Refer to REGEXP_COUNT for detailed information.

For a pattern with subexpressions, subexpr is a nonnegative integer from 0 to 9 indicating which subexpression in pattern is to be returned by the function. This parameter has the same semantics that it has for the REGEXP_INSTR function. Refer to REGEXP_INSTR for more information.</Function>
    <Function Name="REMAINDER" Url="http://docs.oracle.com/database/121/SQLRF/functions165.htm">REMAINDER returns the remainder of n2 divided by n1.
This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.
The MOD function is similar to REMAINDER except that it uses FLOOR in its formula, whereas REMAINDER uses ROUND. Refer to MOD.</Function>
    <Function Name="REPLACE" Url="http://docs.oracle.com/database/121/SQLRF/functions166.htm">REPLACE returns char with every occurrence of search_string replaced with replacement_string. If replacement_string is omitted or null, then all occurrences of search_string are removed. If search_string is null, then char is returned.
Both search_string and replacement_string, as well as char, can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is in the same character set as char. The function returns VARCHAR2 if the first argument is not a LOB and returns CLOB if the first argument is a LOB.
REPLACE provides functionality related to that provided by the TRANSLATE function. TRANSLATE provides single-character, one-to-one substitution. REPLACE lets you substitute one string for another as well as to remove character strings.</Function>
    <Function Name="ROUND" Url="http://docs.oracle.com/database/121/SQLRF/functions167.htm">ROUND returns date rounded to the unit specified by the format model fmt. This function is not sensitive to the NLS_CALENDAR session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type DATE, even if you specify a different datetime data type for date. If you omit fmt, then date is rounded to the nearest day. The date expression must resolve to a DATE value.</Function>
    <Function Name="ROUND" Url="http://docs.oracle.com/database/121/SQLRF/functions168.htm">ROUND returns n rounded to integer places to the right of the decimal point. If you omit integer, then n is rounded to zero places. If integer is negative, then n is rounded off to the left of the decimal point.
n can be any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit integer, then the function returns the value ROUND(n, 0) in the same data type as the numeric data type of n. If you include integer, then the function returns NUMBER.
ROUND is implemented using the following rules:

If n is 0, then ROUND always returns 0 regardless of integer.

If n is negative, then ROUND(n, integer) returns -ROUND(-n, integer).

If n is positive, then

ROUND(n, integer) = FLOOR(n * POWER(10, integer) + 0.5) * POWER(10, -integer)

ROUND applied to a NUMBER value may give a slightly different result from ROUND applied to the same value expressed in floating-point. The different results arise from differences in internal representations of NUMBER and floating point values. The difference will be 1 in the rounded digit if a difference occurs.</Function>
    <Function Name="ROW_NUMBER" Url="http://docs.oracle.com/database/121/SQLRF/functions169.htm">ROW_NUMBER is an analytic function. It assigns a unique number to each row to which it is applied (either each row in the partition or each row returned by the query), in the ordered sequence of rows specified in the order_by_clause, beginning with 1.
By nesting a subquery using ROW_NUMBER inside a query that retrieves the ROW_NUMBER values for a specified range, you can find a precise subset of rows from the results of the inner query. This use of the function lets you implement top-N, bottom-N, and inner-N reporting. For consistent results, the query must ensure a deterministic sort order.
You cannot nest analytic functions by using ROW_NUMBER or any other analytic function for expr. However, you can use other built-in function expressions for expr. Refer to "About SQL Expressions" for information on valid forms of expr.</Function>
    <Function Name="ROWIDTOCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions170.htm">ROWIDTOCHAR converts a rowid value to VARCHAR2 data type. The result of this conversion is always 18 characters long.</Function>
    <Function Name="ROWIDTONCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions171.htm">ROWIDTONCHAR converts a rowid value to NVARCHAR2 data type. The result of this conversion is always in the national character set and is 18 characters long.</Function>
    <Function Name="RPAD" Url="http://docs.oracle.com/database/121/SQLRF/functions172.htm">RPAD returns expr1, right-padded to length n characters with expr2, replicated as many times as necessary. This function is useful for formatting the output of a query.
Both expr1 and expr2 can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if expr1 is a character data type, NVARCHAR2 if expr1 is a national character data type, and a LOB if expr1 is a LOB data type. The string returned is in the same character set as expr1. The argument n must be a NUMBER integer or a value that can be implicitly converted to a NUMBER integer.
expr1 cannot be null. If you do not specify expr2, then it defaults to a single blank. If expr1 is longer than n, then this function returns the portion of expr1 that fits in n.
The argument n is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string.</Function>
    <Function Name="RTRIM" Url="http://docs.oracle.com/database/121/SQLRF/functions173.htm">RTRIM removes from the right end of char all of the characters that appear in set. This function is useful for formatting the output of a query.
If you do not specify set, then it defaults to a single blank. If char is a character literal, then you must enclose it in single quotation marks. RTRIM works similarly to LTRIM.
Both char and set can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The string returned is of VARCHAR2 data type if char is a character data type, NVARCHAR2 if char is a national character data type, and a LOB if char is a LOB data type.</Function>
    <Function Name="SCN_TO_TIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions174.htm">SCN_TO_TIMESTAMP takes as an argument a number that evaluates to a system change number (SCN), and returns the approximate timestamp associated with that SCN. The returned value is of TIMESTAMP data type. This function is useful any time you want to know the timestamp associated with an SCN. For example, it can be used in conjunction with the ORA_ROWSCN pseudocolumn to associate a timestamp with the most recent change to a row.</Function>
    <Function Name="SESSIONTIMEZONE" Url="http://docs.oracle.com/database/121/SQLRF/functions175.htm">SESSIONTIMEZONE returns the time zone of the current session. The return type is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the user specified the session time zone value in the most recent ALTER SESSION statement.</Function>
    <Function Name="SET" Url="http://docs.oracle.com/database/121/SQLRF/functions176.htm">SET converts a nested table into a set by eliminating duplicates. The function returns a nested table whose elements are distinct from one another. The returned nested table is of the same type as the input nested table.
The element types of the nested table must be comparable. Refer to "Comparison Conditions" for information on the comparability of nonscalar types.</Function>
    <Function Name="SIGN" Url="http://docs.oracle.com/database/121/SQLRF/functions177.htm">SIGN returns the sign of n. This function takes as an argument any numeric data type, or any nonnumeric data type that can be implicitly converted to NUMBER, and returns NUMBER.
For value of NUMBER type, the sign is:

-1 if n&lt;0

0 if n=0

1 if n&gt;0

For binary floating-point numbers (BINARY_FLOAT and BINARY_DOUBLE), this function returns the sign bit of the number. The sign bit is:

-1 if n&lt;0

+1 if n&gt;=0 or n=NaN</Function>
    <Function Name="SIN" Url="http://docs.oracle.com/database/121/SQLRF/functions178.htm">SIN returns the sine of n (an angle expressed in radians).
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="SINH" Url="http://docs.oracle.com/database/121/SQLRF/functions179.htm">SINH returns the hyperbolic sine of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="SOUNDEX" Url="http://docs.oracle.com/database/121/SQLRF/functions180.htm">SOUNDEX returns a character string containing the phonetic representation of char. This function lets you compare words that are spelled differently, but sound alike in English.
The phonetic representation is defined in The Art of Computer Programming, Volume 3: Sorting and Searching, by Donald E. Knuth, as follows:

Retain the first letter of the string and remove all other occurrences of the following letters: a, e, h, i, o, u, w, y.

Assign numbers to the remaining letters (after the first) as follows:

b, f, p, v = 1
c, g, j, k, q, s, x, z = 2
d, t = 3
l = 4
m, n = 5
r = 6

If two or more letters with the same number were adjacent in the original name (before step 1), or adjacent except for any intervening h and w, then retain the first letter and omit rest of all the adjacent letters with same number.

Return the first four bytes padded with 0.

char can be of any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The return value is the same data type as char.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="SQRT" Url="http://docs.oracle.com/database/121/SQLRF/functions181.htm">SQRT returns the square root of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="STANDARD_HASH" Url="http://docs.oracle.com/database/121/SQLRF/functions182.htm">STANDARD_HASH computes a hash value for a given expression using one of several hash algorithms that are defined and standardized by the National Institute of Standards and Technology. This function is useful for performing authentication and maintaining data integrity in security applications such as digital signatures, checksums, and fingerprinting.
You can use the STANDARD_HASH function to create an index on an extended data type column. Refer to "Creating an Index on an Extended Data Type Column" for more information.

The expr argument determines the data for which you want Oracle Database to compute a hash value. There are no restrictions on the length of data represented by expr, which commonly resolves to a column name. The expr cannot be a LONG or LOB type. It cannot be a user-defined object type. All other data types are supported for expr.

The optional method argument lets you specify the name of the hash algorithm to be used. Valid algorithms are SHA1, SHA256, SHA384, SHA512, and MD5. If you omit this argument, then SHA1 is used.

The function returns a RAW value.</Function>
    <Function Name="STATS_BINOMIAL_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions183.htm">STATS_BINOMIAL_TEST is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small.
This function takes four arguments: expr1 is the sample being examined. expr2 contains the values for which the proportion is expected to be, and p is a proportion to test against. The fourth argument is a return value of type VARCHAR2. If you omit the fourth argument, then the default is TWO_SIDED_PROB. The meaning of the return values is shown in Table 7-3.</Function>
    <Function Name="STATS_CROSSTAB" Url="http://docs.oracle.com/database/121/SQLRF/functions184.htm">Crosstabulation (commonly called crosstab) is a method used to analyze two nominal variables. The STATS_CROSSTAB function takes three arguments: two expressions and a return value of type VARCHAR2. expr1 and expr2 are the two variables being analyzed. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is CHISQ_SIG. The meaning of the return values is shown in Table 7-4.</Function>
    <Function Name="STATS_F_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions185.htm">STATS_F_TEST tests whether two variances are significantly different. The observed value of f is the ratio of one variance to the other, so values very different from 1 usually indicate significant differences.
This function takes three arguments: expr1 is the grouping or independent variable and expr2 is the sample of values. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is TWO_SIDED_SIG. The meaning of the return values is shown in Table 7-5.</Function>
    <Function Name="STATS_KS_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions186.htm">STATS_KS_TEST is a Kolmogorov-Smirnov function that compares two samples to test whether they are from the same population or from populations that have the same distribution. It does not assume that the population from which the samples were taken is normally distributed.
This function takes three arguments: two expressions and a return value of type VARCHAR2. expr1 classifies the data into the two samples. expr2 contains the values for each of the samples. If expr1 classifies the rows into only one sample or into more than two samples, then an error is raised.The function returns one value determined by the third argument. If you omit the third argument, then the default is SIG. The meaning of the return values is shown in Table 7-6.</Function>
    <Function Name="STATS_MODE" Url="http://docs.oracle.com/database/121/SQLRF/functions187.htm">STATS_MODE takes as its argument a set of values and returns the value that occurs with the greatest frequency. If more than one mode exists, then Oracle Database chooses one and returns only that one value.
To obtain multiple modes (if multiple modes exist), you must use a combination of other functions, as shown in the hypothetical query:

SELECT x FROM (SELECT x, COUNT(x) AS cnt1
   FROM t GROUP BY x)
   WHERE cnt1 =
      (SELECT MAX(cnt2) FROM (SELECT COUNT(x) AS cnt2 FROM t GROUP BY x));</Function>
    <Function Name="STATS_ONE_WAY_ANOVA" Url="http://docs.oracle.com/database/121/SQLRF/functions189.htm">The one-way analysis of variance function (STATS_ONE_WAY_ANOVA) tests differences in means (for groups or variables) for statistical significance by comparing two different estimates of variance. One estimate is based on the variances within each group or category. This is known as the mean squares within or mean square error. The other estimate is based on the variances among the means of the groups. This is known as the mean squares between. If the means of the groups are significantly different, then the mean squares between will be larger than expected and will not match the mean squares within. If the mean squares of the groups are consistent, then the two variance estimates will be about the same.
STATS_ONE_WAY_ANOVA takes three arguments: two expressions and a return value of type VARCHAR2. expr1 is an independent or grouping variable that divides the data into a set of groups. expr2 is a dependent variable (a numeric expression) containing the values corresponding to each member of a group. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is SIG. The meaning of the return values is shown in Table 7-8.</Function>
    <Function Name="STATS_T_TEST_" Url="http://docs.oracle.com/database/121/SQLRF/functions190.htm">The t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample STATS_T_TEST_* functions take three arguments: two expressions and a return value of type VARCHAR2. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is TWO_SIDED_SIG. The meaning of the return values is shown in Table 7-9.</Function>
    <Function Name="STATS_WSR_TEST" Url="http://docs.oracle.com/database/121/SQLRF/functions191.htm">STATS_WSR_TEST is a Wilcoxon Signed Ranks test of paired samples to determine whether the median of the differences between the samples is significantly different from zero. The absolute values of the differences are ordered and assigned ranks. Then the null hypothesis states that the sum of the ranks of the positive differences is equal to the sum of the ranks of the negative differences.
This function takes three arguments: expr1 and expr2 are the two samples being analyzed, and the third argument is a return value of type VARCHAR2. If you omit the third argument, then the default is TWO_SIDED_SIG. The meaning of the return values is shown in Table 7-10.</Function>
    <Function Name="STDDEV" Url="http://docs.oracle.com/database/121/SQLRF/functions192.htm">STDDEV returns the sample standard deviation of expr, a set of numbers. You can use it as both an aggregate and analytic function. It differs from STDDEV_SAMP in that STDDEV returns zero when it has only 1 row of input data, whereas STDDEV_SAMP returns null.
Oracle Database calculates the standard deviation as the square root of the variance defined for the VARIANCE aggregate function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="STDDEV_POP" Url="http://docs.oracle.com/database/121/SQLRF/functions193.htm">STDDEV_POP computes the population standard deviation and returns the square root of the population variance. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="STDDEV_SAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions194.htm">STDDEV_SAMP computes the cumulative sample standard deviation and returns the square root of the sample variance. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="SUBSTR" Url="http://docs.oracle.com/database/121/SQLRF/functions195.htm">The SUBSTR functions return a portion of char, beginning at character position, substring_length characters long. SUBSTR calculates lengths using characters as defined by the input character set. SUBSTRB uses bytes instead of characters. SUBSTRC uses Unicode complete characters. SUBSTR2 uses UCS2 code points. SUBSTR4 uses UCS4 code points.

If position is 0, then it is treated as 1.

If position is positive, then Oracle Database counts from the beginning of char to find the first character.

If position is negative, then Oracle counts backward from the end of char.

If substring_length is omitted, then Oracle returns all characters to the end of char. If substring_length is less than 1, then Oracle returns null.

char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The exceptions are SUBSTRC, SUBSTR2, and SUBSTR4, which do not allow char to be a CLOB or NCLOB. Both position and substring_length must be of data type NUMBER, or any data type that can be implicitly converted to NUMBER, and must resolve to an integer. The return value is the same data type as char. Floating-point numbers passed as arguments to SUBSTR are automatically converted to integers.</Function>
    <Function Name="SUM" Url="http://docs.oracle.com/database/121/SQLRF/functions196.htm">SUM returns the sum of values of expr. You can use it as an aggregate or analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="SYS_CONNECT_BY_PATH" Url="http://docs.oracle.com/database/121/SQLRF/functions197.htm">SYS_CONNECT_BY_PATH is valid only in hierarchical queries. It returns the path of a column value from root to node, with column values separated by char for each row returned by CONNECT BY condition.
Both column and char can be any of the data types CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The string returned is of VARCHAR2 data type and is in the same character set as column.</Function>
    <Function Name="SYS_CONTEXT" Url="http://docs.oracle.com/database/121/SQLRF/functions198.htm">SYS_CONTEXT returns the value of parameter associated with the context namespace at the current instant. You can use this function in both SQL and PL/SQL statements. SYS_CONTEXT must be executed locally.
For namespace and parameter, you can specify either a string or an expression that resolves to a string designating a namespace or an attribute. If you specify literal arguments for namespace and parameter, and you are using SYS_CONTEXT explicitly in a SQL statement—rather than in a PL/SQL function that in turn is in mentioned in a SQL statement—then Oracle Database evaluates SYS_CONTEXT only once per SQL statement execution for each call site that invokes the SYS_CONTEXT function.
The context namespace must already have been created, and the associated parameter and its value must also have been set using the DBMS_SESSION.set_context procedure. The namespace must be a valid SQL identifier. The parameter name can be any string. It is not case sensitive, but it cannot exceed 30 bytes in length.
The data type of the return value is VARCHAR2. The default maximum size of the return value is 256 bytes. You can override this default by specifying the optional length parameter, which must be a NUMBER or a value that can be implicitly converted to NUMBER. The valid range of values is 1 to 4000 bytes. If you specify an invalid value, then Oracle Database ignores it and uses the default.
Oracle provides the following built-in namespaces:

USERENV - Describes the current session. The predefined parameters of namespace USERENV are listed in Table 7-11.

SYS_SESSION_ROLES - Indicates whether a specified role is currently enabled for the session.</Function>
    <Function Name="SYS_DBURIGEN" Url="http://docs.oracle.com/database/121/SQLRF/functions199.htm">SYS_DBURIGen takes as its argument one or more columns or attributes, and optionally a rowid, and generates a URL of data type DBURIType to a particular column or row object. You can then use the URL to retrieve an XML document from the database.
All columns or attributes referenced must reside in the same table. They must perform the function of a primary key. They need not actually match the primary key of the table, but they must reference a unique value. If you specify multiple columns, then all but the final column identify the row in the database, and the last column specified identifies the column within the row.
By default the URL points to a formatted XML document. If you want the URL to point only to the text of the document, then specify the optional 'text()'.</Function>
    <Function Name="SYS_EXTRACT_UTC" Url="http://docs.oracle.com/database/121/SQLRF/functions200.htm">SYS_EXTRACT_UTC extracts the UTC (Coordinated Universal Time—formerly Greenwich Mean Time) from a datetime value with time zone offset or time zone region name. If a time zone is not specified, then the datetime is associated with the session time zone.</Function>
    <Function Name="SYS_GUID" Url="http://docs.oracle.com/database/121/SQLRF/functions201.htm">SYS_GUID generates and returns a globally unique identifier (RAW value) made up of 16 bytes. On most platforms, the generated identifier consists of a host identifier, a process or thread identifier of the process or thread invoking the function, and a nonrepeating value (sequence of bytes) for that process or thread.</Function>
    <Function Name="SYS_OP_ZONE_ID" Url="http://docs.oracle.com/database/121/SQLRF/functions202.htm">SYS_OP_ZONE_ID takes as its argument a rowid and returns a zone ID. The rowid identifies a row in a table. The zone ID identifies the set of contiguous disk blocks, called the zone, that contains the row. The function returns a NUMBER value.
The SYS_OP_ZONE_ID function is used when creating a zone map with the CREATE MATERIALIZED ZONEMAP statement. You must specify SYS_OP_ZONE_ID in the SELECT and GROUP BY clauses of the defining subquery of the zone map.
For rowid, specify the ROWID pseudocolumn of the fact table of the zone map.
Use schema and table to specify the schema and name of the fact table, or t_alias to specify the table alias for the fact table. The specification of these parameters depends on the FROM clause in the defining subquery of the zone map:

If the FROM clause specifies a table alias for the fact table, then you must also specify the table alias (t_alias) in SYS_OP_ZONE_ID.

If the FROM clause does not specify a table alias for the fact table, then use table to specify the name of the fact table. You can use the schema qualifier if the fact table is in a schema other than your own. If you omit schema, then the database assumes the fact table is in your own schema. If the FROM clause specifies only one table (the fact table) then you need not specify schema or table.

The optional scale parameter represents the scale of the zone map. It is not necessary to specify this parameter because, by default, SYS_OP_ZONE_ID uses the scale of the zone map being created. If you do specify scale, then it must match the scale of the zone map being created. Refer to the SCALE clause of CREATE MATERIALIZED ZONEMAP for information on specifying the scale of a zone map.</Function>
    <Function Name="SYS_TYPEID" Url="http://docs.oracle.com/database/121/SQLRF/functions203.htm">SYS_TYPEID returns the typeid of the most specific type of the operand. This value is used primarily to identify the type-discriminant column underlying a substitutable column. For example, you can use the value returned by SYS_TYPEID to build an index on the type-discriminant column.
You can use this function only on object type operands. All final root object types—final types not belonging to a type hierarchy—have a null typeid. Oracle Database assigns to all types belonging to a type hierarchy a unique non-null typeid.</Function>
    <Function Name="SYS_XMLAGG" Url="http://docs.oracle.com/database/121/SQLRF/functions204.htm">SYS_XMLAgg aggregates all of the XML documents or fragments represented by expr and produces a single XML document. It adds a new enclosing element with a default name ROWSET. If you want to format the XML document differently, then specify fmt, which is an instance of the XMLFormat object.</Function>
    <Function Name="SYS_XMLGEN" Url="http://docs.oracle.com/database/121/SQLRF/functions205.htm">SYS_XMLGen takes an expression that evaluates to a particular row and column of the database, and returns an instance of type XMLType containing an XML document. The expr can be a scalar value, a user-defined type, or an XMLType instance.

If expr is a scalar value, then the function returns an XML element containing the scalar value.

If expr is a type, then the function maps the user-defined type attributes to XML elements.

If expr is an XMLType instance, then the function encloses the document in an XML element whose default tag name is ROW.

By default the elements of the XML document match the elements of expr. For example, if expr resolves to a column name, then the enclosing XML element will be the same column name. If you want to format the XML document differently, then specify fmt, which is an instance of the XMLFormat object.</Function>
    <Function Name="SYSDATE" Url="http://docs.oracle.com/database/121/SQLRF/functions206.htm">SYSDATE returns the current date and time set for the operating system on which the database server resides. The data type of the returned value is DATE, and the format returned depends on the value of the NLS_DATE_FORMAT initialization parameter. The function requires no arguments. In distributed SQL statements, this function returns the date and time set for the operating system of your local database. You cannot use this function in the condition of a CHECK constraint.</Function>
    <Function Name="SYSTIMESTAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions207.htm">SYSTIMESTAMP returns the system date, including fractional seconds and time zone, of the system on which the database resides. The return type is TIMESTAMP WITH TIME ZONE.</Function>
    <Function Name="TAN" Url="http://docs.oracle.com/database/121/SQLRF/functions208.htm">TAN returns the tangent of n (an angle expressed in radians).
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="TANH" Url="http://docs.oracle.com/database/121/SQLRF/functions209.htm">TANH returns the hyperbolic tangent of n.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is BINARY_FLOAT, then the function returns BINARY_DOUBLE. Otherwise the function returns the same numeric data type as the argument.</Function>
    <Function Name="TIMESTAMP_TO_SCN" Url="http://docs.oracle.com/database/121/SQLRF/functions210.htm">TIMESTAMP_TO_SCN takes as an argument a timestamp value and returns the approximate system change number (SCN) associated with that timestamp. The returned value is of data type NUMBER. This function is useful any time you want to know the SCN associated with a particular timestamp.</Function>
    <Function Name="TO_BINARY_DOUBLE" Url="http://docs.oracle.com/database/121/SQLRF/functions211.htm">TO_BINARY_DOUBLE returns a double-precision floating-point number.

expr can be a character string or a numeric value of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. If expr is BINARY_DOUBLE, then the function returns expr.

The optional 'fmt' and 'nlsparam' arguments are valid only if expr is a character string. They serve the same purpose as for the TO_CHAR (number) function.

The case-insensitive string 'INF' is converted to positive infinity.

The case-insensitive string '-INF' is converted to negative identity.

The case-insensitive string 'NaN' is converted to NaN (not a number).


You cannot use a floating-point number format element (F, f, D, or d) in a character string expr.
Conversions from character strings or NUMBER to BINARY_DOUBLE can be inexact, because the NUMBER and character types use decimal precision to represent the numeric value, and BINARY_DOUBLE uses binary precision.
Conversions from BINARY_FLOAT to BINARY_DOUBLE are exact.</Function>
    <Function Name="TO_BINARY_FLOAT" Url="http://docs.oracle.com/database/121/SQLRF/functions212.htm">TO_BINARY_FLOAT returns a single-precision floating-point number.

expr can be a character string or a numeric value of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. If expr is BINARY_FLOAT, then the function returns expr.

The optional 'fmt' and 'nlsparam' arguments are valid only if expr is a character string. They serve the same purpose as for the TO_CHAR (number) function.

The incase-sensitive string 'INF' is converted to positive infinity.

The incase-sensitive string '-INF' is converted to negative identity.

The incase-sensitive string 'NaN' is converted to NaN (not a number).


You cannot use a floating-point number format element (F, f, D, or d) in a character string expr.
Conversions from character strings or NUMBER to BINARY_FLOAT can be inexact, because the NUMBER and character types use decimal precision to represent the numeric value and BINARY_FLOAT uses binary precision.
Conversions from BINARY_DOUBLE to BINARY_FLOAT are inexact if the BINARY_DOUBLE value uses more bits of precision than supported by the BINARY_FLOAT.</Function>
    <Function Name="TO_BLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions213.htm">TO_BLOB converts LONG RAW and RAW values to BLOB values.
From within a PL/SQL package, you can use TO_BLOB to convert RAW and BLOB values to BLOB.</Function>
    <Function Name="TO_CHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions214.htm">TO_CHAR (character) converts NCHAR, NVARCHAR2, CLOB, or NCLOB data to the database character set. The value returned is always VARCHAR2.
When you use this function to convert a character LOB into the database character set, if the LOB value to be converted is larger than the target type, then the database returns an error.
You can use this function in conjunction with any of the XML functions to generate a date in the database format rather than the XML Schema standard format.</Function>
    <Function Name="TO_CHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions215.htm">TO_CHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL DAY TO SECOND, or INTERVAL YEAR TO MONTH data type to a value of VARCHAR2 data type in the format specified by the date format fmt. If you omit fmt, then date is converted to a VARCHAR2 value as follows:

DATE values are converted to values in the default date format.

TIMESTAMP and TIMESTAMP WITH LOCAL TIME ZONE values are converted to values in the default timestamp format.

TIMESTAMP WITH TIME ZONE values are converted to values in the default timestamp with time zone format.

Interval values are converted to the numeric representation of the interval literal.

Refer to "Format Models" for information on datetime formats.
The 'nlsparam' argument specifies the language in which month and day names and abbreviations are returned. This argument can have this form:

'NLS_DATE_LANGUAGE = language' 

If you omit 'nlsparam', then this function uses the default date language for your session.</Function>
    <Function Name="TO_CHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions216.htm">TO_CHAR (number) converts n to a value of VARCHAR2 data type, using the optional number format fmt. The value n can be of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. If you omit fmt, then n is converted to a VARCHAR2 value exactly long enough to hold its significant digits.
If n is negative, then the sign is applied after the format is applied. Thus TO_CHAR(-1, '$9') returns -$1, rather than $-1.
Refer to "Format Models" for information on number formats.
The 'nlsparam' argument specifies these characters that are returned by number format elements:

Decimal character

Group separator

Local currency symbol

International currency symbol

This argument can have this form:

'NLS_NUMERIC_CHARACTERS = ''dg''
   NLS_CURRENCY = ''text''
   NLS_ISO_CURRENCY = territory '

The characters d and g represent the decimal character and group separator, respectively. They must be different single-byte characters. Within the quoted string, you must use two single quotation marks around the parameter values. Ten characters are available for the currency symbol.
If you omit 'nlsparam' or any one of the parameters, then this function uses the default parameter values for your session.</Function>
    <Function Name="TO_CLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions217.htm">TO_CLOB converts NCLOB values in a LOB column or other character strings to CLOB values. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. Oracle Database executes this function by converting the underlying LOB data from the national character set to the database character set.
From within a PL/SQL package, you can use the TO_CLOB function to convert RAW, CHAR, VARCHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB values to CLOB or NCLOB values.</Function>
    <Function Name="TO_DATE" Url="http://docs.oracle.com/database/121/SQLRF/functions218.htm">TO_DATE converts char of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to a value of DATE data type.</Function>
    <Function Name="TO_DSINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions219.htm">TO_DSINTERVAL converts a character string of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to an INTERVAL DAY TO SECOND type.
TO_DSINTERVAL accepts argument in one of the two formats:

SQL interval format compatible with the SQL standard (ISO/IEC 9075:2003)

ISO duration format compatible with the ISO 8601:2004 standard

In the SQL format, days is an integer between 0 and 999999999, hours is an integer between 0 and 23, and minutes and seconds are integers between 0 and 59. frac_secs is the fractional part of seconds between .0 and .999999999. One or more blanks separate days from hours. Additional blanks are allowed between format elements.
In the ISO format, days, hours, minutes and seconds are integers between 0 and 999999999. frac_secs is the fractional part of seconds between .0 and .999999999. No blanks are allowed in the value. If you specify T, then you must specify at least one of the hours, minutes, or seconds values.</Function>
    <Function Name="TO_LOB" Url="http://docs.oracle.com/database/121/SQLRF/functions220.htm">TO_LOB converts LONG or LONG RAW values in the column long_column to LOB values. You can apply this function only to a LONG or LONG RAW column, and only in the select list of a subquery in an INSERT statement.
Before using this function, you must create a LOB column to receive the converted LONG values. To convert LONG values, create a CLOB column. To convert LONG RAW values, create a BLOB column.
You cannot use the TO_LOB function to convert a LONG column to a LOB column in the subquery of a CREATE TABLE ... AS SELECT statement if you are creating an index-organized table. Instead, create the index-organized table without the LONG column, and then use the TO_LOB function in an INSERT ... AS SELECT statement.
You cannot use this function within a PL/SQL package. Instead use the TO_CLOB or TO_BLOB functions.</Function>
    <Function Name="TO_MULTI_BYTE" Url="http://docs.oracle.com/database/121/SQLRF/functions221.htm">TO_MULTI_BYTE returns char with all of its single-byte characters converted to their corresponding multibyte characters. char can be of data type CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The value returned is in the same data type as char.
Any single-byte characters in char that have no multibyte equivalents appear in the output string as single-byte characters. This function is useful only if your database character set contains both single-byte and multibyte characters.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TO_NCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions222.htm">TO_NCHAR (character) converts a character string, CHAR, VARCHAR2, CLOB, or NCLOB value to the national character set. The value returned is always NVARCHAR2. This function is equivalent to the TRANSLATE ... USING function with a USING clause in the national character set.</Function>
    <Function Name="TO_NCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions223.htm">TO_NCHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL MONTH TO YEAR, or INTERVAL DAY TO SECOND data type from the database character set to the national character set.</Function>
    <Function Name="TO_NCHAR" Url="http://docs.oracle.com/database/121/SQLRF/functions224.htm">TO_NCHAR (number) converts n to a string in the national character set. The value n can be of type NUMBER, BINARY_FLOAT, or BINARY_DOUBLE. The function returns a value of the same type as the argument. The optional fmt and 'nlsparam' corresponding to n can be of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL MONTH TO YEAR, or INTERVAL DAY TO SECOND data type.</Function>
    <Function Name="TO_NCLOB" Url="http://docs.oracle.com/database/121/SQLRF/functions225.htm">TO_NCLOB converts CLOB values in a LOB column or other character strings to NCLOB values. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. Oracle Database implements this function by converting the character set of char from the database character set to the national character set.</Function>
    <Function Name="TO_NUMBER" Url="http://docs.oracle.com/database/121/SQLRF/functions226.htm">TO_NUMBER converts expr to a value of NUMBER data type. The expr can be a BINARY_DOUBLE value or a value of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type containing a number in the format specified by the optional format model fmt.
You can specify an expr of BINARY_FLOAT. However, it makes no sense to do so because a float can be interpreted only by its internal presentation.
Refer to "Format Models" for information on number formats.
The 'nlsparam' argument in this function has the same purpose as it does in the TO_CHAR function for number conversions. Refer to TO_CHAR (number) for more information.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TO_SINGLE_BYTE" Url="http://docs.oracle.com/database/121/SQLRF/functions227.htm">TO_SINGLE_BYTE returns char with all of its multibyte characters converted to their corresponding single-byte characters. char can be of data type CHAR, VARCHAR2, NCHAR, or NVARCHAR2. The value returned is in the same data type as char.
Any multibyte characters in char that have no single-byte equivalents appear in the output as multibyte characters. This function is useful only if your database character set contains both single-byte and multibyte characters.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TO_YMINTERVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions230.htm">TO_YMINTERVAL converts a character string of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to an INTERVAL YEAR TO MONTH type.
TO_YMINTERVAL accepts argument in one of the two formats:

SQL interval format compatible with the SQL standard (ISO/IEC 9075:2003)

ISO duration format compatible with the ISO 8601:2004 standard

In the SQL format, years is an integer between 0 and 999999999, and months is an integer between 0 and 11. Additional blanks are allowed between format elements.
In the ISO format, years and months are integers between 0 and 999999999. Days, hours, minutes, seconds, and frac_secs are non-negative integers, and are ignored, if specified. No blanks are allowed in the value. If you specify T, then you must specify at least one of the hours, minutes, or seconds values.</Function>
    <Function Name="TRANSLATE" Url="http://docs.oracle.com/database/121/SQLRF/functions231.htm">TRANSLATE returns expr with all occurrences of each character in from_string replaced by its corresponding character in to_string. Characters in expr that are not in from_string are not replaced. The argument from_string can contain more characters than to_string. In this case, the extra characters at the end of from_string have no corresponding characters in to_string. If these extra characters appear in expr, then they are removed from the return value.
If a character appears multiple times in from_string, then the to_string mapping corresponding to the first occurrence is used.
You cannot use an empty string for to_string to remove all characters in from_string from the return value. Oracle Database interprets the empty string as null, and if this function has a null argument, then it returns null. To remove all characters in from_string, concatenate another character to the beginning of from_string and specify this character as the to_string. For example, TRANSLATE(expr, 'x0123456789', 'x') removes all digits from expr.
TRANSLATE provides functionality related to that provided by the REPLACE function. REPLACE lets you substitute a single string for another single string, as well as remove character strings. TRANSLATE lets you make several single-character, one-to-one substitutions in one operation.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TRANSLATE" Url="http://docs.oracle.com/database/121/SQLRF/functions232.htm">TRANSLATE ... USING converts char into the character set specified for conversions between the database character set and the national character set.</Function>
    <Function Name="TREAT" Url="http://docs.oracle.com/database/121/SQLRF/functions233.htm">TREAT changes the declared type of an expression.
You must have the EXECUTE object privilege on type to use this function.

type must be some supertype or subtype of the declared type of expr. If the most specific type of expr is type (or some subtype of type), then TREAT returns expr. If the most specific type of expr is not type (or some subtype of type), then TREAT returns NULL.

You can specify REF only if the declared type of expr is a REF type.

If the declared type of expr is a REF to a source type of expr, then type must be some subtype or supertype of the source type of expr. If the most specific type of DEREF(expr) is type (or a subtype of type), then TREAT returns expr. If the most specific type of DEREF(expr) is not type (or a subtype of type), then TREAT returns NULL.

This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="TRIM" Url="http://docs.oracle.com/database/121/SQLRF/functions234.htm">TRIM enables you to trim leading or trailing characters (or both) from a character string. If trim_character or trim_source is a character literal, then you must enclose it in single quotation marks.

If you specify LEADING, then Oracle Database removes any leading characters equal to trim_character.

If you specify TRAILING, then Oracle removes any trailing characters equal to trim_character.

If you specify BOTH or none of the three, then Oracle removes leading and trailing characters equal to trim_character.

If you do not specify trim_character, then the default value is a blank space.

If you specify only trim_source, then Oracle removes leading and trailing blank spaces.

The function returns a value with data type VARCHAR2. The maximum length of the value is the length of trim_source.

If either trim_source or trim_character is null, then the TRIM function returns null.

Both trim_character and trim_source can be VARCHAR2 or any data type that can be implicitly converted to VARCHAR2. The string returned is a VARCHAR2 (NVARCHAR2) data type if trim_source is a CHAR or VARCHAR2 (NCHAR or NVARCHAR2) data type, and a CLOB if trim_source is a CLOB data type. The return string is in the same character set as trim_source.</Function>
    <Function Name="TRUNC" Url="http://docs.oracle.com/database/121/SQLRF/functions235.htm">The TRUNC (date) function returns date with the time portion of the day truncated to the unit specified by the format model fmt. This function is not sensitive to the NLS_CALENDAR session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type DATE, even if you specify a different datetime data type for date. If you omit fmt, then the default format model 'DD' is used and the value returned is date truncated to the day with a time of midnight. Refer to "ROUND and TRUNC Date Functions" for the permitted format models to use in fmt.</Function>
    <Function Name="TRUNC" Url="http://docs.oracle.com/database/121/SQLRF/functions236.htm">The TRUNC (number) function returns n1 truncated to n2 decimal places. If n2 is omitted, then n1 is truncated to 0 places. n2 can be negative to truncate (make zero) n2 digits left of the decimal point.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit n2, then the function returns the same data type as the numeric data type of the argument. If you include n2, then the function returns NUMBER.</Function>
    <Function Name="TZ_OFFSET" Url="http://docs.oracle.com/database/121/SQLRF/functions237.htm">TZ_OFFSET returns the time zone offset corresponding to the argument based on the date the statement is executed. You can enter a valid time zone region name, a time zone offset from UTC (which simply returns itself), or the keyword SESSIONTIMEZONE or DBTIMEZONE. For a listing of valid values for time_zone_name, query the TZNAME column of the V$TIMEZONE_NAMES dynamic performance view.</Function>
    <Function Name="UID" Url="http://docs.oracle.com/database/121/SQLRF/functions238.htm">UID returns an integer that uniquely identifies the session user (the user who logged on).</Function>
    <Function Name="UNISTR" Url="http://docs.oracle.com/database/121/SQLRF/functions239.htm">UNISTR takes as its argument a text literal or an expression that resolves to character data and returns it in the national character set. The national character set of the database can be either AL16UTF16 or UTF8. UNISTR provides support for Unicode string literals by letting you specify the Unicode encoding value of characters in the string. This is useful, for example, for inserting data into NCHAR columns.
The Unicode encoding value has the form '\xxxx' where 'xxxx' is the hexadecimal value of a character in UCS-2 encoding format. Supplementary characters are encoded as two code units, the first from the high-surrogates range (U+D800 to U+DBFF), and the second from the low-surrogates range (U+DC00 to U+DFFF). To include the backslash in the string itself, precede it with another backslash (\\).
For portability and data preservation, Oracle recommends that in the UNISTR string argument you specify only ASCII characters and the Unicode encoding values.</Function>
    <Function Name="UPDATEXML" Url="http://docs.oracle.com/database/121/SQLRF/functions240.htm">UPDATEXML takes as arguments an XMLType instance and an XPath-value pair and returns an XMLType instance with the updated value. If XPath_string is an XML element, then the corresponding value_expr must be an XMLType instance. If XPath_string is an attribute or text node, then the value_expr can be any scalar data type. You can specify an absolute XPath_string with an initial slash or a relative XPath_string by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node.
The data types of the target of each XPath_string and its corresponding value_expr must match. The optional namespace_string must resolve to a VARCHAR2 value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s).
If you update an XML element to null, then Oracle removes the attributes and children of the element, and the element becomes empty. If you update the text node of an element to null, Oracle removes the text value of the element, and the element itself remains but is empty.
In most cases, this function materializes an XML document in memory and updates the value. However, UPDATEXML is optimized for UPDATE statements on object-relational columns so that the function updates the value directly in the column. This optimization requires the following conditions:

The XMLType_instance must be the same as the column in the UPDATE ... SET clause.

The XPath_string must resolve to scalar content.</Function>
    <Function Name="UPPER" Url="http://docs.oracle.com/database/121/SQLRF/functions241.htm">UPPER returns char, with all letters uppercase. char can be any of the data types CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB. The return value is the same data type as char. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase, refer to NLS_UPPER.</Function>
    <Function Name="USER" Url="http://docs.oracle.com/database/121/SQLRF/functions242.htm">USER returns the name of the session user (the user who logged on). This may change during the duration of a database session as Real Application Security sessions are attached or detached. For enterprise users, this function returns the schema. For other users, it returns the database user name. If a Real Application Security session is currently attached to the database session, then it returns user XS$NULL.
This function returns a VARCHAR2 value.
Oracle Database compares values of this function with blank-padded comparison semantics.
In a distributed SQL statement, the UID and USER functions together identify the user on your local database. You cannot use these functions in the condition of a CHECK constraint.</Function>
    <Function Name="VALUE" Url="http://docs.oracle.com/database/121/SQLRF/functions244.htm">VALUE takes as its argument a correlation variable (table alias) associated with a row of an object table and returns object instances stored in the object table. The type of the object instances is the same type as the object table.</Function>
    <Function Name="VAR_POP" Url="http://docs.oracle.com/database/121/SQLRF/functions245.htm">VAR_POP returns the population variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="VAR_SAMP" Url="http://docs.oracle.com/database/121/SQLRF/functions246.htm">VAR_SAMP returns the sample variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="VARIANCE" Url="http://docs.oracle.com/database/121/SQLRF/functions247.htm">VARIANCE returns the variance of expr. You can use it as an aggregate or analytic function.
Oracle Database calculates the variance of expr as follows:

0 if the number of rows in expr = 1

VAR_SAMP if the number of rows in expr &gt; 1

If you specify DISTINCT, then you can specify only the query_partition_clause of the analytic_clause. The order_by_clause and windowing_clause are not allowed.
This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument.</Function>
    <Function Name="WIDTH_BUCKET" Url="http://docs.oracle.com/database/121/SQLRF/functions249.htm">WIDTH_BUCKET lets you construct equiwidth histograms, in which the histogram range is divided into intervals that have identical size. (Compare this function with NTILE, which creates equiheight histograms.) Ideally each bucket is a closed-open interval of the real number line. For example, a bucket can be assigned to scores between 10.00 and 19.999 ... to indicate that 10 is included in the interval and 20 is excluded. This is sometimes denoted [10, 20).
For a given expression, WIDTH_BUCKET returns the bucket number into which the value of this expression would fall after being evaluated.

expr is the expression for which the histogram is being created. This expression must evaluate to a numeric or datetime value or to a value that can be implicitly converted to a numeric or datetime value. If expr evaluates to null, then the expression returns null.

min_value and max_value are expressions that resolve to the end points of the acceptable range for expr. Both of these expressions must also evaluate to numeric or datetime values, and neither can evaluate to null.

num_buckets is an expression that resolves to a constant indicating the number of buckets. This expression must evaluate to a positive integer.


See Also:
Table 2-10, "Implicit Type Conversion Matrix" for more information on implicit conversion


When needed, Oracle Database creates an underflow bucket numbered 0 and an overflow bucket numbered num_buckets+1. These buckets handle values less than min_value and more than max_value and are helpful in checking the reasonableness of endpoints.</Function>
    <Function Name="VSIZE" Url="http://docs.oracle.com/database/121/SQLRF/functions248.htm">VSIZE returns the number of bytes in the internal representation of expr. If expr is null, then this function returns null.
This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.</Function>
    <Function Name="XMLAGG" Url="http://docs.oracle.com/database/121/SQLRF/functions250.htm">XMLAgg is an aggregate function. It takes a collection of XML fragments and returns an aggregated XML document. Any arguments that return null are dropped from the result.
XMLAgg is similar to SYS_XMLAgg except that XMLAgg returns a collection of nodes but it does not accept formatting using the XMLFormat object. Also, XMLAgg does not enclose the output in an element tag as does SYS_XMLAgg.
Within the order_by_clause, Oracle Database does not interpret number literals as column positions, as it does in other uses of this clause, but simply as number literals.</Function>
    <Function Name="XMLCAST" Url="http://docs.oracle.com/database/121/SQLRF/functions251.htm">XMLCast casts value_expression to the scalar SQL data type specified by datatype. The value_expression argument is a SQL expression that is evaluated. The datatype argument can be of data type NUMBER, VARCHAR2, CHAR, CLOB, BLOB, REF XMLTYPE, and any of the datetime data types.</Function>
    <Function Name="XMLCDATA" Url="http://docs.oracle.com/database/121/SQLRF/functions252.htm">XMLCData generates a CDATA section by evaluating value_expr. The value_expr must resolve to a string. The value returned by the function takes the following form:

&lt;![CDATA[string]]&gt;

If the resulting value is not a valid XML CDATA section, then the function returns an error.The following conditions apply to XMLCData:

The value_expr cannot contain the substring ]]&gt;.

If value_expr evaluates to null, then the function returns null.</Function>
    <Function Name="XMLCOLATTVAL" Url="http://docs.oracle.com/database/121/SQLRF/functions253.htm">XMLColAttVal creates an XML fragment and then expands the resulting XML so that each XML fragment has the name column with the attribute name.
You can use the AS clause to change the value of the name attribute to something other than the column name. You can do this by specifying c_alias, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the alias. The alias can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED. See "Extended Data Types" for more information.
You must specify a value for value_expr. If value_expr is null, then no element is returned.

Restriction on XMLColAttVal You cannot specify an object type column for value_expr.</Function>
    <Function Name="XMLCOMMENT" Url="http://docs.oracle.com/database/121/SQLRF/functions254.htm">XMLComment generates an XML comment using an evaluated result of value_expr. The value_expr must resolve to a string. It cannot contain two consecutive dashes (hyphens). The value returned by the function takes the following form:

&lt;!--string--&gt;

If value_expr resolves to null, then the function returns null.</Function>
    <Function Name="XMLCONCAT" Url="http://docs.oracle.com/database/121/SQLRF/functions255.htm">XMLConcat takes as input a series of XMLType instances, concatenates the series of elements for each row, and returns the concatenated series. XMLConcat is the inverse of XMLSequence.
Null expressions are dropped from the result. If all the value expressions are null, then the function returns null.</Function>
    <Function Name="XMLDIFF" Url="http://docs.oracle.com/database/121/SQLRF/functions256.htm">The XMLDiff function is the SQL interface for the XmlDiff C API. This function compares two XML documents and captures the differences in XML conforming to an Xdiff schema. The diff document is returned as an XMLType document.

For the first two arguments, specify the names of two XMLType documents.

For the integer, specify a number representing the hashLevel for a C function XmlDiff. If you do not want hashing, set this argument to 0 or omit it entirely. If you do not want hashing, but you want to specify flags, then you must set this argument to 0.

For string, specify the flags that control the behavior of the function. These flags are specified by one or more names separated by semicolon. The names are the same as the names of constants for XmlDiff function.</Function>
    <Function Name="XMLELEMENT" Url="http://docs.oracle.com/database/121/SQLRF/functions257.htm">XMLElement takes an element name for identifier or evaluates an element name for EVALNAME value_expr, an optional collection of attributes for the element, and arguments that make up the content of the element. It returns an instance of type XMLType. XMLElement is similar to SYS_XMLGen except that XMLElement can include attributes in the XML returned, but it does not accept formatting using the XMLFormat object.
The XMLElement function is typically nested to produce an XML document with a nested structure, as in the example in the following section.
For an explanation of the ENTITYESCAPING and NONENTITYESCAPING keywords, refer to Oracle XML DB Developer's Guide.
You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying identifier, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier does not have to be a column name or column reference. It cannot be an expression or null. It can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED.
The objects that make up the element content follow the XMLATTRIBUTES keyword. In the XML_attributes_clause, if the value_expr is null, then no attribute is created for that value expression. The type of value_expr cannot be an object type or collection. If you specify an alias for value_expr using the AS clause, then the c_alias or the evaluated value expression (EVALNAME value_expr) can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED.</Function>
    <Function Name="XMLEXISTS" Url="http://docs.oracle.com/database/121/SQLRF/functions258.htm">XMLExists checks whether a given XQuery expression returns a nonempty XQuery sequence. If so, the function returns TRUE; otherwise, it returns FALSE. The argument XQuery_string is a literal string, but it can contain XQuery variables that you bind using the XML_passing_clause.
The expr in the XML_passing_clause is an expression returning an XMLType or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one expr in the PASSING clause without an identifier. The result of evaluating each expr is bound to the corresponding identifier in the XQuery_string. If any expr that is not followed by an AS clause, then the result of evaluating that expression is used as the context item for evaluating the XQuery_string.</Function>
    <Function Name="XMLFOREST" Url="http://docs.oracle.com/database/121/SQLRF/functions259.htm">XMLForest converts each of its argument parameters to XML, and then returns an XML fragment that is the concatenation of these converted arguments.

If value_expr is a scalar expression, then you can omit the AS clause, and Oracle Database uses the column name as the element name.

If value_expr is an object type or collection, then the AS clause is mandatory, and Oracle uses the specified expression as the enclosing tag.
You can do this by specifying c_alias, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier does not have to be a column name or column reference. It cannot be an expression or null. It can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED. See "Extended Data Types" for more information.

If value_expr is null, then no element is created for that value_expr.</Function>
    <Function Name="XMLISVALID" Url="http://docs.oracle.com/database/121/SQLRF/functions260.htm">XMLISVALID checks whether the input XMLType_instance conforms to the relevant XML schema. It does not change the validation status recorded for XMLType_instance.
If the input XML document is determined to be valid, then XMLISVALID returns 1; otherwise, it returns 0. If you provide XMLSchema_URL as an argument, then that is used to check conformance. Otherwise, the XML schema specified by the XML document is used to check conformance.

XMLType_instance is the XMLType instance to be validated.

XMLSchema_URL is the URL of the XML schema against which to check conformance.

element is the element of the specified schema against which to check conformance. Use this if you have an XML schema that defines more than one top level element, and you want to check conformance against a specific one of those elements.</Function>
    <Function Name="XMLPARSE" Url="http://docs.oracle.com/database/121/SQLRF/functions261.htm">XMLParse parses and generates an XML instance from the evaluated result of value_expr. The value_expr must resolve to a string. If value_expr resolves to null, then the function returns null.

If you specify DOCUMENT, then value_expr must resolve to a singly rooted XML document.

If you specify CONTENT, then value_expr must resolve to a valid XML value.

When you specify WELLFORMED, you are guaranteeing that value_expr resolves to a well-formed XML document, so the database does not perform validity checks to ensure that the input is well formed.</Function>
    <Function Name="XMLPATCH" Url="http://docs.oracle.com/database/121/SQLRF/functions262.htm">The XMLPatch function is the SQL interface for the XmlPatch C API. This function patches an XML document with the changes specified. A patched XMLType document is returned.

For the first argument, specify the name of the input XMLType document.

For the second argument, specify the XMLType document containing the changes to be applied to the first document. The changes should conform to the Xdiff XML schema. You can supply the XML output from the Oracle XML Developer's Kit Java method diff().</Function>
    <Function Name="XMLPI" Url="http://docs.oracle.com/database/121/SQLRF/functions263.htm">XMLPI generates an XML processing instruction using identifier and optionally the evaluated result of value_expr. A processing instruction is commonly used to provide to an application information that is associated with all or part of an XML document. The application uses the processing instruction to determine how best to process the XML document.
You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying identifier, which is a string literal, or by specifying EVALNAME value_expr. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier does not have to be a column name or column reference. It cannot be an expression or null. It can be up to 4000 characters if the initialization parameter MAX_STRING_SIZE = STANDARD, and 32767 characters if MAX_STRING_SIZE = EXTENDED. See "Extended Data Types" for more information.
The optional value_expr must resolve to a string. If you omit the optional value_expr, then a zero-length string is the default. The value returned by the function takes this form:

&lt;?identifier string?&gt;

XMLPI is subject to the following restrictions:

The identifier must be a valid target for a processing instruction.

You cannot specify xml in any case combination for identifier.

The identifier cannot contain the consecutive characters ?&gt;.</Function>
    <Function Name="XMLQUERY" Url="http://docs.oracle.com/database/121/SQLRF/functions264.htm">XMLQUERY lets you query XML data in SQL statements. It takes an XQuery expression as a string literal, an optional context item, and other bind variables and returns the result of evaluating the XQuery expression using these input values.

XQuery_string is a complete XQuery expression, including prolog.

The expr in the XML_passing_clause is an expression returning an XMLType or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one expr in the PASSING clause without an identifier. The result of evaluating each expr is bound to the corresponding identifier in the XQuery_string. If any expr that is not followed by an AS clause, then the result of evaluating that expression is used as the context item for evaluating the XQuery_string.

RETURNING CONTENT indicates that the result from the XQuery evaluation is either an XML 1.0 document or a document fragment conforming to the XML 1.0 semantics.

If the result set is empty, then the function returns the SQL NULL value. The NULL ON EMPTY keywords are implemented by default and are shown for semantic clarity.</Function>
    <Function Name="XMLROOT" Url="http://docs.oracle.com/database/121/SQLRF/functions265.htm">XMLROOT lets you create a new XML value by providing version and standalone properties in the XML root information (prolog) of an existing XML value. If the value_expr already has a prolog, then the database returns an error. If the input is null, then the function returns null.
The value returned takes the following form:

&lt;?xml version = "version" [ STANDALONE = "{yes | no}" ]?&gt;


The first value_expr specifies the XML value for which you are providing prolog information.

In the VERSION clause, value_expr must resolve to a string representing a valid XML version. If you specify NO VALUE for VERSION, then the version defaults to 1.0.

If you omit the optional STANDALONE clause, or if you specify it with NO VALUE, then the standalone property is absent from the value returned by the function.</Function>
    <Function Name="XMLSEQUENCE" Url="http://docs.oracle.com/database/121/SQLRF/functions266.htm">XMLSequence has two forms:

The first form takes as input an XMLType instance and returns a varray of the top-level nodes in the XMLType. This form is effectively superseded by the SQL/XML standard function XMLTable, which provides for more readable SQL code. Prior to Oracle Database 10g Release 2, XMLSequence was used with SQL function TABLE to do some of what can now be done better with the XMLTable function.

The second form takes as input a REFCURSOR instance, with an optional instance of the XMLFormat object, and returns as an XMLSequence type an XML document for each row of the cursor.

Because XMLSequence returns a collection of XMLType, you can use this function in a TABLE clause to unnest the collection values into multiple rows, which can in turn be further processed in the SQL query.</Function>
    <Function Name="XMLSERIALIZE" Url="http://docs.oracle.com/database/121/SQLRF/functions267.htm">XMLSerialize creates a string or LOB containing the contents of value_expr.

If you specify DOCUMENT, then the value_expr must be a valid XML document.

If you specify CONTENT, then the value_expr need not be a singly rooted XML document. However it must be valid XML content.

The datatype specified can be a string type (VARCHAR2 or VARCHAR, but not NVARCHAR2), BLOB, or CLOB. The default is CLOB.

If datatype is BLOB, then you can specify the ENCODING clause to use the specified encoding in the prolog. The xml_encoding_spec is an XML encoding declaration (encoding="...").

Specify the VERSION clause to use the version you provide as string_literal in the XML declaration (&lt;?xml version="..." ...?&gt;).

Specify NO INDENT to strip all insignificant whitespace from the output. Specify INDENT SIZE = N, where N is a whole number, for output that is pretty-printed using a relative indentation of N spaces. If N is 0, then pretty-printing inserts a newline character after each element, placing each element on a line by itself, but omitting all other insignificant whitespace in the output. If INDENT is present without a SIZE specification, then 2-space indenting is used. If you omit this clause, then the behavior (pretty-printing or not) is indeterminate.

HIDE DEFAULTS and SHOW DEFAULTS apply only to XML schema-based data. If you specify SHOW DEFAULTS and the input data is missing any optional elements or attributes for which the XML schema defines default values, then those elements or attributes are included in the output with their default values. If you specify HIDE DEFAULTS, then no such elements or attributes are included in the output. HIDE DEFAULTS is the default behavior.</Function>
    <Function Name="XMLTABLE" Url="http://docs.oracle.com/database/121/SQLRF/functions268.htm">XMLTable maps the result of an XQuery evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL.

The XMLNAMESPACES clause contains a set of XML namespace declarations. These declarations are referenced by the XQuery expression (the evaluated XQuery_string), which computes the row, and by the XPath expression in the PATH clause of XML_table_column, which computes the columns for the entire XMLTable function. If you want to use qualified names in the PATH expressions of the COLUMNS clause, then you need to specify the XMLNAMESPACES clause.

XQuery_string is a literal string. It is a complete XQuery expression and can include prolog declarations. The value of XQuery_string serves as input to the XMLTable function; it is this XQuery result that is decomposed and stored as relational data.

The expr in the XML_passing_clause is an expression returning an XMLType or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one expr in the PASSING clause without an identifier. The result of evaluating each expr is bound to the corresponding identifier in the XQuery_string. If any expr that is not followed by an AS clause, then the result of evaluating that expression is used as the context item for evaluating the XQuery_string. This clause supports only passing by value, not passing by reference. Therefore, the BY VALUE keywords are optional and are provided for semantic clarity.

The optional RETURNING SEQUENCE BY REF clause causes the result of the XQuery evaluation to be returned by reference. This allows you to refer to any part of the source data in the XML_table_column clause.
If you omit this clause, then the result of the XQuery evaluation is returned by value. That is, a copy of the targeted nodes is returned instead of a reference to the actual nodes. In this case, you cannot refer to any data that is not in the returned copy in the XML_table_column clause. In particular, you cannot refer to data that precedes the targeted nodes in the source data.

The optional COLUMNS clause defines the columns of the virtual table to be created by XMLTable.

If you omit the COLUMNS clause, then XMLTable returns a row with a single XMLType pseudocolumn named COLUMN_VALUE.

FOR ORDINALITY specifies that column is to be a column of generated row numbers. There must be at most one FOR ORDINALITY clause. It is created as a NUMBER column.

For each resulting column except the FOR ORDINALITY column, you must specify the column data type, which can be XMLType or any other data type.
If the column data type is XMLType, then specify the XMLTYPE clause. If you specify the optional (SEQUENCE) BY REF clause, then a reference to the source data targeted by the PATH expression is returned as the column content. Otherwise, column contains a copy of that targeted data.
Returning the XMLType data by reference lets you specify other columns whose paths target nodes in the source data that are outside those targeted by the PATH expression for column.
If the column data type is any other data type, then specify datatype.

The optional PATH clause specifies that the portion of the XQuery result that is addressed by XQuery expression string is to be used as the column content.
If you omit PATH, then the XQuery expression column is assumed. For example:

XMLTable(... COLUMNS xyz)

is equivalent to

XMLTable(... COLUMNS xyz PATH 'XYZ')

You can use different PATH clauses to split the XQuery result into different virtual-table columns.

The optional DEFAULT clause specifies the value to use when the PATH expression results in an empty sequence. Its expr is an XQuery expression that is evaluated to produce the default value.</Function>
    <Function Name="XMLTRANSFORM" Url="http://docs.oracle.com/database/121/SQLRF/functions269.htm">XMLTransform takes as arguments an XMLType instance and an XSL style sheet, which is itself a form of XMLType instance. It applies the style sheet to the instance and returns an XMLType.
This function is useful for organizing data according to a style sheet as you are retrieving it from the database.</Function>
  </Functions>
  <Statements>
    <Statement Name="ADMINISTER KEY MANAGEMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_1003.htm" />
    <Statement Name="ALTER AUDIT POLICY" Url="http://docs.oracle.com/database/121/SQLRF/statements_1004.htm" />
    <Statement Name="ALTER CLUSTER" Url="http://docs.oracle.com/database/121/SQLRF/statements_1005.htm" />
    <Statement Name="ALTER DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_1006.htm" />
    <Statement Name="ALTER DATABASE LINK" Url="http://docs.oracle.com/database/121/SQLRF/statements_1007.htm" />
    <Statement Name="ALTER DIMENSION" Url="http://docs.oracle.com/database/121/SQLRF/statements_1008.htm" />
    <Statement Name="ALTER DISKGROUP" Url="http://docs.oracle.com/database/121/SQLRF/statements_1009.htm" />
    <Statement Name="ALTER FLASHBACK ARCHIVE" Url="http://docs.oracle.com/database/121/SQLRF/statements_1010.htm" />
    <Statement Name="ALTER FUNCTION" Url="http://docs.oracle.com/database/121/SQLRF/statements_1011.htm" />
    <Statement Name="ALTER INDEX" Url="http://docs.oracle.com/database/121/SQLRF/statements_1012.htm" />
    <Statement Name="ALTER INDEXTYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_1013.htm" />
    <Statement Name="ALTER JAVA" Url="http://docs.oracle.com/database/121/SQLRF/statements_1014.htm" />
    <Statement Name="ALTER LIBRARY" Url="http://docs.oracle.com/database/121/SQLRF/statements_2001.htm" />
    <Statement Name="ALTER MATERIALIZED VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_2002.htm" />
    <Statement Name="ALTER MATERIALIZED VIEW LOG" Url="http://docs.oracle.com/database/121/SQLRF/statements_2003.htm" />
    <Statement Name="ALTER MATERIALIZED ZONEMAP" Url="http://docs.oracle.com/database/121/SQLRF/statements_2004.htm" />
    <Statement Name="ALTER OPERATOR" Url="http://docs.oracle.com/database/121/SQLRF/statements_2005.htm" />
    <Statement Name="ALTER OUTLINE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2006.htm" />
    <Statement Name="ALTER PACKAGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2007.htm" />
    <Statement Name="ALTER PLUGGABLE DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2008.htm" />
    <Statement Name="ALTER PROCEDURE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2009.htm" />
    <Statement Name="ALTER PROFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2010.htm" />
    <Statement Name="ALTER RESOURCE COST" Url="http://docs.oracle.com/database/121/SQLRF/statements_2011.htm" />
    <Statement Name="ALTER ROLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2012.htm" />
    <Statement Name="ALTER ROLLBACK SEGMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_2013.htm" />
    <Statement Name="ALTER SEQUENCE" Url="http://docs.oracle.com/database/121/SQLRF/statements_2014.htm" />
    <Statement Name="ALTER SESSION" Url="http://docs.oracle.com/database/121/SQLRF/statements_2015.htm" />
    <Statement Name="ALTER SYNONYM" Url="http://docs.oracle.com/database/121/SQLRF/statements_2016.htm" />
    <Statement Name="ALTER SYSTEM" Url="http://docs.oracle.com/database/121/SQLRF/statements_2017.htm" />
    <Statement Name="ALTER TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_3001.htm" />
    <Statement Name="ALTER TABLESPACE" Url="http://docs.oracle.com/database/121/SQLRF/statements_3002.htm" />
    <Statement Name="ALTER TRIGGER" Url="http://docs.oracle.com/database/121/SQLRF/statements_4001.htm" />
    <Statement Name="ALTER TYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_4002.htm" />
    <Statement Name="ALTER USER" Url="http://docs.oracle.com/database/121/SQLRF/statements_4003.htm" />
    <Statement Name="ALTER VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_4004.htm" />
    <Statement Name="ANALYZE" Url="http://docs.oracle.com/database/121/SQLRF/statements_4005.htm" />
    <Statement Name="ASSOCIATE STATISTICS" Url="http://docs.oracle.com/database/121/SQLRF/statements_4006.htm" />
    <Statement Name="AUDIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_4007.htm" />
    <Statement Name="AUDIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_4008.htm" />
    <Statement Name="CALL" Url="http://docs.oracle.com/database/121/SQLRF/statements_4009.htm" />
    <Statement Name="COMMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_4010.htm" />
    <Statement Name="COMMIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_4011.htm" />
    <Statement Name="CREATE AUDIT POLICY" Url="http://docs.oracle.com/database/121/SQLRF/statements_5001.htm" />
    <Statement Name="CREATE CLUSTER" Url="http://docs.oracle.com/database/121/SQLRF/statements_5002.htm" />
    <Statement Name="CREATE CONTEXT" Url="http://docs.oracle.com/database/121/SQLRF/statements_5003.htm" />
    <Statement Name="CREATE CONTROLFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_5004.htm" />
    <Statement Name="CREATE DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_5005.htm" />
    <Statement Name="CREATE DATABASE LINK" Url="http://docs.oracle.com/database/121/SQLRF/statements_5006.htm" />
    <Statement Name="CREATE DIMENSION" Url="http://docs.oracle.com/database/121/SQLRF/statements_5007.htm" />
    <Statement Name="CREATE DIRECTORY" Url="http://docs.oracle.com/database/121/SQLRF/statements_5008.htm" />
    <Statement Name="CREATE DISKGROUP" Url="http://docs.oracle.com/database/121/SQLRF/statements_5009.htm" />
    <Statement Name="CREATE EDITION" Url="http://docs.oracle.com/database/121/SQLRF/statements_5010.htm" />
    <Statement Name="CREATE FLASHBACK ARCHIVE" Url="http://docs.oracle.com/database/121/SQLRF/statements_5011.htm" />
    <Statement Name="CREATE FUNCTION" Url="http://docs.oracle.com/database/121/SQLRF/statements_5012.htm" />
    <Statement Name="CREATE INDEX" Url="http://docs.oracle.com/database/121/SQLRF/statements_5013.htm" />
    <Statement Name="CREATE INDEXTYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_5014.htm" />
    <Statement Name="CREATE JAVA" Url="http://docs.oracle.com/database/121/SQLRF/statements_5015.htm" />
    <Statement Name="CREATE LIBRARY" Url="http://docs.oracle.com/database/121/SQLRF/statements_6001.htm" />
    <Statement Name="CREATE MATERIALIZED VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_6002.htm" />
    <Statement Name="CREATE MATERIALIZED VIEW LOG" Url="http://docs.oracle.com/database/121/SQLRF/statements_6003.htm" />
    <Statement Name="CREATE MATERIALIZED ZONEMAP" Url="http://docs.oracle.com/database/121/SQLRF/statements_6004.htm" />
    <Statement Name="CREATE OPERATOR" Url="http://docs.oracle.com/database/121/SQLRF/statements_6005.htm" />
    <Statement Name="CREATE OUTLINE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6006.htm" />
    <Statement Name="CREATE PACKAGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6007.htm" />
    <Statement Name="CREATE PACKAGE BODY" Url="http://docs.oracle.com/database/121/SQLRF/statements_6008.htm" />
    <Statement Name="CREATE PFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6009.htm" />
    <Statement Name="CREATE PLUGGABLE DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6010.htm" />
    <Statement Name="CREATE PROCEDURE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6011.htm" />
    <Statement Name="CREATE PROFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6012.htm" />
    <Statement Name="CREATE RESTORE POINT" Url="http://docs.oracle.com/database/121/SQLRF/statements_6013.htm" />
    <Statement Name="CREATE ROLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6014.htm" />
    <Statement Name="CREATE ROLLBACK SEGMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_6015.htm" />
    <Statement Name="CREATE SCHEMA" Url="http://docs.oracle.com/database/121/SQLRF/statements_6016.htm" />
    <Statement Name="CREATE SEQUENCE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6017.htm" />
    <Statement Name="CREATE SPFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_6018.htm" />
    <Statement Name="CREATE SYNONYM" Url="http://docs.oracle.com/database/121/SQLRF/statements_7001.htm" />
    <Statement Name="CREATE TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_7002.htm" />
    <Statement Name="CREATE TABLESPACE" Url="http://docs.oracle.com/database/121/SQLRF/statements_7003.htm" />
    <Statement Name="CREATE TRIGGER" Url="http://docs.oracle.com/database/121/SQLRF/statements_7004.htm" />
    <Statement Name="CREATE TYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8001.htm" />
    <Statement Name="CREATE TYPE BODY" Url="http://docs.oracle.com/database/121/SQLRF/statements_8002.htm" />
    <Statement Name="CREATE USER" Url="http://docs.oracle.com/database/121/SQLRF/statements_8003.htm" />
    <Statement Name="CREATE VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_8004.htm" />
    <Statement Name="DELETE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8005.htm" />
    <Statement Name="DISASSOCIATE STATISTICS" Url="http://docs.oracle.com/database/121/SQLRF/statements_8006.htm" />
    <Statement Name="DROP AUDIT POLICY" Url="http://docs.oracle.com/database/121/SQLRF/statements_8007.htm" />
    <Statement Name="DROP CLUSTER" Url="http://docs.oracle.com/database/121/SQLRF/statements_8008.htm" />
    <Statement Name="DROP CONTEXT" Url="http://docs.oracle.com/database/121/SQLRF/statements_8009.htm" />
    <Statement Name="DROP DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8010.htm" />
    <Statement Name="DROP DATABASE LINK" Url="http://docs.oracle.com/database/121/SQLRF/statements_8011.htm" />
    <Statement Name="DROP DIMENSION" Url="http://docs.oracle.com/database/121/SQLRF/statements_8012.htm" />
    <Statement Name="DROP DIRECTORY" Url="http://docs.oracle.com/database/121/SQLRF/statements_8013.htm" />
    <Statement Name="DROP DISKGROUP" Url="http://docs.oracle.com/database/121/SQLRF/statements_8014.htm" />
    <Statement Name="DROP EDITION" Url="http://docs.oracle.com/database/121/SQLRF/statements_8015.htm" />
    <Statement Name="DROP FLASHBACK ARCHIVE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8016.htm" />
    <Statement Name="DROP FUNCTION" Url="http://docs.oracle.com/database/121/SQLRF/statements_8017.htm" />
    <Statement Name="DROP INDEX" Url="http://docs.oracle.com/database/121/SQLRF/statements_8018.htm" />
    <Statement Name="DROP INDEXTYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8019.htm" />
    <Statement Name="DROP JAVA" Url="http://docs.oracle.com/database/121/SQLRF/statements_8020.htm" />
    <Statement Name="DROP LIBRARY" Url="http://docs.oracle.com/database/121/SQLRF/statements_8021.htm" />
    <Statement Name="DROP MATERIALIZED VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_8022.htm" />
    <Statement Name="DROP MATERIALIZED VIEW LOG" Url="http://docs.oracle.com/database/121/SQLRF/statements_8023.htm" />
    <Statement Name="DROP MATERIALIZED ZONEMAP" Url="http://docs.oracle.com/database/121/SQLRF/statements_8024.htm" />
    <Statement Name="DROP OPERATOR" Url="http://docs.oracle.com/database/121/SQLRF/statements_8025.htm" />
    <Statement Name="DROP OUTLINE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8026.htm" />
    <Statement Name="DROP PACKAGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8027.htm" />
    <Statement Name="DROP PLUGGABLE DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8028.htm" />
    <Statement Name="DROP PROCEDURE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8029.htm" />
    <Statement Name="DROP PROFILE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8030.htm" />
    <Statement Name="DROP RESTORE POINT" Url="http://docs.oracle.com/database/121/SQLRF/statements_8031.htm" />
    <Statement Name="DROP ROLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_8032.htm" />
    <Statement Name="DROP ROLLBACK SEGMENT" Url="http://docs.oracle.com/database/121/SQLRF/statements_8033.htm" />
    <Statement Name="DROP SEQUENCE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9001.htm" />
    <Statement Name="DROP SYNONYM" Url="http://docs.oracle.com/database/121/SQLRF/statements_9002.htm" />
    <Statement Name="DROP TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9003.htm" />
    <Statement Name="DROP TABLESPACE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9004.htm" />
    <Statement Name="DROP TRIGGER" Url="http://docs.oracle.com/database/121/SQLRF/statements_9005.htm" />
    <Statement Name="DROP TYPE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9006.htm" />
    <Statement Name="DROP TYPE BODY" Url="http://docs.oracle.com/database/121/SQLRF/statements_9007.htm" />
    <Statement Name="DROP USER" Url="http://docs.oracle.com/database/121/SQLRF/statements_9008.htm" />
    <Statement Name="DROP VIEW" Url="http://docs.oracle.com/database/121/SQLRF/statements_9009.htm" />
    <Statement Name="EXPLAIN PLAN" Url="http://docs.oracle.com/database/121/SQLRF/statements_9010.htm" />
    <Statement Name="FLASHBACK DATABASE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9011.htm" />
    <Statement Name="FLASHBACK TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9012.htm" />
    <Statement Name="GRANT" Url="http://docs.oracle.com/database/121/SQLRF/statements_9013.htm" />
    <Statement Name="INSERT" Url="http://docs.oracle.com/database/121/SQLRF/statements_9014.htm" />
    <Statement Name="LOCK TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9015.htm" />
    <Statement Name="MERGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9016.htm" />
    <Statement Name="NOAUDIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_9017.htm" />
    <Statement Name="NOAUDIT" Url="http://docs.oracle.com/database/121/SQLRF/statements_9018.htm" />
    <Statement Name="PURGE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9019.htm" />
    <Statement Name="RENAME" Url="http://docs.oracle.com/database/121/SQLRF/statements_9020.htm" />
    <Statement Name="REVOKE" Url="http://docs.oracle.com/database/121/SQLRF/statements_9021.htm" />
    <Statement Name="ROLLBACK" Url="http://docs.oracle.com/database/121/SQLRF/statements_9022.htm" />
    <Statement Name="SAVEPOINT" Url="http://docs.oracle.com/database/121/SQLRF/statements_10001.htm" />
    <Statement Name="SELECT" Url="http://docs.oracle.com/database/121/SQLRF/statements_10002.htm" />
    <Statement Name="SET CONSTRAINT" Url="http://docs.oracle.com/database/121/SQLRF/statements_10003.htm" />
    <Statement Name="SET CONSTRAINTS" Url="http://docs.oracle.com/database/121/SQLRF/statements_10003.htm" />
    <Statement Name="SET ROLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_10004.htm" />
    <Statement Name="SET TRANSACTION" Url="http://docs.oracle.com/database/121/SQLRF/statements_10005.htm" />
    <Statement Name="TRUNCATE CLUSTER" Url="http://docs.oracle.com/database/121/SQLRF/statements_10006.htm" />
    <Statement Name="TRUNCATE TABLE" Url="http://docs.oracle.com/database/121/SQLRF/statements_10007.htm" />
    <Statement Name="UPDATE" Url="http://docs.oracle.com/database/121/SQLRF/statements_10008.htm" />
  </Statements>
  <Packages>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ADDM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_addm.htm">
      <Description>The DBMS_ADDM package facilitates the use of Advisor functionality regarding the Automatic Database Diagnostic Monitor.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ANALYZE_DB&quot;" ElementId="#CACECAHI">Creates an ADDM task for analyzing in database analysis mode and executes it</SubProgram>
        <SubProgram Name="&quot;ANALYZE_INST&quot;" ElementId="#CACHCIHE">Creates an ADDM task for analyzing in instance analysis mode and executes it.</SubProgram>
        <SubProgram Name="&quot;ANALYZE_PARTIAL&quot;" ElementId="#CACEDJDH">Creates an ADDM task for analyzing a subset of instances in partial analysis mode and executes it</SubProgram>
        <SubProgram Name="&quot;COMPARE_CAPTURE_REPLAY_REPORT&quot;" ElementId="#CIABGAAI">Produces a Compare Period ADDM report comparing the performance of a capture to a replay</SubProgram>
        <SubProgram Name="&quot;COMPARE_DATABASES&quot;" ElementId="#CIAJABBF">Produces a Compare Period ADDM report for a database-wide performance comparison</SubProgram>
        <SubProgram Name="&quot;COMPARE_INSTANCES&quot;" ElementId="#CIAIBHCB">Produces a Compare Period ADDM report for an instance-level performance comparison</SubProgram>
        <SubProgram Name="&quot;COMPARE_REPLAY_REPLAY_REPORT&quot;" ElementId="#CIADBCJD">Produces a Compare Period ADDM report comparing the performance of a replay to another replay</SubProgram>
        <SubProgram Name="&quot;DELETE&quot;" ElementId="#CACIBFDB">Deletes an already created ADDM task (of any kind)</SubProgram>
        <SubProgram Name="&quot;DELETE_FINDING_DIRECTIVE&quot;" ElementId="#CACHFIJC">Deletes a finding directive</SubProgram>
        <SubProgram Name="&quot;DELETE_PARAMETER_DIRECTIVE&quot;" ElementId="#CACBBIJJ">Deletes a parameter directive</SubProgram>
        <SubProgram Name="&quot;DELETE_SEGMENT_DIRECTIVE&quot;" ElementId="#CACGDEED">Deletes a segment directive</SubProgram>
        <SubProgram Name="&quot;DELETE_SQL_DIRECTIVE&quot;" ElementId="#CACGGBBF">Deletes a SQL directive</SubProgram>
        <SubProgram Name="&quot;GET_ASH_QUERY&quot;" ElementId="#CIAGBAFE">Returns a string containing the SQL text of an ASH query identifying the rows in ASH with impact for the finding</SubProgram>
        <SubProgram Name="&quot;GET_REPORT&quot;" ElementId="#CACJDCBJ">Retrieves the default text report of an executed ADDM task</SubProgram>
        <SubProgram Name="&quot;INSERT_FINDING_DIRECTIVE&quot;" ElementId="#CACBDJAI">Creates a directive to limit reporting of a specific finding type.</SubProgram>
        <SubProgram Name="&quot;INSERT_PARAMETER_DIRECTIVE&quot;" ElementId="#CACIFJED">Creates a directive to prevent ADDM from creating actions to alter the value of a specific system parameter</SubProgram>
        <SubProgram Name="&quot;INSERT_SEGMENT_DIRECTIVE&quot;" ElementId="#CACECFCJ">Creates a directive to prevent ADDM from creating actions to "run Segment Advisor" for specific segments</SubProgram>
        <SubProgram Name="&quot;INSERT_SQL_DIRECTIVE&quot;" ElementId="#CACGEACB">Creates a directive to limit reporting of actions on specific SQL</SubProgram>
        <SubProgram Name="&quot;REAL_TIME_ADDM_REPORT&quot;" ElementId="#BABFHEEH">Produces a real-time report of ADDM activity</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ADVANCED_REWRITE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_advrwr.htm">
      <Description>DBMS_ADVANCED_REWRITE contains interfaces for advanced query rewrite users. Using this package, you can create, drop, and maintain functional equivalence declarations for query rewrite.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ALTER_REWRITE_EQUIVALENCE&quot;" ElementId="#i999545">Changes the mode of the rewrite equivalence declaration to the mode you specify</SubProgram>
        <SubProgram Name="&quot;BUILD_SAFE_REWRITE_EQUIVALENCE&quot;" ElementId="#CFAGJHJB">Enables the rewrite of top-level materialized views using submaterialized views. Oracle Corporation does not recommend you directly use this procedure</SubProgram>
        <SubProgram Name="&quot;DECLARE_REWRITE_EQUIVALENCE&quot;" ElementId="#CFAJDGBJ">Creates a declaration indicating that source_stmt is functionally equivalent to destination_stmt for as long as the equivalence declaration remains enabled, and that destination_stmt is more favorable in terms of performance</SubProgram>
        <SubProgram Name="&quot;DROP_REWRITE_EQUIVALENCE&quot;" ElementId="#i998647">Drops the specified rewrite equivalence declaration</SubProgram>
        <SubProgram Name="&quot;VALIDATE_REWRITE_EQUIVALENCE&quot;" ElementId="#i998649">Validates the specified rewrite equivalence declaration using the same validation method as described with the validate parameter</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ADVISOR&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_advis.htm">
      <Description>DBMS_ADVISOR is part of the server manageability suite of advisors, a set of expert systems that identifies and helps resolve performance problems relating to database server components.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ALERT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_alert.htm">
      <Description>DBMS_ALERT supports asynchronous notification of database events (alerts). By appropriate use of this package and database triggers, an application can notify itself whenever values of interest in the database are changed.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_APP_CONT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_app_cont.htm">
      <Description>The DBMS_APP_CONT package provides an interface to determine if the in-flight transaction on a now unavailable session committed or not, and if the last call on that session completed or not.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GET_LTXID_OUTCOME&quot;" ElementId="#BABHFHDG">Lets customer applications and third party application servers determine the transactional status of the last session when that session becomes unavailable.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_APPLICATION_INFO&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_appinf.htm">
      <Description>Application developers can use the DBMS_APPLICATION_INFO package with Oracle Trace and the SQL trace facility to record names of executing modules or transactions in the database for later use when tracking the performance of various modules and debugging.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;READ_CLIENT_INFO&quot;" ElementId="#BABCHFIH">Reads the value of the client_info field of the current session</SubProgram>
        <SubProgram Name="&quot;READ_MODULE&quot;" ElementId="#i999292">Reads the values of the module and action fields of the current session</SubProgram>
        <SubProgram Name="&quot;SET_ACTION&quot;" ElementId="#i999254">Sets the name of the current action within the current module</SubProgram>
        <SubProgram Name="&quot;SET_CLIENT_INFO&quot;" ElementId="#CHEJCFGG">Sets the client_info field of the session</SubProgram>
        <SubProgram Name="&quot;SET_MODULE&quot;" ElementId="#i996826">Sets the name of the module that is currently running to a new module</SubProgram>
        <SubProgram Name="&quot;SET_SESSION_LONGOPS&quot;" ElementId="#i996999">Sets a row in the V$SESSION_LONGOPS table</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_AQ&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_aq.htm">
      <Description>The DBMS_AQ package provides an interface to Oracle Streams Advanced Queuing (AQ).</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BIND_AGENT&quot;" ElementId="#i1001600">Creates an entry for an Oracle Database Advanced Queuing agent in the LDAP directory</SubProgram>
        <SubProgram Name="&quot;DEQUEUE&quot;" ElementId="#i1000252">Dequeues a message from the specified queue</SubProgram>
        <SubProgram Name="&quot;DEQUEUE_ARRAY&quot;" ElementId="#i1000850">Dequeues an array of messages from the specified queue</SubProgram>
        <SubProgram Name="&quot;ENQUEUE&quot;" ElementId="#i1001648">Adds a message to the specified queue</SubProgram>
        <SubProgram Name="&quot;ENQUEUE_ARRAY&quot;" ElementId="#i1001754">Adds an array of messages to the specified queue</SubProgram>
        <SubProgram Name="&quot;LISTEN&quot;" ElementId="#i997325">Listen to one or more queues on behalf of a list of agents</SubProgram>
        <SubProgram Name="&quot;POST&quot;" ElementId="#i1001949">Posts to a anonymous subscription which allows all clients who are registered for the subscription to get notifications</SubProgram>
        <SubProgram Name="&quot;REGISTER&quot;" ElementId="#i997366">Registers for message notifications</SubProgram>
        <SubProgram Name="&quot;UNBIND_AGENT&quot;" ElementId="#i1001993">Removes an entry for an Oracle Database Advanced Queuing agent from the LDAP directory</SubProgram>
        <SubProgram Name="&quot;UNREGISTER&quot;" ElementId="#CBACHAFB">Unregisters a subscription which turns off notification</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_AQADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_aqadm.htm">
      <Description>The DBMS_AQADM package provides procedures to manage Oracle Database Advanced Queuing (AQ) configuration and administration information.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_ALIAS_TO_LDAP&quot;" ElementId="#i1016021">Creates an alias for a queue, agent, or a JMS ConnectionFactory in LDAP</SubProgram>
        <SubProgram Name="&quot;ADD_SUBSCRIBER&quot;" ElementId="#i1015125">Adds a default subscriber to a queue</SubProgram>
        <SubProgram Name="&quot;ALTER_AQ_AGENT&quot;" ElementId="#CACDGDCB">Alters an agent registered for Oracle Database Advanced Queuing Internet access, and an Oracle Database Advanced Queuing agent that accesses secure queues</SubProgram>
        <SubProgram Name="&quot;ALTER_PROPAGATION_SCHEDULE&quot;" ElementId="#i1015375">Alters parameters for a propagation schedule</SubProgram>
        <SubProgram Name="&quot;ALTER_QUEUE&quot;" ElementId="#i1014785">Alters existing properties of a queue</SubProgram>
        <SubProgram Name="&quot;ALTER_QUEUE_TABLE&quot;" ElementId="#i1014529">Alters the existing properties of a queue table</SubProgram>
        <SubProgram Name="&quot;ALTER_SUBSCRIBER&quot;" ElementId="#i1015198">Alters existing properties of a subscriber to a specified queue</SubProgram>
        <SubProgram Name="&quot;CREATE_AQ_AGENT&quot;" ElementId="#i1015539">Registers an agent for Oracle Database Advanced Queuing Internet access using HTTP/SMTP protocols, and creates an Oracle Database Advanced Queuing agent to access secure queues</SubProgram>
        <SubProgram Name="&quot;CREATE_NP_QUEUE&quot;" ElementId="#i1014730">Creates a nonpersistent RAW queue</SubProgram>
        <SubProgram Name="&quot;CREATE_QUEUE&quot;" ElementId="#i1015639">Creates a queue in the specified queue table</SubProgram>
        <SubProgram Name="&quot;CREATE_SHARDED_QUEUE&quot;" ElementId="#CHDEDBEF">Creates a queue and its queue table for a sharded queue all together.</SubProgram>
        <SubProgram Name="&quot;CREATE_QUEUE_TABLE&quot;" ElementId="#i1014381">Creates a queue table for messages of a predefined type</SubProgram>
        <SubProgram Name="&quot;DROP_SHARDED_QUEUE&quot;" ElementId="#BABBGHGI">Drops an existing sharded queue from the database queuing system</SubProgram>
        <SubProgram Name="&quot;DEL_ALIAS_FROM_LDAP&quot;" ElementId="#i1016072">Drops an alias for a queue, agent, or JMS ConnectionFactory in LDAP</SubProgram>
        <SubProgram Name="&quot;DISABLE_DB_ACCESS&quot;" ElementId="#i1015964">Revokes the privileges of a specific database user from an Oracle Database Advanced Queuing Internet agent</SubProgram>
        <SubProgram Name="&quot;DISABLE_PROPAGATION_SCHEDULE&quot;" ElementId="#i1015488">Disables a propagation schedule</SubProgram>
        <SubProgram Name="&quot;DROP_AQ_AGENT&quot;" ElementId="#i1015851">Drops an agent that was previously registered for Oracle Database Advanced Queuing Internet access</SubProgram>
        <SubProgram Name="&quot;DROP_QUEUE&quot;" ElementId="#i1014867">Drops an existing queue</SubProgram>
        <SubProgram Name="&quot;DROP_QUEUE_TABLE&quot;" ElementId="#i1011453">Drops an existing queue table</SubProgram>
        <SubProgram Name="&quot;ENABLE_DB_ACCESS&quot;" ElementId="#i1015894">Grants an Oracle Database Advanced Queuing Internet agent the privileges of a specific database user</SubProgram>
        <SubProgram Name="&quot;ENABLE_JMS_TYPES&quot;" ElementId="#i1016404">A precondition for the enqueue of JMS types and XML types</SubProgram>
        <SubProgram Name="&quot;ENABLE_PROPAGATION_SCHEDULE&quot;" ElementId="#i1015435">Enables a previously disabled propagation schedule</SubProgram>
        <SubProgram Name="&quot;GET_WATERMARK&quot;" ElementId="#BABDIFDJ">Retrieves the value of watermark set by the SET_WATERMARK Procedure</SubProgram>
        <SubProgram Name="&quot;GET_MAX_STREAMS_POOL&quot;" ElementId="#i1016831">Retrieves the value of Oracle Database Advanced Queuing maximum streams pool memory limit</SubProgram>
        <SubProgram Name="&quot;GET_MIN_STREAMS_POOL&quot;" ElementId="#BABFEFIJ">Retrieves the value of Oracle Database Advanced Queuing minimum streams pool memory limit</SubProgram>
        <SubProgram Name="&quot;GRANT_QUEUE_PRIVILEGE&quot;" ElementId="#i1014966">Grants privileges on a queue to users and roles</SubProgram>
        <SubProgram Name="&quot;GRANT_SYSTEM_PRIVILEGE&quot;" ElementId="#i1014912">Grants Oracle Database Advanced Queuing system privileges to users and roles</SubProgram>
        <SubProgram Name="&quot;MIGRATE_QUEUE_TABLE&quot;" ElementId="#i1014582">Upgrades an 8.0-compatible queue table to an 8.1-compatible or higher queue table, or downgrades an 8.1-compatible or higher queue table to an 8.0-compatible queue table</SubProgram>
        <SubProgram Name="&quot;PURGE_QUEUE_TABLE&quot;" ElementId="#i1014013">Purges messages from queue tables</SubProgram>
        <SubProgram Name="&quot;QUEUE_SUBSCRIBERS&quot;" ElementId="#i1016768">Returns the subscribers to an 8.0-compatible multiconsumer queue in the PL/SQL index by table collection type DBMS_AQADM.AQ$_subscriber_list_t</SubProgram>
        <SubProgram Name="&quot;REMOVE_SUBSCRIBER&quot;" ElementId="#i1015258">Removes a default subscriber from a queue</SubProgram>
        <SubProgram Name="&quot;REVOKE_QUEUE_PRIVILEGE&quot;" ElementId="#i1015021">Revokes privileges on a queue from users and roles</SubProgram>
        <SubProgram Name="&quot;REVOKE_SYSTEM_PRIVILEGE&quot;" ElementId="#i1015074">Revokes Oracle Database Advanced Queuing system privileges from users and roles</SubProgram>
        <SubProgram Name="&quot;SCHEDULE_PROPAGATION&quot;" ElementId="#i1015306">Schedules propagation of messages from a queue to a destination identified by a specific database link</SubProgram>
        <SubProgram Name="&quot;SET_WATERMARK&quot;" ElementId="#BABBJFJA">Used for Oracle Database Advanced Queuing notification to specify and limit memory use</SubProgram>
        <SubProgram Name="&quot;SET_MAX_STREAMS_POOL&quot;" ElementId="#i1016938">Used for Oracle Database Advanced Queuing to specify and limit maximum streams pool memory use</SubProgram>
        <SubProgram Name="&quot;SET_MIN_STREAMS_POOL&quot;" ElementId="#BABFJBAH">used for Oracle Database Advanced Queuing to specify and limit minimum streams pool memory use</SubProgram>
        <SubProgram Name="&quot;START_QUEUE&quot;" ElementId="#i1011806">Enables the specified queue for enqueuing or dequeuing</SubProgram>
        <SubProgram Name="&quot;STOP_QUEUE&quot;" ElementId="#i1011844">Disables enqueuing or dequeuing on the specified queue</SubProgram>
        <SubProgram Name="&quot;UNSCHEDULE_PROPAGATION&quot;" ElementId="#i1014138">Unschedules previously scheduled propagation of messages from a queue to a destination identified by a specific database link</SubProgram>
        <SubProgram Name="&quot;VERIFY_QUEUE_TYPES&quot;" ElementId="#i1012328">Verifies that the source and destination queues have identical types</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_AQELM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_aqelm.htm">
      <Description>The DBMS_AQELM package provides subprograms to manage the configuration of Oracle Streams Advanced Queuing (AQ) asynchronous notification by e-mail and HTTP.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_AQIN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_aquin.htm">
      <Description>The DBMS_AQIN package plays a part in providing secure access to the Oracle JMS interfaces.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ASSERT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_assert.htm">
      <Description>The DBMS_ASSERT package provides an interface to validate properties of the input value.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_AUDIT_MGMT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_audit_mgmt.htm">
      <Description>The DBMS_AUDIT_MGMT package provides subprograms to manage audit trail records. These subprograms enable audit administrators to manage the audit trail. In a mixed-mode environment, these audit trails comprise the database, operating system (OS), and XML audit trails. In a unified auditing environment, this comprises the unified audit trail.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLEAN_AUDIT_TRAIL&quot;" ElementId="#BABIAEAH">Deletes audit trail records that have been archived</SubProgram>
        <SubProgram Name="&quot;CLEAR_AUDIT_TRAIL_PROPERTY&quot;" ElementId="#BABHFBJG">Clears the value for the audit trail property that you specify</SubProgram>
        <SubProgram Name="&quot;CLEAR_LAST_ARCHIVE_TIMESTAMP&quot;" ElementId="#BABFJEAI">Clears the timestamp set by the SET_LAST_ARCHIVE_TIMESTAMP Procedure</SubProgram>
        <SubProgram Name="&quot;CREATE_PURGE_JOB&quot;" ElementId="#BABFJHCB">Creates a purge job for periodically deleting the audit trail records</SubProgram>
        <SubProgram Name="&quot;DEINIT_CLEANUP&quot;" ElementId="#BABGCGDD">Undoes the setup and initialization performed by the INIT_CLEANUP Procedure</SubProgram>
        <SubProgram Name="&quot;DROP_OLD_UNIFIED_AUDIT_TABLES&quot;" ElementId="#BABGHBCB">Drops old unified audit tables following the cloning of a pluggable database (PDB)</SubProgram>
        <SubProgram Name="&quot;DROP_PURGE_JOB&quot;" ElementId="#BABGIHAG">Drops the purge job created using the CREATE_PURGE_JOB Procedure</SubProgram>
        <SubProgram Name="&quot;FLUSH_UNIFIED_AUDIT_TRAIL&quot;" ElementId="#BABBFBHG">Writes the unified audit trail records in the SGA queue to disk</SubProgram>
        <SubProgram Name="&quot;GET_AUDIT_COMMIT_DELAY&quot;" ElementId="#BABGGHGG">Returns the audit commit delay time as the number of seconds. This is the maximum time that it takes to COMMIT an audit record to the database audit trail.</SubProgram>
        <SubProgram Name="&quot;GET_&quot;" ElementId="#BABHEHDC">Returns the property value set by the SET_AUDIT_TRAIL_PROPERTY Procedure</SubProgram>
        <SubProgram Name="&quot;GET_LAST_ARCHIVE_TIMESTAMP&quot;" ElementId="#BABGIGDC">Returns the timestamp set by the SET_LAST_ARCHIVE_TIMESTAMP Procedure in that database instance</SubProgram>
        <SubProgram Name="&quot;INIT_CLEANUP&quot;" ElementId="#BABFHEFH">Sets up the audit management infrastructure and sets a default cleanup interval for audit trail records</SubProgram>
        <SubProgram Name="&quot;IS_CLEANUP_INITIALIZED&quot;" ElementId="#BABDGBCC">Checks to see if the INIT_CLEANUP Procedure has been run for an audit trail type</SubProgram>
        <SubProgram Name="&quot;LOAD_UNIFIED_AUDIT_FILES&quot;" ElementId="#BABEJFEA">Loads the data from the spillover OS audit files in a unified audit trail into the designated unified audit trail tablespace</SubProgram>
        <SubProgram Name="&quot;SET_AUDIT_TRAIL_LOCATION&quot;" ElementId="#BABDAHBG">Moves the audit trail tables from their current tablespace to a user-specified tablespace</SubProgram>
        <SubProgram Name="&quot;SET_AUDIT_TRAIL_PROPERTY&quot;" ElementId="#BABBBBJE">Sets the audit trail properties for the audit trail type that you specify</SubProgram>
        <SubProgram Name="&quot;SET_LAST_ARCHIVE_TIMESTAMP&quot;" ElementId="#BABBHHGC">Sets a timestamp indicating when the audit records were last archived</SubProgram>
        <SubProgram Name="&quot;SET_PURGE_JOB_INTERVAL&quot;" ElementId="#BABFJBGE">Sets the interval at which the CLEAN_AUDIT_TRAIL Procedure is called for the purge job that you specify</SubProgram>
        <SubProgram Name="&quot;SET_PURGE_JOB_STATUS&quot;" ElementId="#BABGDFAJ">Enables or disables the purge job that you specify</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_AUTO_REPORT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_auto_report.htm">
      <Description>The DBMS_AUTO_REPORT package provides an interface to view SQL Monitoring and Real-time Automatic Database Diagnostic Monitor (ADDM) data that has been captured into Automatic Workload Repository (AWR). It also provides subprograms to control the behavior of how these data are captured to AWR.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;FINISH_REPORT_CAPTURE&quot;" ElementId="#CIHIEBDI">Ends the complete capture of SQL monitor data that was started with the START_REPORT_CAPTURE Procedure.</SubProgram>
        <SubProgram Name="&quot;REPORT_REPOSITORY_DETAIL&quot;" ElementId="#CIHHCIDJ">Obtains the stored report for a given report ID</SubProgram>
        <SubProgram Name="&quot;REPORT_REPOSITORY_DETAIL_XML&quot;" ElementId="#CIHEBHCC">Obtains the stored XML report for a given report ID</SubProgram>
        <SubProgram Name="&quot;REPORT_REPOSITORY_LIST_XML&quot;" ElementId="#CIHICHEB">Obtains an XML report of the list of SQL Monitor and Real-time ADDM data captured in AWR</SubProgram>
        <SubProgram Name="&quot;START_REPORT_CAPTURE&quot;" ElementId="#CIHCGDDG">Captures SQL monitor data of any newly monitored SQLs every minute since the last run of the capture cycle, and stores it in AWR.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_AUTO_SQLTUNE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_autosta.htm">
      <Description>The DBMS_AUTO_SQLTUNE package is the interface for managing the Automatic SQL Tuning task. Unlike DBMS_SQLTUNE, the DBMS_AUTO_SQLTUNE package requires the DBA role.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_AUTO_TASK_ADMIN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_autotaskadm.htm">
      <Description>The DBMS_AUTO_TASK_ADMIN package provides an interface to AUTOTASK functionality. It is used by the DBA as well as Enterprise Manager to access the AUTOTASK controls. Enterprise Manager also uses the AUTOTASK Advisor.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_AW_STATS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_aw_stats.htm">
      <Description>DBMS_AW_STATS contains subprograms for managing optimizer statistics for cubes and dimensions. Generating the statistics does not have a significant performance cost.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ANALYZE&quot;" ElementId="#CHDCBFHG">Generates optimizer statistics on cubes and cube dimensions.</SubProgram>
        <SubProgram Name="&quot;CLEAR&quot;" ElementId="#CIHGHBFG">Clears optimizer statistics from cubes and cube dimensions.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_CAPTURE_ADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_cap_a.htm">
      <Description>The DBMS_CAPTURE_ADM package, one of a set of Oracle Streams packages, provides subprograms for starting, stopping, and configuring a capture process. The source of the captured changes is the redo logs, and the repository for the captured changes is a queue.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ABORT_GLOBAL_INSTANTIATION&quot;" ElementId="#i996899">Reverses the effects of running the PREPARE_GLOBAL_INSTANTIATION, PREPARE_SCHEMA_INSTANTIATION, and PREPARE_TABLE_INSTANTIATION procedures</SubProgram>
        <SubProgram Name="&quot;ABORT_SCHEMA_INSTANTIATION&quot;" ElementId="#BGBFECAG">Reverses the effects of running the PREPARE_SCHEMA_INSTANTIATION and PREPARE_TABLE_INSTANTIATION procedures</SubProgram>
        <SubProgram Name="&quot;ABORT_SYNC_INSTANTIATION&quot;" ElementId="#BGBHGABG">Reverses the effects of running the PREPARE_SYNC_INSTANTIATION procedure</SubProgram>
        <SubProgram Name="&quot;ABORT_TABLE_INSTANTIATION&quot;" ElementId="#i996936">Reverses the effects of running the PREPARE_TABLE_INSTANTIATION procedure</SubProgram>
        <SubProgram Name="&quot;ALTER_CAPTURE&quot;" ElementId="#i996962">Alters a capture process</SubProgram>
        <SubProgram Name="&quot;ALTER_SYNC_CAPTURE&quot;" ElementId="#BGBHGBAF">Alters a synchronous capture</SubProgram>
        <SubProgram Name="&quot;BUILD&quot;" ElementId="#i1003124">Extracts the data dictionary of the current database to the redo logs and automatically specifies database supplemental logging for all primary key and unique key columns</SubProgram>
        <SubProgram Name="&quot;CREATE_CAPTURE&quot;" ElementId="#i997066">Creates a capture process</SubProgram>
        <SubProgram Name="&quot;CREATE_SYNC_CAPTURE&quot;" ElementId="#BGBCAHCG">Creates a synchronous capture</SubProgram>
        <SubProgram Name="&quot;DROP_CAPTURE&quot;" ElementId="#i997167">Drops a capture process</SubProgram>
        <SubProgram Name="&quot;INCLUDE_EXTRA_ATTRIBUTE&quot;" ElementId="#i1000175">Includes or excludes an extra attribute in logical change records (LCRs) captured by the specified capture process or synchronous capture</SubProgram>
        <SubProgram Name="&quot;PREPARE_GLOBAL_INSTANTIATION&quot;" ElementId="#BGBDGIEG">Performs the synchronization necessary for instantiating all the tables in the database at another database and can enable supplemental logging for key columns or all columns in these tables</SubProgram>
        <SubProgram Name="&quot;PREPARE_SCHEMA_INSTANTIATION&quot;" ElementId="#BGBCHBDG">Performs the synchronization necessary for instantiating all tables in the schema at another database and can enable supplemental logging for key columns or all columns in these tables</SubProgram>
        <SubProgram Name="&quot;PREPARE_SYNC_INSTANTIATION&quot;" ElementId="#BGBFEICF">Performs the synchronization necessary for instantiating one or more tables at another database and returns the prepare SCN</SubProgram>
        <SubProgram Name="&quot;PREPARE_TABLE_INSTANTIATION&quot;" ElementId="#i997227">Performs the synchronization necessary for instantiating the table at another database and can enable supplemental logging for key columns or all columns in the table</SubProgram>
        <SubProgram Name="&quot;SET_PARAMETER&quot;" ElementId="#i997253">Sets a capture process parameter to the specified value</SubProgram>
        <SubProgram Name="&quot;START_CAPTURE&quot;" ElementId="#BGBHAJGJ">Starts the capture process, which mines redo logs and enqueues the mined redo information into the associated queue</SubProgram>
        <SubProgram Name="&quot;STOP_CAPTURE&quot;" ElementId="#i997449">Stops the capture process from mining redo logs</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_COMPARISON&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_comparison.htm">
      <Description>The DBMS_COMPARISON package provides interfaces to compare and converge database objects at different databases.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;COMPARE&quot;" ElementId="#CHDDFJBH">Performs the specified comparison</SubProgram>
        <SubProgram Name="&quot;CONVERGE&quot;" ElementId="#CHDGIBFI">Executes data manipulation language (DML) changes to synchronize the portion of the database object that was compared in the specified scan</SubProgram>
        <SubProgram Name="&quot;CREATE_COMPARISON&quot;" ElementId="#CHDCJIFD">Creates a comparison</SubProgram>
        <SubProgram Name="&quot;DROP_COMPARISON&quot;" ElementId="#CHDJGDIF">Drops a comparison</SubProgram>
        <SubProgram Name="&quot;PURGE_COMPARISON&quot;" ElementId="#CHDGJFJB">Purges the comparison results, or a subset of the comparison results, for a comparison</SubProgram>
        <SubProgram Name="&quot;RECHECK&quot;" ElementId="#CHDEJHCF">Rechecks the differences in a specified scan for a comparison</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_COMPRESSION&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_compress.htm">
      <Description>The DBMS_COMPRESSION package provides an interface to facilitate choosing the correct compression level for an application.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GET_COMPRESSION_RATIO&quot;" ElementId="#BEIBEEJC">Analyzes the compression ratio of a table, and gives information about compressibility of a table</SubProgram>
        <SubProgram Name="&quot;GET_COMPRESSION_TYPE&quot;" ElementId="#BEIFFAHJ">Returns the compression type for a specified row</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_CONNECTION_POOL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_connection_pool.htm">
      <Description>The DBMS_CONNECTION_POOL package provides an interface to manage Database Resident Connection Pool.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ALTER_PARAM&quot;" ElementId="#BABJAIGJ">Alters a specific configuration parameter as a standalone unit and does not affect other parameters</SubProgram>
        <SubProgram Name="&quot;CONFIGURE_POOL&quot;" ElementId="#BABCECIF">Configures the pool with advanced options</SubProgram>
        <SubProgram Name="&quot;START_POOL&quot;" ElementId="#BABJIAIH">Starts the pool for operations. It is only after this call that the pool could be used by connection clients for creating sessions</SubProgram>
        <SubProgram Name="&quot;STOP_POOL&quot;" ElementId="#BABBGICE">Stops the pool and makes it unavailable for the registered connection clients</SubProgram>
        <SubProgram Name="&quot;RESTORE_DEFAULTS&quot;" ElementId="#BABGFGAG">Restores the pool to default settings</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_CQ_NOTIFICATION&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_cqnotif.htm">
      <Description>The DBMS_CQ_NOTIFICATION package is part of the database change notification feature that provides the functionality to create registration on queries designated by a client application and so to receive notifications in response to DML or DDL changes on the objects associated with the queries. The notifications are published by the database when the DML or DDL transaction commits.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_CREDENTIAL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_credential.htm">
      <Description>The DBMS_CREDENTIAL package provides an interface for authenticating and impersonating EXTPROC callout functions, as well as external jobs, remote jobs and file watchers from the SCHEDULER.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CREATE_CREDENTIAL&quot;" ElementId="#CIHDCEFH">Creates a stored username/password pair in a database object called an Oracle credential</SubProgram>
        <SubProgram Name="&quot;DISABLE_CREDENTIAL&quot;" ElementId="#BABCIHFJ">Disables an Oracle credential</SubProgram>
        <SubProgram Name="&quot;DROP_CREDENTIAL&quot;" ElementId="#BABHBABD">Drops an Oracle credential</SubProgram>
        <SubProgram Name="&quot;ENABLE_CREDENTIAL&quot;" ElementId="#BABCGFEA">Enables an Oracle credential</SubProgram>
        <SubProgram Name="&quot;UPDATE_CREDENTIAL&quot;" ElementId="#BABHHIDH">Updates an existing Oracle credential</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_CRYPTO&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_crypto.htm">
      <Description>DBMS_CRYPTO provides an interface to encrypt and decrypt stored data, and can be used in conjunction with PL/SQL programs running network communications. It provides support for several industry-standard encryption and hashing algorithms, including the Advanced Encryption Standard (AES) encryption algorithm. AES has been approved by the National Institute of Standards and Technology (NIST) to replace the Data Encryption Standard (DES).</Description>
      <SubPrograms>
        <SubProgram Name="&quot;DECRYPT&quot;" ElementId="#i1004325">Decrypts RAW data using a stream or block cipher with a user supplied key and optional IV (initialization vector)</SubProgram>
        <SubProgram Name="&quot;DECRYPT&quot;" ElementId="#i1004271">Decrypts LOB data using a stream or block cipher with a user supplied key and optional IV</SubProgram>
        <SubProgram Name="&quot;ENCRYPT&quot;" ElementId="#i1002112">Encrypts RAW data using a stream or block cipher with a user supplied key and optional IV</SubProgram>
        <SubProgram Name="&quot;ENCRYPT&quot;" ElementId="#i1003081">Encrypts LOB data using a stream or block cipher with a user supplied key and optional IV</SubProgram>
        <SubProgram Name="&quot;HASH&quot;" ElementId="#i1002022">Applies one of the supported cryptographic hash algorithms (MD4, MD5, SHA-1, or SHA-2) to data</SubProgram>
        <SubProgram Name="&quot;MAC&quot;" ElementId="#i1000594">Applies Message Authentication Code algorithms (MD5, SHA-1, or SHA-2) to data to provide keyed message protection</SubProgram>
        <SubProgram Name="&quot;RANDOMBYTES&quot;" ElementId="#i1000605">Returns a RAW value containing a cryptographically secure pseudo-random sequence of bytes, and can be used to generate random material for encryption keys</SubProgram>
        <SubProgram Name="&quot;RANDOMINTEGER&quot;" ElementId="#i1003214">Returns a random BINARY_INTEGER</SubProgram>
        <SubProgram Name="&quot;RANDOMNUMBER&quot;" ElementId="#i1004384">Returns a random 128-bit integer of the NUMBER datatype</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_CSX_ADMIN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_csx_admin.htm">
      <Description>The DBMS_CSX_ADMIN package provides an interface to customize the setup when transporting a tablespace containing binary XML data.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GETTOKENTABLEINFO&quot;" ElementId="#CDCJIGCA">Returns the GUID of the token table set where token mappings for this table</SubProgram>
        <SubProgram Name="&quot;GETTOKENTABLEINFOBYTABLESPACE&quot;" ElementId="#CDCCAFJF">Returns the GUID and the token table names for this tablespace</SubProgram>
        <SubProgram Name="&quot;NAMESPACEIDTABLE&quot;" ElementId="#CDCIFICC">Returns default namespace-ID token table</SubProgram>
        <SubProgram Name="&quot;PATHIDTABLE&quot;" ElementId="#CDCEBIBJ">Returns the default path-ID token table</SubProgram>
        <SubProgram Name="&quot;QNAMEIDTABLE&quot;" ElementId="#CDCIAICI">Returns the default qname-ID token table.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_CUBE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_cube.htm">
      <Description>DBMS_CUBE contains subprograms that create OLAP cubes and dimensions, and that load and process the data for querying.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_CUBE_ADVISE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_cube_advise.htm">
      <Description>DBMS_CUBE_ADVISE contains subprograms for evaluating cube materialized views to support log-based fast refresh and query rewrite.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_CUBE_LOG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_cube_log.htm">
      <Description>DBMS_CUBE_LOG contains subprograms for creating and managing logs for cubes and cube dimensions.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DATA_MINING&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_datmin.htm">
      <Description>The DBMS_DATA_MININGpackage is the application programming interface for creating, evaluating, and querying data mining models.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_COST_MATRIX&quot;" ElementId="#CACGCHCE">Adds a cost matrix to a classification model</SubProgram>
        <SubProgram Name="&quot;ALTER_REVERSE_EXPRESSION&quot;" ElementId="#CACCBBJG">Changes the reverse transformation expression to an expression that you specify</SubProgram>
        <SubProgram Name="&quot;APPLY&quot;" ElementId="#i1038691">Applies a model to a data set (scores the data)</SubProgram>
        <SubProgram Name="&quot;COMPUTE_CONFUSION_MATRIX&quot;" ElementId="#i1038990">Computes the confusion matrix for a classification model</SubProgram>
        <SubProgram Name="&quot;COMPUTE_LIFT&quot;" ElementId="#i1042043">Computes lift for a a classification model</SubProgram>
        <SubProgram Name="&quot;COMPUTE_ROC&quot;" ElementId="#i1039323">Computes Receiver Operating Characteristic (ROC) for a classification model</SubProgram>
        <SubProgram Name="&quot;CREATE_MODEL&quot;" ElementId="#i1038828">Creates a model</SubProgram>
        <SubProgram Name="&quot;DROP_MODEL&quot;" ElementId="#i1039535">Drops a model</SubProgram>
        <SubProgram Name="&quot;EXPORT_MODEL&quot;" ElementId="#i1039591">Exports a model to a dump file</SubProgram>
        <SubProgram Name="&quot;GET_ASSOCIATION_RULES&quot;" ElementId="#i1039753">Returns the rules from an association model</SubProgram>
        <SubProgram Name="&quot;GET_FREQUENT_ITEMSETS&quot;" ElementId="#i1039941">Returns the frequent itemsets for an association model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_COST_MATRIX&quot;" ElementId="#CACGJGDJ">Returns the cost matrix for a model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_AI&quot;" ElementId="#CACGDHGJ">Returns details about an Attribute Importance model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_EM&quot;" ElementId="#CACIHDHB">Returns details about an Expectation Maximization model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_EM_COMP&quot;" ElementId="#CACHIBCG">Returns details about the parameters of an Expectation Maximization model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_EM_PROJ&quot;" ElementId="#CACHDDCF">Returns details about the projects of an Expectation Maximization model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_GLM&quot;" ElementId="#CACECDHF">Returns details about a Generalized Linear Model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_GLOBAL&quot;" ElementId="#CACICAIJ">Returns high-level statistics about a model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_KM&quot;" ElementId="#CACIIEAA">Returns details about a k-Means model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_NB&quot;" ElementId="#i1040352">Returns details about a Naive Bayes model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_NMF&quot;" ElementId="#i1040515">Returns details about a Non-Negative Matrix Factorization model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_OC&quot;" ElementId="#CACDAIAE">Returns details about an O-Cluster model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_SVD&quot;" ElementId="#CACEABEH">Returns details about a Singular Value Decomposition model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_SVM&quot;" ElementId="#i1040615">Returns details about a Support Vector Machine model with a linear kernel</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_DETAILS_XML&quot;" ElementId="#CACFGFDB">Returns details about a Decision Tree model</SubProgram>
        <SubProgram Name="&quot;GET_MODEL_TRANSFORMATIONS&quot;" ElementId="#CACJDBCE">Returns the transformations embedded in a model</SubProgram>
        <SubProgram Name="&quot;GET_TRANSFORM_LIST&quot;" ElementId="#CACBGIDA">Converts between two different transformation specification formats</SubProgram>
        <SubProgram Name="&quot;IMPORT_MODEL&quot;" ElementId="#i1040882">Imports a model into a user schema</SubProgram>
        <SubProgram Name="&quot;RANK_APPLY&quot;" ElementId="#i1041086">Ranks the predictions from the APPLY results for a classification model</SubProgram>
        <SubProgram Name="&quot;REMOVE_COST_MATRIX&quot;" ElementId="#CACFCAIH">Removes a cost matrix from a model</SubProgram>
        <SubProgram Name="&quot;RENAME_MODEL&quot;" ElementId="#i1041237">Renames a model</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DATA_MINING_TRANSFORM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dmtran.htm">
      <Description>DBMS_DATA_MINING_TRANSFORM implements a set of transformations that are commonly used in data mining. </Description>
      <SubPrograms>
        <SubProgram Name="&quot;CREATE_BIN_CAT&quot;" ElementId="#BABHJHJF">Creates a transformation definition table for categorical binning</SubProgram>
        <SubProgram Name="&quot;CREATE_BIN_NUM&quot;" ElementId="#BABCJBCG">Creates a transformation definition table for numerical binning</SubProgram>
        <SubProgram Name="&quot;CREATE_CLIP&quot;" ElementId="#BABCFGBC">Creates a transformation definition table for clipping</SubProgram>
        <SubProgram Name="&quot;CREATE_COL_REM&quot;" ElementId="#BABGCDCC">Creates a transformation definition table for column removal</SubProgram>
        <SubProgram Name="&quot;CREATE_MISS_CAT&quot;" ElementId="#BABHJFDC">Creates a transformation definition table for categorical missing value treatment</SubProgram>
        <SubProgram Name="&quot;CREATE_MISS_NUM&quot;" ElementId="#BABIEAGA">Creates a transformation definition table for numerical missing values treatment</SubProgram>
        <SubProgram Name="&quot;CREATE_NORM_LIN&quot;" ElementId="#BABGBDGB">Creates a transformation definition table for linear normalization</SubProgram>
        <SubProgram Name="&quot;DESCRIBE_STACK&quot;" ElementId="#BABIIFEF">Describes the transformation list</SubProgram>
        <SubProgram Name="&quot;GET_EXPRESSION&quot;" ElementId="#BABGDGIA">Returns a VARCHAR2 chunk from a transformation expression</SubProgram>
        <SubProgram Name="&quot;INSERT_AUTOBIN_NUM_EQWIDTH&quot;" ElementId="#BABJDGIA">Inserts numeric automatic equi-width binning definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_BIN_CAT_FREQ&quot;" ElementId="#BABCIBEH">Inserts categorical frequency-based binning definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_BIN_NUM_EQWIDTH&quot;" ElementId="#BABEFAIC">Inserts numeric equi-width binning definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_BIN_NUM_QTILE&quot;" ElementId="#BABEDFDH">Inserts numeric quantile binning expressions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_BIN_SUPER&quot;" ElementId="#BABEHBCE">Inserts supervised binning definitions in numerical and categorical transformation definition tables</SubProgram>
        <SubProgram Name="&quot;INSERT_CLIP_TRIM_TAIL&quot;" ElementId="#BABIIJFA">Inserts numerical trimming definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_CLIP_WINSOR_TAIL&quot;" ElementId="#BABIIFED">Inserts numerical winsorizing definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_MISS_CAT_MODE&quot;" ElementId="#BABJCGCA">Inserts categorical missing value treatment definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_MISS_NUM_MEAN&quot;" ElementId="#BABHAHEJ">Inserts numerical missing value treatment definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_NORM_LIN_MINMAX&quot;" ElementId="#BABDFACD">Inserts linear min-max normalization definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_NORM_LIN_SCALE&quot;" ElementId="#BABHAFJC">Inserts linear scale normalization definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;INSERT_NORM_LIN_ZSCORE&quot;" ElementId="#BABDCGGH">Inserts linear zscore normalization definitions in a transformation definition table</SubProgram>
        <SubProgram Name="&quot;SET_EXPRESSION&quot;" ElementId="#CACJDFJC">Adds a VARCHAR2 chunk to an expression</SubProgram>
        <SubProgram Name="&quot;SET_TRANSFORM&quot;" ElementId="#BABJIIIE">Adds a transformation record to a transformation list</SubProgram>
        <SubProgram Name="&quot;STACK_BIN_CAT&quot;" ElementId="#CACJCHHI">Adds a categorical binning expression to a transformation list</SubProgram>
        <SubProgram Name="&quot;STACK_BIN_NUM&quot;" ElementId="#CACEGEHI">Adds a numerical binning expression to a transformation list</SubProgram>
        <SubProgram Name="&quot;STACK_CLIP&quot;" ElementId="#CACHGHIG">Adds a clipping expression to a transformation list</SubProgram>
        <SubProgram Name="&quot;STACK_COL_REM&quot;" ElementId="#CACHCDCH">Adds a column removal expression to a transformation list</SubProgram>
        <SubProgram Name="&quot;STACK_MISS_CAT&quot;" ElementId="#BABJGBGH">Adds a categorical missing value treatment expression to a transformation list</SubProgram>
        <SubProgram Name="&quot;STACK_MISS_NUM&quot;" ElementId="#BABFIBFF">Adds a numerical missing value treatment expression to a transformation list</SubProgram>
        <SubProgram Name="&quot;STACK_NORM_LIN&quot;" ElementId="#BABFAFCH">Adds a linear normalization expression to a transformation list</SubProgram>
        <SubProgram Name="&quot;XFORM_BIN_CAT&quot;" ElementId="#BABHHBCI">Creates a view of the data table with categorical binning transformations</SubProgram>
        <SubProgram Name="&quot;XFORM_BIN_NUM&quot;" ElementId="#BABJDHDF">Creates a view of the data table with numerical binning transformations</SubProgram>
        <SubProgram Name="&quot;XFORM_CLIP&quot;" ElementId="#BABDFGDG">Creates a view of the data table with clipping transformations</SubProgram>
        <SubProgram Name="&quot;XFORM_COL_REM&quot;" ElementId="#BABHFHGH">Creates a view of the data table with column removal transformations</SubProgram>
        <SubProgram Name="&quot;XFORM_EXPR_NUM&quot;" ElementId="#BABJHGCG">Creates a view of the data table with the specified numeric transformations</SubProgram>
        <SubProgram Name="&quot;XFORM_EXPR_STR&quot;" ElementId="#BABHGAJH">Creates a view of the data table with the specified categorical transformations</SubProgram>
        <SubProgram Name="&quot;XFORM_MISS_CAT&quot;" ElementId="#BABBEDBE">Creates a view of the data table with categorical missing value treatment</SubProgram>
        <SubProgram Name="&quot;XFORM_MISS_NUM&quot;" ElementId="#BABCFDAA">Creates a view of the data table with numerical missing value treatment</SubProgram>
        <SubProgram Name="&quot;XFORM_NORM_LIN&quot;" ElementId="#BABIHHGG">Creates a view of the data table with linear normalization transformations</SubProgram>
        <SubProgram Name="&quot;XFORM_STACK&quot;" ElementId="#BABIHDCC">Creates a view of the transformation list</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DATAPUMP&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_datpmp.htm">
      <Description>The DBMS_DATAPUMP package is used to move all, or part of, a database between databases, including both data and metadata.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_FILE&quot;" ElementId="#i997139">Adds dump files to the dump file set for an Export, Import, or SQL_FILE operation. In addition to dump files, other types of files can also be added by using the FILETYPE parameter provided with this procedure.</SubProgram>
        <SubProgram Name="&quot;ATTACH&quot;" ElementId="#i997216">Used to gain access to a Data Pump job that is in the Defining, Executing, Idling, or Stopped state</SubProgram>
        <SubProgram Name="&quot;DATA_FILTER&quot;" ElementId="#i997260">Specifies restrictions on the rows that are to be retrieved</SubProgram>
        <SubProgram Name="&quot;DATA_REMAP&quot;" ElementId="#CEGFJHIC">Specifies transformations to be applied to column data as it is exported from, or imported into, a database.</SubProgram>
        <SubProgram Name="&quot;DETACH&quot;" ElementId="#i997382">Specifies that the user has no further interest in using the handle</SubProgram>
        <SubProgram Name="&quot;GET_DUMPFILE_INFO&quot;" ElementId="#BABJBADB">Retrieves information about a specified dump file</SubProgram>
        <SubProgram Name="&quot;GET_STATUS&quot;" ElementId="#i997417">Monitors the status of a job or waits for the completion of a job or for more details on API errors</SubProgram>
        <SubProgram Name="&quot;LOG_ENTRY&quot;" ElementId="#i997488">Inserts a message into the log file</SubProgram>
        <SubProgram Name="&quot;METADATA_FILTER&quot;" ElementId="#BABJACDG">Provides filters that allow you to restrict the items that are included in a job</SubProgram>
        <SubProgram Name="&quot;METADATA_REMAP&quot;" ElementId="#i1007115">Specifies a remapping to be applied to objects as they are processed in the specified job</SubProgram>
        <SubProgram Name="&quot;METADATA_TRANSFORM&quot;" ElementId="#i1006886">Specifies transformations to be applied to objects as they are processed in the specified job</SubProgram>
        <SubProgram Name="&quot;OPEN&quot;" ElementId="#i997806">Declares a new job using the Data Pump API, the handle returned being used as a parameter for calls to all other procedures (but not to the ATTACH function)</SubProgram>
        <SubProgram Name="&quot;SET_PARALLEL&quot;" ElementId="#i1011791">Adjusts the degree of parallelism within a job</SubProgram>
        <SubProgram Name="&quot;SET_PARAMETER&quot;" ElementId="#i1011813">Specifies job-processing options</SubProgram>
        <SubProgram Name="&quot;START_JOB&quot;" ElementId="#i998298">Begins or resumes execution of a job</SubProgram>
        <SubProgram Name="&quot;STOP_JOB&quot;" ElementId="#i998351">Terminates a job, but optionally, preserves the state of the job</SubProgram>
        <SubProgram Name="&quot;WAIT_FOR_JOB&quot;" ElementId="#BABJHGAC">Runs a job until it either completes normally or stops for some other reason</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DB_VERSION&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dbver.htm">
      <Description>The DBMS_DB_VERSION package specifies the Oracle version numbers and other information useful for simple conditional compilation selections based on Oracle versions.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DBFS_CONTENT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dbfs_content.htm">
      <Description>The DBMS_DBFS_CONTENT package provides an interface comprising a file system-like abstraction backed by one or more Store Providers.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CHECKACCESS&quot;" ElementId="#CIHICEDH">Reports if the user (principal) can perform the specified operation on the given path</SubProgram>
        <SubProgram Name="&quot;CHECKSPI&quot;" ElementId="#CIHEDCIJ">Checks if a user-provided package implements all of the DBMS_DBFS_CONTENT_SPI subprograms with the proper signatures, and reports on the conformance.</SubProgram>
        <SubProgram Name="&quot;CREATEDIRECTORY&quot;" ElementId="#CIHCCAGI">Creates a directory</SubProgram>
        <SubProgram Name="&quot;CREATEFILE&quot;" ElementId="#CIHCGCHB">Creates a file</SubProgram>
        <SubProgram Name="&quot;CREATELINK&quot;" ElementId="#CIHJIEHA">Creates a new reference to the source file system element</SubProgram>
        <SubProgram Name="&quot;CREATEREFERENCE&quot;" ElementId="#CIHFBAAB">Creates a physical link to an already existing file system element</SubProgram>
        <SubProgram Name="&quot;DECODEFEATURES&quot;" ElementId="#CIHIHJBD">Given a feature bit set integer value, returns a FEATURES_T table of the feature bits as FEATURE_T records</SubProgram>
        <SubProgram Name="&quot;DELETECONTENT&quot;" ElementId="#CIHFIJCF">Deletes the file specified by the given contentID</SubProgram>
        <SubProgram Name="&quot;DELETEDIRECTORY&quot;" ElementId="#CIHIJHHE">Deletes a directory</SubProgram>
        <SubProgram Name="&quot;DELETEFILE&quot;" ElementId="#CIHIHFHC">Deletes a file</SubProgram>
        <SubProgram Name="&quot;FEATURENAME&quot;" ElementId="#CIHIJJAA">Given a feature bit, returns a VARCHAR2 of that feature's name</SubProgram>
        <SubProgram Name="&quot;FLUSHSTATS&quot;" ElementId="#CIHHFBDH">Flushes DBMS_DBFS_CONTENT statistics to disk</SubProgram>
        <SubProgram Name="&quot;GETDEFAULTACL&quot;" ElementId="#CIHEHCFB">Returns the ACL parameter of the default context</SubProgram>
        <SubProgram Name="&quot;GETDEFAULTASOF&quot;" ElementId="#CIHCJFDD">Returns the asof parameter of the default context</SubProgram>
        <SubProgram Name="&quot;GETTDEFAULTCONTEXT&quot;" ElementId="#CIHIHFDG">Returns the default context</SubProgram>
        <SubProgram Name="&quot;GETDEFAULTOWNER&quot;" ElementId="#CIHDGBHB">Returns the owner parameter of the default context</SubProgram>
        <SubProgram Name="&quot;GETDEFAULTPRINCIPAL&quot;" ElementId="#CIHGCGFA">Returns the principal parameter of the default context</SubProgram>
        <SubProgram Name="&quot;GETFEATURESBYMOUNT&quot;" ElementId="#CIHGHFCE">Returns features of a store by mount point</SubProgram>
        <SubProgram Name="&quot;GETFEATURESBYNAME&quot;" ElementId="#CIHFEIJI">Returns features of a store by store name</SubProgram>
        <SubProgram Name="&quot;GETFEATURESBYPATH&quot;" ElementId="#CIHDHIFI">Returns features of a store by path</SubProgram>
        <SubProgram Name="&quot;GETPATHBYMOUNTID&quot;" ElementId="#CIHICJIC">Returns the full absolute path name</SubProgram>
        <SubProgram Name="&quot;GETPATH&quot;" ElementId="#CIHBEIBE">Returns existing path items (such as files and directories)</SubProgram>
        <SubProgram Name="&quot;GETPATHBYSTOREID&quot;" ElementId="#CIHDFFIF">If the underlying GUID is found in the underlying store, returns the store-qualified path name</SubProgram>
        <SubProgram Name="&quot;GETPATHNOWAIT&quot;" ElementId="#CIHCDGDA">Implies that the operation is for an update, and, if implemented, allows providers to return an exception (ORA-00054) rather than wait for row locks.</SubProgram>
        <SubProgram Name="&quot;GETSTOREBYMOUNT&quot;" ElementId="#CIHCGCFD">Returns a store by way of its mount point</SubProgram>
        <SubProgram Name="&quot;GETSTOREBYNAME&quot;" ElementId="#CIHCFIJA">Returns a store by way of its name</SubProgram>
        <SubProgram Name="&quot;GETSTOREBYPATH&quot;" ElementId="#CIHCCHEJ">Returns a store by way of its path</SubProgram>
        <SubProgram Name="&quot;GETSTATS&quot;" ElementId="#CIHEIIDH">Returns information about DBMS_DBFS_CONTENT statistics collection</SubProgram>
        <SubProgram Name="&quot;GETTRACE&quot;" ElementId="#CIHCCCFJ">Returns whether or not DBMS_DBFS_CONTENT tracing is turned on</SubProgram>
        <SubProgram Name="&quot;GETVERSION&quot;" ElementId="#CIHHJAAB">Returns the version of the DBMS_DBFS_CONTENT interface in a standardized format associated with a store</SubProgram>
        <SubProgram Name="&quot;LIST&quot;" ElementId="#CIHJGDGF">Lists the path items in the specified path meeting the specified filter and other criteria</SubProgram>
        <SubProgram Name="&quot;LISTALLCONTENT&quot;" ElementId="#CIHIGJBI">Lists all path items in all mounts</SubProgram>
        <SubProgram Name="&quot;LISTALLPROPERTIES&quot;" ElementId="#CIHEAEEA">Returns a table of all properties for all path items in all mounts</SubProgram>
        <SubProgram Name="&quot;LISTMOUNTS&quot;" ElementId="#CIHFFBIB">Lists all available mount points, their backing stores, and the store features</SubProgram>
        <SubProgram Name="&quot;LISTSTORES&quot;" ElementId="#CIHFCIGI">Lists all available stores and their features</SubProgram>
        <SubProgram Name="&quot;LOCKPATH&quot;" ElementId="#CIHHFAGA">Applies user-level locks to the given valid path name</SubProgram>
        <SubProgram Name="&quot;MOUNTSTORE&quot;" ElementId="#CIHDBCJI">Mounts a previously registered store and binds it to the mount point</SubProgram>
        <SubProgram Name="&quot;NORMALIZEPATH&quot;" ElementId="#CIHJGGAH">Converts a store-specific or full-absolute path name into normalized form</SubProgram>
        <SubProgram Name="&quot;PROPANY&quot;" ElementId="#CIHJJFGD">Provides constructors that take one of a variety of types and return a PROPERTY_T</SubProgram>
        <SubProgram Name="&quot;PROPERTIESH2T&quot;" ElementId="#CIHGCBFD">Converts a PROPERTY_T hash to a DBMS_DBFS_CONTENT_PROPERTIES_T table</SubProgram>
        <SubProgram Name="&quot;PROPERTIEST2H&quot;" ElementId="#CIHBAIHH">Converts a DBMS_DBFS_CONTENT_PROPERTIES_T table to a PROPERTY_T hash</SubProgram>
        <SubProgram Name="&quot;PROPNUMBER&quot;" ElementId="#CIHDEIDD">Is a constructor that takes a NUMBER and returns a PROPERTY_T</SubProgram>
        <SubProgram Name="&quot;PROPRAW&quot;" ElementId="#CIHIGGHD">Is a constructor that takes a RAW and returns a PROPERTY_T</SubProgram>
        <SubProgram Name="&quot;PROPTIMESTAMP&quot;" ElementId="#CIHFHABG">Is a constructor that takes a TIMESTAMP and returns a PROPERTY_T</SubProgram>
        <SubProgram Name="&quot;PROPVARCHAR2&quot;" ElementId="#CIHDIAEI">Is a constructor that takes a VARCAHR2 and returns a PROPERTY_T</SubProgram>
        <SubProgram Name="&quot;PURGEALL&quot;" ElementId="#CIHJHFIB">Purges all soft-deleted entries matching the path and optional filter criteria</SubProgram>
        <SubProgram Name="&quot;PURGEPATH&quot;" ElementId="#CIHIFCBF">Purges any soft-deleted versions of the given path item</SubProgram>
        <SubProgram Name="&quot;PUTPATH&quot;" ElementId="#CIHHAJGE">Creates a new path item</SubProgram>
        <SubProgram Name="&quot;REGISTERSTORE&quot;" ElementId="#CIHIDCJH">Registers a new store</SubProgram>
        <SubProgram Name="&quot;RENAMEPATH&quot;" ElementId="#CIHGHJFE">Renames or moves a path</SubProgram>
        <SubProgram Name="&quot;RESTOREALL&quot;" ElementId="#CIHEHDCJ">Restores all soft-deleted path items meeting the path and filter criteria</SubProgram>
        <SubProgram Name="&quot;RESTOREPATH&quot;" ElementId="#CIHDEFEB">Restores all soft-deleted path items that match the given path and filter criteria</SubProgram>
        <SubProgram Name="&quot;SETDEFAULTACL&quot;" ElementId="#CIHHCHGF">Sets the ACL parameter of the default context</SubProgram>
        <SubProgram Name="&quot;SETDEFAULTASOF&quot;" ElementId="#CIHJDDGC">Sets the "as of" parameter of the default context</SubProgram>
        <SubProgram Name="&quot;SETDEFAULTCONTEXT&quot;" ElementId="#CIHHBAJE">Sets the default context</SubProgram>
        <SubProgram Name="&quot;SETDEFAULTOWNER&quot;" ElementId="#CIHCIIDJ">Sets the "owner" parameter of the default context</SubProgram>
        <SubProgram Name="&quot;SETDEFAULTPRINCIPAL&quot;" ElementId="#CIHIICHD">Sets the "principal" parameter of the default context</SubProgram>
        <SubProgram Name="&quot;SETPATH&quot;" ElementId="#CIHFBFDB">Assigns a path name to a path item represented by contentID</SubProgram>
        <SubProgram Name="&quot;SETSTATS&quot;" ElementId="#CIHJBDJB">Enables and disables statistics collection</SubProgram>
        <SubProgram Name="&quot;SETTRACE&quot;" ElementId="#BABFJJCC">Sets DBMS_DBFS_CONTENT tracing on or off</SubProgram>
        <SubProgram Name="&quot;SPACEUSAGE&quot;" ElementId="#CIHGDHIC">Queries file system space usage statistics</SubProgram>
        <SubProgram Name="&quot;TRACE&quot;" ElementId="#CIHCFDIC">Returns a CLOB that contains the evaluation results</SubProgram>
        <SubProgram Name="&quot;TRACEENABLED&quot;" ElementId="#CIHIIBJI">Determines if the current trace "severity" set by the SETTRACE Procedure is at least as high as the given trace level</SubProgram>
        <SubProgram Name="&quot;UNLOCKPATH&quot;" ElementId="#CIHGHCGH">Unlocks path items that were previously locked with the LOCKPATH Procedure</SubProgram>
        <SubProgram Name="&quot;UNMOUNTSTORE&quot;" ElementId="#CIHCHIDC">Unmounts a registered store</SubProgram>
        <SubProgram Name="&quot;UNREGISTERSTORE&quot;" ElementId="#CIHCDJJI">Unregisters a store</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DBFS_CONTENT_SPI&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dbfs_content_spi.htm">
      <Description>The DBMS_DBFS_CONTENT_SPI package is a specification for DBMS_DBFS_CONTENT store providers, which must be implemented. Application designers can create PL/SQL packages conforming to this specification to extend DBMS_DBFS_CONTENT to use custom store providers.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CHECKACCESS&quot;" ElementId="#BGBHICAE">Reports if the user (principal) can perform the specified operation on the given path</SubProgram>
        <SubProgram Name="&quot;CREATEDIRECTORY&quot;" ElementId="#BGBBIGIB">Creates a directory</SubProgram>
        <SubProgram Name="&quot;CREATEFILE&quot;" ElementId="#BGBDACFI">Creates a file</SubProgram>
        <SubProgram Name="&quot;CREATELINK&quot;" ElementId="#BGBBFDEI">Creates a physical link to an already existing file system element</SubProgram>
        <SubProgram Name="&quot;CREATEREFERENCE&quot;" ElementId="#BGBHHAFD">Creates a new reference to the source file system element</SubProgram>
        <SubProgram Name="&quot;DELETECONTENT&quot;" ElementId="#BGBIFDGG">Deletes the file specified by the given contentID</SubProgram>
        <SubProgram Name="&quot;DELETEDIRECTORY&quot;" ElementId="#BGBDEFIE">Deletes a directory</SubProgram>
        <SubProgram Name="&quot;DELETEFILE&quot;" ElementId="#BGBGFJEB">Deletes a file</SubProgram>
        <SubProgram Name="&quot;GETFEATURES&quot;" ElementId="#BGBGGAFG">Returns the features of a store</SubProgram>
        <SubProgram Name="&quot;GETPATH&quot;" ElementId="#BGBFJGFJ">Returns existing path items (such as files and directories)</SubProgram>
        <SubProgram Name="&quot;GETPATHBYSTOREID&quot;" ElementId="#BGBBCBHI">If the underlying GUID is found in the underlying store, returns the store-qualified path name</SubProgram>
        <SubProgram Name="&quot;GETPATHNOWAIT&quot;" ElementId="#BGBIHGBC">Implies that the operation is for an update, and, if implemented, allows providers to return an exception (ORA-00054) rather than wait for row locks.</SubProgram>
        <SubProgram Name="&quot;GETSTOREID&quot;" ElementId="#BGBFABCE">Returns the ID of a store</SubProgram>
        <SubProgram Name="&quot;GETVERSION&quot;" ElementId="#BGBBHGAB">Returns the version associated with a store</SubProgram>
        <SubProgram Name="&quot;LIST&quot;" ElementId="#BGBHDECB">Lists the contents of a directory path name</SubProgram>
        <SubProgram Name="&quot;LOCKPATH&quot;" ElementId="#BGBJFBFA">Applies user-level locks to the given valid path name</SubProgram>
        <SubProgram Name="&quot;PURGEALL&quot;" ElementId="#BGBIDAFA">Purges all soft-deleted entries matching the path and optional filter criteria</SubProgram>
        <SubProgram Name="&quot;PURGEPATH&quot;" ElementId="#BGBICJHF">Purges any soft-deleted versions of the given path item</SubProgram>
        <SubProgram Name="&quot;PUTPATH&quot;" ElementId="#BGBDHAFD">Creates a new path item</SubProgram>
        <SubProgram Name="&quot;RENAMEPATH&quot;" ElementId="#BGBIDJEB">Renames or moves a path</SubProgram>
        <SubProgram Name="&quot;RESTOREALL&quot;" ElementId="#BGBCAFBJ">Restores all soft-deleted path items meeting the path and filter criteria</SubProgram>
        <SubProgram Name="&quot;RESTOREPATH&quot;" ElementId="#BGBCFFHH">Restores all soft-deleted path items that match the given path and filter criteria</SubProgram>
        <SubProgram Name="&quot;SEARCH&quot;" ElementId="#BGBIIHJI">Searches for path items matching the given path and filter criteria</SubProgram>
        <SubProgram Name="&quot;SETPATH&quot;" ElementId="#BGBBEIDB">Assigns a path name to a path item represented by contentID</SubProgram>
        <SubProgram Name="&quot;SPACEUSAGE&quot;" ElementId="#BGBEFDCI">Queries file system space usage statistics</SubProgram>
        <SubProgram Name="&quot;UNLOCKPATH&quot;" ElementId="#BGBBCDFD">Unlocks path items that were previously locked with the LOCKPATH Procedure</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DBFS_HS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dbfs_hs.htm">
      <Description>The Oracle Database File System Hierarchical Store is implemented in the DBMS_DBFS_HS package. This package provides users the ability to use tape or Amazon S3 Web service as a storage tier when doing Information Lifecycle Management for their database tables.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLEANUPUNUSEDBACKUPFILES&quot;" ElementId="#BABIBGFG">Removes files created on the external storage device that hold no currently used data</SubProgram>
        <SubProgram Name="&quot;CREATEBUCKET&quot;" ElementId="#BABJCGCE">Creates an AWS bucket, associated with a store of type STORETYPE_AMAZONS3 into which the Hierarchical Store can then move data</SubProgram>
        <SubProgram Name="&quot;CREATESTORE&quot;" ElementId="#BABBEAAJ">Creates a new hierarchical store</SubProgram>
        <SubProgram Name="&quot;DEREGSTORECOMMAND&quot;" ElementId="#BABGABDD">Removes a command that had been previously associated with a store through the RECONFIGCACHE Procedure</SubProgram>
        <SubProgram Name="&quot;DROPSTORE&quot;" ElementId="#BABGDHIJ">Deletes a previously created hierarchical store</SubProgram>
        <SubProgram Name="&quot;FLUSHCACHE&quot;" ElementId="#BABGCAJE">Flushes (writes out) dirty contents from the level-1 cache.</SubProgram>
        <SubProgram Name="&quot;GETSTOREPROPERTY&quot;" ElementId="#BABIIAIB">Retrieves the values of a property of a store</SubProgram>
        <SubProgram Name="&quot;RECONFIGCACHE&quot;" ElementId="#BABJFGEH">Reconfigures the parameters of the database cache used by the store</SubProgram>
        <SubProgram Name="&quot;REGISTERSTORECOMMAND&quot;" ElementId="#BABEICFJ">Registers commands for a store with the Hierarchical Store to be sent to the Media Manager for the external storage device associated with the store</SubProgram>
        <SubProgram Name="&quot;SENDCOMMAND&quot;" ElementId="#BABDBADI">Sends a command to be executed on the external storage device's Media Manager</SubProgram>
        <SubProgram Name="&quot;SETSTOREPROPERTY&quot;" ElementId="#BABIHJAD">Stores properties of a store in the database</SubProgram>
        <SubProgram Name="&quot;STOREPUSH&quot;" ElementId="#BABJBICH">Pushes locally staged data to the remote storage</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DBFS_SFS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dbfs_sfs.htm">
      <Description>The DBMS_DBFS_SFS package provides an interface to operate a SecureFile-based store (SFS) for the content interface described in the DBMS_DBFS_CONTENT package.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CREATEFILESYSTEM&quot;" ElementId="#BABBDEDE">Creates a file system store</SubProgram>
        <SubProgram Name="&quot;CREATESTORE&quot;" ElementId="#BABDBGCG">Creates a new DBFS SFS store</SubProgram>
        <SubProgram Name="&quot;DROPFILESYSTEM&quot;" ElementId="#BABHDDBB">Drops the DBFS SFS store</SubProgram>
        <SubProgram Name="&quot;INITFS&quot;" ElementId="#BABCEFFE">Initializes a POSIX file system store</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DDL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_ddl.htm">
      <Description>This package provides access to some SQL data definition language (DDL) statements from stored procedures. It also provides special administration operations that are not available as Data Definition Language statements (DDLs).</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DEBUG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_debug.htm">
      <Description>DBMS_DEBUG is a PL/SQL interface to the PL/SQL debugger layer, Probe, in the Oracle server.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DEFER&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_defer.htm">
      <Description>DBMS_DEFER is the user interface to a replicated transactional deferred remote procedure call facility. Replicated applications use the calls in this interface to queue procedure calls for later transactional execution at remote nodes.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DEFER_QUERY&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_defque.htm">
      <Description>DBMS_DEFER_QUERY enables you to query the deferred transactions queue data that is not exposed through views.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DEFER_SYS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_defsys.htm">
      <Description>DBMS_DEFER_SYS subprograms manage default replication node lists. This package is the system administrator interface to a replicated transactional deferred remote procedure call facility. Administrators and replication daemons can execute transactions queued for remote nodes using this facility, and administrators can control the nodes to which remote calls are destined.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DESCRIBE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_descrb.htm">
      <Description>You can use the DBMS_DESCRIBE package to get information about a PL/SQL object. When you specify an object name, DBMS_DESCRIBE returns a set of indexed tables with the results. Full name translation is performed and security checking is also checked on the final object.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dg.htm">
      <Description>The DBMS_DG package allows applications to notify the primary database or the fast-start failover target database in an Oracle Data Guard broker environment to initiate a fast-start failover when the application encounters a condition that warrants a failover.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DIMENSION&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dimens.htm">
      <Description>DBMS_DIMENSION enables you to verify dimension relationships and provides an alternative to the Enterprise Manager Dimension Wizard for displaying a dimension definition.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DISTRIBUTED_TRUST_ADMIN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dist_trust_adm.htm">
      <Description>DBMS_DISTRIBUTED_TRUST_ADMINprocedures maintain the Trusted Servers List. Use these procedures to define whether a server is trusted. If a database is not trusted, Oracle refuses current user database links from the database.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ALLOW_ALL&quot;" ElementId="#i996808">Empties the list and inserts a row indicating that all servers should be trusted</SubProgram>
        <SubProgram Name="&quot;ALLOW_SERVER&quot;" ElementId="#i996816">Enables a specific server to be allowed access even though deny all is indicated in the list</SubProgram>
        <SubProgram Name="&quot;DENY_ALL&quot;" ElementId="#BJEJEDHI">Empties the list and inserts a row indicating that all servers should be untrusted</SubProgram>
        <SubProgram Name="&quot;DENY_SERVER&quot;" ElementId="#i996848">Enables a specific server to be denied access even though allow all is indicated in the list</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DNFS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dnfs.htm">
      <Description>The DBMS_DNFS package provides an interface to assists in creating a database using files in the backup set.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLONEDB_RENAMEFILE&quot;" ElementId="#CJAIHDDG">Renames datafiles that were pointing to the backup set to the actual file name in cloned database.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_DST&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_dst.htm">
      <Description>The DBMS_DST package provides an interface to apply the Daylight Saving Time (DST) patch to the Timestamp with Time Zone datatype.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BEGIN_PREPARE&quot;" ElementId="#CIHDCBDI">Starts a prepare window</SubProgram>
        <SubProgram Name="&quot;BEGIN_UPGRADE&quot;" ElementId="#CIHDDJDJ">Starts an upgrade window</SubProgram>
        <SubProgram Name="&quot;CREATE_AFFECTED_TABLE&quot;" ElementId="#CIHFIHAF">Creates a table that has the schema shown in the comments for the FIND_AFFECTED_TABLES Procedure</SubProgram>
        <SubProgram Name="&quot;CREATE_ERROR_TABLE&quot;" ElementId="#CIHIDDIB">Creates a log error table</SubProgram>
        <SubProgram Name="&quot;CREATE_TRIGGER_TABLE&quot;" ElementId="#CIHJHFDD">Creates a table that is used to record active triggers disabled before performing upgrade on the table, having not been enabled due to fatal failure during the upgrading process</SubProgram>
        <SubProgram Name="&quot;END_PREPARE&quot;" ElementId="#CIHDEJDD">Ends a prepare window</SubProgram>
        <SubProgram Name="&quot;END_UPGRADE&quot;" ElementId="#CIHEACDD">Ends an upgrade window</SubProgram>
        <SubProgram Name="&quot;FIND_AFFECTED_TABLES&quot;" ElementId="#CIHHFEBD">Finds all the tables that have affected TSTZ data due to the new timezone version</SubProgram>
        <SubProgram Name="&quot;UPGRADE_DATABASE&quot;" ElementId="#CIHJEIJC">Upgrades all tables in the database that have one or more columns defined on the TSTZ type, or an ADT containing the TSTZ type</SubProgram>
        <SubProgram Name="&quot;UPGRADE_SCHEMA&quot;" ElementId="#CIHBIJDB">Upgrades tables in a specified list of schemas that has one or more columns defined on the TSTZ type, or an ADT containing the TSTZ type</SubProgram>
        <SubProgram Name="&quot;UPGRADE_TABLE&quot;" ElementId="#CIHCEGHG">Upgrades a specified list of tables that has one or more columns defined on the TSTZ type or an ADT containing the TSTZ type</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_EDITIONS_UTILITIES&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_editions_utl.htm">
      <Description>The DBMS_EDITIONS_UTILITIES package provides helper functions for edition-related operations.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;SET_EDITIONING_VIEWS_READ_ONLY&quot;" ElementId="#CBHIBDCE">Given the schema name and table name, this procedure sets the corresponding editioning views in all editions to READONLY or READ/WRITE</SubProgram>
        <SubProgram Name="&quot;SET_NULL_COLUMN_VALUES_TO_EXPR&quot;" ElementId="#CBHDIDEC">For use only during an edition-based redefinition (EBR) exercise</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_EPG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_epg.htm">
      <Description>The DBMS_EPG package implements the embedded PL/SQL gateway that enables a Web browser to invoke a PL/SQL stored procedure through an HTTP listener.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ERRLOG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_errlog.htm">
      <Description>The DBMS_ERRLOG package provides a procedure that enables you to create an error logging table so that DML operations can continue after encountering errors rather than abort and roll back. This enables you to save time and system resources.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CREATE_ERROR_LOG&quot;" ElementId="#CEGBBABI">Creates the error logging table used in DML error logging</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_FGA&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_fga.htm">
      <Description>The DBMS_FGA package provides fine-grained security functions.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_POLICY&quot;" ElementId="#CDEIECAG">Creates an audit policy using the supplied predicate as the audit condition</SubProgram>
        <SubProgram Name="&quot;DISABLE_POLICY&quot;" ElementId="#i1011920">Disables an audit policy</SubProgram>
        <SubProgram Name="&quot;DROP_POLICY&quot;" ElementId="#i1011851">Drops an audit policy</SubProgram>
        <SubProgram Name="&quot;ENABLE_POLICY&quot;" ElementId="#i1011884">Enables an audit policy</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_FILE_GROUP&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_filgrp.htm">
      <Description>The DBMS_FILE_GROUP package, one of a set of Oracle Streams packages, provides administrative interfaces for managing file groups, file group versions, and files. A file group repository is a collection of all of the file groups in a database and can contain multiple versions of a particular file group. You can use this package to create and manage file group repositories.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_FILE&quot;" ElementId="#CEGIEAEC">Adds a file to a version of a file group</SubProgram>
        <SubProgram Name="&quot;ALTER_FILE&quot;" ElementId="#CEGBCBEH">Alters a file in a version of a file group</SubProgram>
        <SubProgram Name="&quot;ALTER_FILE_GROUP&quot;" ElementId="#CEGGBFDC">Alters a file group</SubProgram>
        <SubProgram Name="&quot;ALTER_VERSION&quot;" ElementId="#CEGEDIIC">Alters a version of a file group</SubProgram>
        <SubProgram Name="&quot;CREATE_FILE_GROUP&quot;" ElementId="#CEGIEGAA">Creates a file group</SubProgram>
        <SubProgram Name="&quot;CREATE_VERSION&quot;" ElementId="#CEGFIDJJ">Creates a version of a file group</SubProgram>
        <SubProgram Name="&quot;DROP_FILE_GROUP&quot;" ElementId="#CEGIDAEJ">Drops a file group</SubProgram>
        <SubProgram Name="&quot;DROP_VERSION&quot;" ElementId="#CEGCBHJA">Drops a version of a file group</SubProgram>
        <SubProgram Name="&quot;GRANT_OBJECT_PRIVILEGE&quot;" ElementId="#CEGCADHG">Grants object privileges on a file group to a user</SubProgram>
        <SubProgram Name="&quot;GRANT_SYSTEM_PRIVILEGE&quot;" ElementId="#CEGCCCAG">Grants system privileges for file group operations to a user</SubProgram>
        <SubProgram Name="&quot;PURGE_FILE_GROUP&quot;" ElementId="#CEGDAFAE">Purges a file group using the file group's retention policy</SubProgram>
        <SubProgram Name="&quot;REMOVE_FILE&quot;" ElementId="#CEGCAHGA">Removes a file from a version of a file group</SubProgram>
        <SubProgram Name="&quot;REVOKE_OBJECT_PRIVILEGE&quot;" ElementId="#CEGCDAJC">Revokes object privileges on a file group from a user</SubProgram>
        <SubProgram Name="&quot;REVOKE_SYSTEM_PRIVILEGE&quot;" ElementId="#CEGCAIFG">Revokes system privileges for file group operations from a user</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_FILE_TRANSFER&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_ftran.htm">
      <Description>The DBMS_FILE_TRANSFER package provides procedures to copy a binary file within a database or to transfer a binary file between databases.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;COPY_FILE&quot;" ElementId="#i998868">Reads a file from a source directory and creates a copy of it in a destination directory. The source and destination directories can both be in a local file system, or both be in an Automatic Storage Management (ASM) disk group, or between local file system and ASM with copying in either direction.</SubProgram>
        <SubProgram Name="&quot;GET_FILE&quot;" ElementId="#i998902">Contacts a remote database to read a remote file and then creates a copy of the file in the local file system or ASM</SubProgram>
        <SubProgram Name="&quot;PUT_FILE&quot;" ElementId="#i998903">Reads a local file or ASM and contacts a remote database to create a copy of the file in the remote file system</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_FLASHBACK&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_flashb.htm">
      <Description>Using DBMS_FLASHBACK, you can flash back to a version of the database at a specified time or a specified system change number (SCN).</Description>
      <SubPrograms>
        <SubProgram Name="&quot;DISABLE&quot;" ElementId="#i999219">Disables the Flashback mode for the entire session</SubProgram>
        <SubProgram Name="&quot;ENABLE_AT_SYSTEM_CHANGE_NUMBER&quot;" ElementId="#BGBJEJGF">Enables Flashback for the entire session. Takes an SCN as an Oracle number and sets the session snapshot to the specified number. Inside the Flashback mode, all queries return data consistent as of the specified wall-clock time or SCN</SubProgram>
        <SubProgram Name="&quot;ENABLE_AT_TIME&quot;" ElementId="#i999213">Enables Flashback for the entire session. The snapshot time is set to the SCN that most closely matches the time specified in query_time</SubProgram>
        <SubProgram Name="&quot;GET_SYSTEM_CHANGE_NUMBER&quot;" ElementId="#i997043">Returns the current SCN as an Oracle number. You can use the SCN to store specific snapshots</SubProgram>
        <SubProgram Name="&quot;TRANSACTION_BACKOUT&quot;" ElementId="#CHDEAIFF">Provides the mechanism to back out a transaction</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_FLASHBACK_ARCHIVE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_flashb_archive.htm">
      <Description>The DBMS_FLASHBACK_ARCHIVE package contains procedures for performing various tasks such as:</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_TABLE_TO_APPLICATION&quot;" ElementId="#CHDGHBED">Takes an application name and adds a table to the application as a security table</SubProgram>
        <SubProgram Name="&quot;CREATE_TEMP_HISTORY_TABLE&quot;" ElementId="#CHDDGIEF">Creates a table called TEMP_HISTORY with the correct definition in schema</SubProgram>
        <SubProgram Name="&quot;DISABLE_APPLICATION&quot;" ElementId="#CHDHADJH">Takes an application name and marks a table in it as a security table</SubProgram>
        <SubProgram Name="&quot;DISABLE_ASOF_VALID_TIME&quot;" ElementId="#CHDEDEHB">Disables session level valid-time flashback</SubProgram>
        <SubProgram Name="&quot;DISASSOCIATE_FBA&quot;" ElementId="#CHDGHBJD">Disassociates the given table from the flashback data archive</SubProgram>
        <SubProgram Name="&quot;DROP_APPLICATION&quot;" ElementId="#CHDEFDJB">Takes an application name and removes it from the list of applications</SubProgram>
        <SubProgram Name="&quot;ENABLE_APPLICATION&quot;" ElementId="#CHDDAAEA">Takes an application name and enables Flashback Data Archive on all the security tables for this application</SubProgram>
        <SubProgram Name="&quot;ENABLE_AT_VALID_TIME&quot;" ElementId="#CHDGEEIG">Enables session level valid time flashback</SubProgram>
        <SubProgram Name="&quot;EXTEND_MAPPINGS&quot;" ElementId="#CHDIAEBD">Extends time mappings to times in the past</SubProgram>
        <SubProgram Name="&quot;GET_SYS_CONTEXT&quot;" ElementId="#CHDFGCIG">Gets the context previously selected by the SET_CONTEXT_LEVEL Procedure</SubProgram>
        <SubProgram Name="&quot;IMPORT_HISTORY&quot;" ElementId="#CHDICIJI">Imports history from a table called TEMP_HISTORY in the given schema</SubProgram>
        <SubProgram Name="&quot;LOCK_DOWN_APPLICATION&quot;" ElementId="#CHDJHJID">Takes an application name and makes all the security tables read-only. The group called SYSTEM cannot be locked</SubProgram>
        <SubProgram Name="&quot;PURGE_CONTEXT&quot;" ElementId="#CHDIJFII">Purges the context to be saved selected by the SET_CONTEXT_LEVEL Procedure</SubProgram>
        <SubProgram Name="&quot;REASSOCIATE_FBA&quot;" ElementId="#CHDICBIH">Reassociates the given table with the flashback data archive</SubProgram>
        <SubProgram Name="&quot;REGISTER_APPLICATION&quot;" ElementId="#CHDHHBAB">Takes an application name and optionally a Flashback Data Archive, and registers an application for database hardening</SubProgram>
        <SubProgram Name="&quot;REMOVE_TABLE_FROM_APPLICATION&quot;" ElementId="#CHDJGIBH">Takes an application name and marks a table in it as no longer being a security table</SubProgram>
        <SubProgram Name="&quot;SET_CONTEXT_LEVEL&quot;" ElementId="#CHDHGAFE">Defines how much of the user context is to be saved</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_FREQUENT_ITEMSET&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_frqist.htm">
      <Description>The DBMS_FREQUENT_ITEMSET package enables frequent itemset counting. The two functions are identical except in the input cursor format difference.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_GOLDENGATE_AUTH&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_goldengate_auth.htm">
      <Description>The DBMS_GOLDENGATE_AUTH package provides subprograms for granting privileges to and revoking privileges from GoldenGate administrators.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GRANT_ADMIN_PRIVILEGE&quot;" ElementId="#CBHDIIEC">Either grants the privileges needed by a user to be a GoldenGate administrator directly, or generates a script that grants these privileges</SubProgram>
        <SubProgram Name="&quot;REVOKE_ADMIN_PRIVILEGE&quot;" ElementId="#CBHJIEGG">Either revokes GoldenGate administrator privileges from a user directly, or generates a script that revokes these privileges</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_HEAT_MAP&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_heat_map.htm">
      <Description>The DBMS_HEAT_MAP package provides an interface to externalize heatmaps at various levels of storage including block, extent, segment, object and tablespace. A second set of subprograms externalize the heatmaps materialized by the background for top N tablespaces.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BLOCK_HEAT_MAP&quot;" ElementId="#BEHDHBCB">Returns last modification time for each block in a table segment</SubProgram>
        <SubProgram Name="&quot;EXTENT_HEAT_MAP&quot;" ElementId="#BEHDDJCJ">Returns the extent level Heat Map statistics for a table segment</SubProgram>
        <SubProgram Name="&quot;OBJECT_HEAT_MAP&quot;" ElementId="#BEHEJIAG">Returns the minimum, maximum and average access times for all the segments belonging to the object</SubProgram>
        <SubProgram Name="&quot;SEGMENT_HEAT_MAP&quot;" ElementId="#BEHHGFDB">Returns the heatmap attributes for the given segment</SubProgram>
        <SubProgram Name="&quot;TABLESPACE_HEAT_MAP&quot;" ElementId="#BEHBDIDB">Returns the minimum, maximum and average access times for all the segments in the tablespace</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_HM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_hm.htm">
      <Description>This package contains constants and procedure declarations for health check management. Health Monitor provides facilities to run a check store and retrieve the reports through DBMS_HM package</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GET_RUN_REPORT&quot;" ElementId="#BABCGHIA">Returns the report for the specified checker run</SubProgram>
        <SubProgram Name="&quot;RUN_CHECK&quot;" ElementId="#BABHEFDC">Runs the specified checker with the given arguments</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_HPROF&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_hprof.htm">
      <Description>The DBMS_HPROF package provides an interface for profiling the execution of PL/SQL applications. It provides services for collecting the hierarchical profiler data, analyzing the raw profiler output and profiling information generation.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ANALYZE&quot;" ElementId="#BABECDHB">Analyzes the raw profiler output and produces hierarchical profiler information in database tables</SubProgram>
        <SubProgram Name="&quot;START_PROFILING&quot;" ElementId="#BABBJGHB">Starts hierarchical profiler data collection in the user's session</SubProgram>
        <SubProgram Name="&quot;STOP_PROFILING&quot;" ElementId="#BABHDEHJ">Stops profiler data collection in the user's session.s</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_HS_PARALLEL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_hsparallel.htm">
      <Description></Description>
      <SubPrograms>
        <SubProgram Name="&quot;CREATE_OR_REPLACE_VIEW&quot;" ElementId="#BEIGDJCF">Creates (or replaces) a read-only view to be referenced for retrieving the data from a remote table in parallel.</SubProgram>
        <SubProgram Name="&quot;CREATE_TABLE_TEMPLATE&quot;" ElementId="#BEIDHDJA">Writes out a CREATE TABLE template based on information gathered from the remote table. You can use the information to add any optimal Oracle CREATE TABLE clauses.</SubProgram>
        <SubProgram Name="&quot;DROP_VIEW&quot;" ElementId="#BEIDJFGF">Drops the view and internal objects created by the CREATE_OR_REPLACE_VIEW procedure. If the view has not already been created by the CREATE_OR_REPLACE_VIEW procedure, an error message is returned.</SubProgram>
        <SubProgram Name="&quot;LOAD_TABLE&quot;" ElementId="#BEIIJCEG">Loads the data from a remote table to a local Oracle table in parallel. If the local Oracle table does not already exist, it is created automatically.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_HS_PASSTHROUGH&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_hspass.htm">
      <Description>The DBMS_HS_PASSTHROUGH PL/SQL package allows you to send a statement directly to a non-Oracle system without being interpreted by the Oracle server. This can be useful if the non-Oracle system allows operations in statements for which there is no equivalent in Oracle.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ILM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_ilm.htm">
      <Description>The DBMS_ILM package provides an interface for implementing Information Lifecycle Management (ILM) strategies using Automatic Data Optimization (ADO) policies.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_TO_ILM&quot;" ElementId="#CACCHHJE">Adds the object specified through the argument to a particular ADO task and evaluates the ADO policies on this object</SubProgram>
        <SubProgram Name="&quot;ARCHIVESTATENAME&quot;" ElementId="#CACHAEJF">Returns the value of the ORA_ARCHIVE_STATE column of a row-archival enabled table</SubProgram>
        <SubProgram Name="&quot;EXECUTE_ILM&quot;" ElementId="#CACHBJFB">Executes an ADO task.</SubProgram>
        <SubProgram Name="&quot;EXECUTE_ILM_TASK&quot;" ElementId="#CACHBIAF">Executes an ADO task that has been evaluated previously</SubProgram>
        <SubProgram Name="&quot;PREVIEW_ILM&quot;" ElementId="#CACEIDAA">Evaluates all ADO policies in the scope specified by means of an argument</SubProgram>
        <SubProgram Name="&quot;REMOVE_FROM_ILM&quot;" ElementId="#CACIFEAB">Removes the object specified through the argument from a particular ADO task</SubProgram>
        <SubProgram Name="&quot;STOP_ILM&quot;" ElementId="#CACIBEEF">Stops ADO-related jobs created for a particular ADO task</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ILM_ADMIN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_ilm_admin.htm">
      <Description>The DBMS_ILM_ADMIN package provides an interface to customize Automatic Data Optimization (ADO) policy execution. In combination with partitioning and compression, ADO policies can be used to help implement an Information Lifecycle Management (ILM) strategy.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLEAR_HEAT_MAP_ALL&quot;" ElementId="#CDCIFAIH">Deletes all rows except the dummy row</SubProgram>
        <SubProgram Name="&quot;CLEAR_HEAT_MAP_TABLE&quot;" ElementId="#CDCBIDJD">Clears all or some statistics for the heat map table, deleting rows for a given table or segment which match a given pattern, or all such rows</SubProgram>
        <SubProgram Name="&quot;CUSTOMIZE_ILM&quot;" ElementId="#CDCGJADA">Customizes environment for ILM execution by specifying the values for ILM execution related parameters</SubProgram>
        <SubProgram Name="&quot;DISABLE_ILM&quot;" ElementId="#CDCBBJJD">Turns off all background ILM scheduling</SubProgram>
        <SubProgram Name="&quot;ENABLE_ILM&quot;" ElementId="#CDCIAAFJ">Turns on all background ILM scheduling</SubProgram>
        <SubProgram Name="&quot;SET_HEAT_MAP_ALL&quot;" ElementId="#CDCFHHDC">Updates or inserts heat map rows for all tables</SubProgram>
        <SubProgram Name="&quot;SET_HEAT_MAP_START&quot;" ElementId="#CDCCECEI">Sets the start date for collecting heat map data</SubProgram>
        <SubProgram Name="&quot;SET_HEAT_MAP_TABLE&quot;" ElementId="#CDCBGDEB">Updates or inserts a row for the specified table or segment</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_INMEMORY&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_inmemory.htm">
      <Description>The DBMS_INMEMORY package provides an interface for in-memory column store functionality.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;POPULATE&quot;" ElementId="#CBAHICAD">Forces population of a given table</SubProgram>
        <SubProgram Name="&quot;REPOPULATE&quot;" ElementId="#CBAIBBIE">Forces repopulation of a given table</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_IOT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_iot.htm">
      <Description>The DBMS_IOT package creates a table into which references to the chained rows for an index-organized table can be placed using the ANALYZE command. DBMS_IOT can also create an exception table into which references to the rows of an index-organized table that violate a constraint can be placed during the enable_constraint operation.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BUILD_CHAIN_ROWS_TABLE&quot;" ElementId="#i996772">Creates a table into which references to the chained rows for an index-organized table can be placed using the ANALYZE command</SubProgram>
        <SubProgram Name="&quot;BUILD_EXCEPTIONS_TABLE&quot;" ElementId="#i996821">Creates an exception table into which rows of an index-organized table that violate a constraint can be placed</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_JAVA&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_java.htm">
      <Description>The DBMS_JAVA package provides a PL/SQL interface for accessing database functionality from Java.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_JOB&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_job.htm">
      <Description>The DBMS_JOB package schedules and manages jobs in the job queue.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_LDAP&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_ldap.htm">
      <Description>The DBMS_LDAP package lets you access data from LDAP servers.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_LDAP_UTL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_ldaputl.htm">
      <Description>The DBMS_LDAP_UTL package contains the Oracle Extension utility functions.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_LIBCACHE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_libcac.htm">
      <Description>The DBMS_LIBCACHE package consists of one subprogram that prepares the library cache on an Oracle instance by extracting SQL and PL/SQL from a remote instance and compiling this SQL locally without execution. The value of compiling the cache of an instance is to prepare the information the application requires to execute in advance of failover or switchover.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;COMPILE_FROM_REMOTE&quot;" ElementId="#i996766">Extracts SQL in batch from the source instance and compiles the SQL at the target instance</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_LOB&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_lob.htm">
      <Description></Description>
      <SubPrograms>
        <SubProgram Name="&quot;APPEND&quot;" ElementId="#i997432">Appends the contents of the source LOB to the destination LOB</SubProgram>
        <SubProgram Name="&quot;CLOSE&quot;" ElementId="#i997518">Closes a previously opened internal or external LOB</SubProgram>
        <SubProgram Name="&quot;COMPARE&quot;" ElementId="#i1016668">Compares two entire LOBs or parts of two LOBs</SubProgram>
        <SubProgram Name="&quot;CONVERTTOBLOB&quot;" ElementId="#i1020355">Reads character data from a source CLOB or NCLOB instance, converts the character data to the specified character, writes the converted data to a destination BLOB instance in binary format, and returns the new offsets</SubProgram>
        <SubProgram Name="&quot;CONVERTTOCLOB&quot;" ElementId="#i1020356">Takes a source BLOB instance, converts the binary data in the source instance to character data using the specified character, writes the character data to a destination CLOB or NCLOB instance, and returns the new offsets</SubProgram>
        <SubProgram Name="&quot;COPY&quot;" ElementId="#i997674">Copies all, or part, of the source LOB to the destination LOB</SubProgram>
        <SubProgram Name="&quot;COPY_DBFS_LINK&quot;" ElementId="#BGBCJJDF">Copies the DBFS Link in the source LOB to the destination LOB</SubProgram>
        <SubProgram Name="&quot;COPY_FROM_DBFS_LINK&quot;" ElementId="#BGBDAAIF">Retrieves the data for the LOB from the DBFS store</SubProgram>
        <SubProgram Name="&quot;CREATETEMPORARY&quot;" ElementId="#i997788">Creates a temporary BLOB or CLOB and its corresponding index in the user's default temporary tablespace</SubProgram>
        <SubProgram Name="&quot;DBFS_LINK_GENERATE_PATH&quot;" ElementId="#BGBIHAJI">Returns a unique file path name for use in creating a DBFS Link</SubProgram>
        <SubProgram Name="&quot;ERASE&quot;" ElementId="#i997838">Erases all or part of a LOB</SubProgram>
        <SubProgram Name="&quot;FILECLOSE&quot;" ElementId="#i997934">Closes the file</SubProgram>
        <SubProgram Name="&quot;FILECLOSEALL&quot;" ElementId="#i998026">Closes all previously opened files</SubProgram>
        <SubProgram Name="&quot;FILEEXISTS&quot;" ElementId="#i998077">Checks if the file exists on the server</SubProgram>
        <SubProgram Name="&quot;FILEGETNAME&quot;" ElementId="#i998169">Gets the directory object name and file name</SubProgram>
        <SubProgram Name="&quot;FILEISOPEN&quot;" ElementId="#i998235">Checks if the file was opened using the input BFILE locators</SubProgram>
        <SubProgram Name="&quot;FILEOPEN&quot;" ElementId="#i998315">Opens a file</SubProgram>
        <SubProgram Name="&quot;FRAGMENT_DELETE&quot;" ElementId="#i998411">Deletes the data at the specified offset for the specified length from the LOB</SubProgram>
        <SubProgram Name="&quot;FRAGMENT_INSERT&quot;" ElementId="#CHDGBIBD">Inserts the specified data (limited to 32K) into the LOB at the specified offset</SubProgram>
        <SubProgram Name="&quot;FRAGMENT_MOVE&quot;" ElementId="#CHDJDHHF">Moves the amount of bytes (BLOB) or characters (CLOB/NCLOB) from the specified offset to the new offset specified</SubProgram>
        <SubProgram Name="&quot;FRAGMENT_REPLACE&quot;" ElementId="#CHDGBAHJ">Replaces the data at the specified offset with the specified data (not to exceed 32k)</SubProgram>
        <SubProgram Name="&quot;FREETEMPORARY&quot;" ElementId="#BGBDBFAD">Frees the temporary BLOB or CLOB in the default temporary tablespace</SubProgram>
        <SubProgram Name="&quot;GET_DBFS_LINK&quot;" ElementId="#BGBIEEBG">Returns the DBFS Link path associated with the specified SecureFile</SubProgram>
        <SubProgram Name="&quot;GET_DBFS_LINK_STATE&quot;" ElementId="#BGBCBHGD">Retrieves the current DBFS Link state of the specified SecureFile</SubProgram>
        <SubProgram Name="&quot;GETCHUNKSIZE&quot;" ElementId="#BGBCDIHI">Returns the amount of space used in the LOB chunk to store the LOB value</SubProgram>
        <SubProgram Name="&quot;GETCONTENTTYPE&quot;" ElementId="#BGBFJFCC">Returns the content ID string previously set by means of the SETCONTENTTYPE Procedure</SubProgram>
        <SubProgram Name="&quot;GETLENGTH&quot;" ElementId="#i998484">Gets the length of the LOB value</SubProgram>
        <SubProgram Name="&quot;GETOPTIONS&quot;" ElementId="#CHDIHDIC">Obtains settings corresponding to the option_type field for a particular LOB</SubProgram>
        <SubProgram Name="&quot;GET_STORAGE_LIMIT&quot;" ElementId="#i1012980">Returns the storage limit for LOBs in your database configuration</SubProgram>
        <SubProgram Name="&quot;INSTR&quot;" ElementId="#i998546">Returns the matching position of the nth occurrence of the pattern in the LOB</SubProgram>
        <SubProgram Name="&quot;ISOPEN&quot;" ElementId="#i998705">Checks to see if the LOB was already opened using the input locator</SubProgram>
        <SubProgram Name="&quot;ISSECUREFILE&quot;" ElementId="#CJHCGHBF">Returns TRUE if the LOB locator passed to is for a SecureFiles LOB, otherwise, returns FALSE</SubProgram>
        <SubProgram Name="&quot;ISTEMPORARY&quot;" ElementId="#i998745">Checks if the locator is pointing to a temporary LOB</SubProgram>
        <SubProgram Name="&quot;LOADBLOBFROMFILE&quot;" ElementId="#i998869">Loads BFILE data into an internal BLOB</SubProgram>
        <SubProgram Name="&quot;LOADCLOBFROMFILE&quot;" ElementId="#i998978">Loads BFILE data into an internal CLOB</SubProgram>
        <SubProgram Name="&quot;LOADFROMFILE&quot;" ElementId="#i998778">Loads BFILE data into an internal LOB</SubProgram>
        <SubProgram Name="&quot;MOVE_TO_DBFS_LINK&quot;" ElementId="#BGBJEGGG">Writes the specified SecureFile data to the DBFS store</SubProgram>
        <SubProgram Name="&quot;OPEN&quot;" ElementId="#BABGHBIF">Opens a LOB (internal, external, or temporary) in the indicated mode</SubProgram>
        <SubProgram Name="&quot;READ&quot;" ElementId="#i999170">Reads data from the LOB starting at the specified offset</SubProgram>
        <SubProgram Name="&quot;SET_DBFS_LINK&quot;" ElementId="#BGBHHHJC">Links the specified SecureFile to the specified path name. It does not copy the data to the path</SubProgram>
        <SubProgram Name="&quot;SETCONTENTTYPE&quot;" ElementId="#BGBBGICA">Sets the content type string for the data in the LOB</SubProgram>
        <SubProgram Name="&quot;SETOPTIONS&quot;" ElementId="#CHDHDDDD">Enables CSCE features on a per-LOB basis, overriding the default LOB column settings</SubProgram>
        <SubProgram Name="&quot;SUBSTR&quot;" ElementId="#i999349">Returns part of the LOB value starting at the specified offset</SubProgram>
        <SubProgram Name="&quot;TRIM&quot;" ElementId="#i999503">Trims the LOB value to the specified shorter length</SubProgram>
        <SubProgram Name="&quot;WRITE&quot;" ElementId="#i999593">Writes data to the LOB from a specified offset</SubProgram>
        <SubProgram Name="&quot;WRITEAPPEND&quot;" ElementId="#i999705">Writes a buffer to the end of a LOB</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_LOCK&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_lock.htm">
      <Description>The DBMS_LOCK package provides an interface to Oracle Lock Management services. You can request a lock of a specific mode, give it a unique name recognizable in another procedure in the same or another instance, change the lock mode, and release it.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_LOGMNR&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_logmnr.htm">
      <Description>The DBMS_LOGMNR package, one of a set of LogMiner packages, contains the subprograms you use to initialize the LogMiner tool and to begin and end a LogMiner session.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_LOGFILE&quot;" ElementId="#i77176">Adds a redo log file to the existing or newly created list of redo log files for LogMiner to process, so that if a new list is created, this marks the beginning of a LogMiner session</SubProgram>
        <SubProgram Name="&quot;COLUMN_PRESENT&quot;" ElementId="#i80784">Call this function for any row returned from the V$LOGMNR_CONTENTS view to determine if undo or redo column values exist for the column specified by the column_name input parameter to this function</SubProgram>
        <SubProgram Name="&quot;END_LOGMNR&quot;" ElementId="#i80896">Finishes a LogMiner session</SubProgram>
        <SubProgram Name="&quot;MINE_VALUE&quot;" ElementId="#i80918">Call this function for any row returned from the V$LOGMNR_CONTENTS view to retrieve the undo or redo column value of the column specified by the column_name input parameter to this function</SubProgram>
        <SubProgram Name="&quot;REMOVE_LOGFILE&quot;" ElementId="#i77231">Removes a redo log file from the list of redo log files for LogMiner to process</SubProgram>
        <SubProgram Name="&quot;START_LOGMNR&quot;" ElementId="#i77269">Initializes the LogMiner utility and starts LogMiner (unless the session was already started with a call to DBMS_LOGMNR.ADD_LOGFILE)</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_LOGMNR_D&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_logmnrd.htm">
      <Description>The DBMS_LOGMNR_D package, one of a set of LogMiner packages, contains two subprograms:</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BUILD&quot;" ElementId="#i77008">Extracts the LogMiner dictionary to either a flat file or one or more redo log files</SubProgram>
        <SubProgram Name="&quot;SET_TABLESPACE&quot;" ElementId="#i77096">Re-creates all LogMiner tables in an alternate tablespace</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_LOGSTDBY&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_lsbydb.htm">
      <Description>The DBMS_LOGSTDBY package provides subprograms for configuring and managing the logical standby database environment.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;APPLY_SET&quot;" ElementId="#BDCIEGEI">Sets the values of various parameters that configure and maintain SQL Apply.</SubProgram>
        <SubProgram Name="&quot;APPLY_UNSET&quot;" ElementId="#i997040">Restores the default values of various parameters that configure and maintain SQL Apply.</SubProgram>
        <SubProgram Name="&quot;BUILD&quot;" ElementId="#i997124">Ensures supplemental logging is enabled properly and builds the LogMiner dictionary.</SubProgram>
        <SubProgram Name="&quot;EDS_ADD_TABLE&quot;" ElementId="#BGBJHBGE">Adds EDS-based replication for the table. It should be invoked on the primary database first and then on the standby database.</SubProgram>
        <SubProgram Name="&quot;EDS_EVOLVE_AUTOMATIC&quot;" ElementId="#BGBFFJIE">Enables or disables automatic DDL handling for EDS tables.</SubProgram>
        <SubProgram Name="&quot;EDS_EVOLVE_MANUAL&quot;" ElementId="#BGBGHJIB">Allows you to evolve EDS tables manually (that is, manually take compensating actions based on DDLs on the base tables with EDS-replication).</SubProgram>
        <SubProgram Name="&quot;EDS_REMOVE_TABLE&quot;" ElementId="#BGBIEIDF">Removes EDS-based replication for the specified table. It also drops the shadow table and triggers.</SubProgram>
        <SubProgram Name="&quot;INSTANTIATE_TABLE&quot;" ElementId="#i1008139">Creates and populates a table in the standby database from a corresponding table in the primary database.</SubProgram>
        <SubProgram Name="&quot;IS_APPLY_SERVER&quot;" ElementId="#BGBBBDBA">This function returns TRUE if it is executed from PL/SQL in the context of a logical standby apply server process. This function is used in conjunction with triggers that have the fire_once parameter in the DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY subprogram set to FALSE (the default is TRUE). Such triggers are executed when the relevant target is updated by an apply process. This function can be used within the body of the trigger to ensure that the trigger takes different (or no) actions on the primary or on the standby.</SubProgram>
        <SubProgram Name="&quot;MAP_PRIMARY_SCN&quot;" ElementId="#BABEGDAE">Maps an SCN relevant to the primary database to a corresponding SCN at the logical standby database. The mapped SCN is conservative in nature, and can thus be used to flash back the logical standby database to compensate for a flashback database operation performed at the primary database.</SubProgram>
        <SubProgram Name="&quot;PREPARE_FOR_NEW_PRIMARY&quot;" ElementId="#BABHDEFF">Used after a failover, this procedure ensures a local logical standby database that was not involved in the failover has not processed more redo than the new primary database and reports the set of archive redo log files that must be replaced to ensure consistency</SubProgram>
        <SubProgram Name="&quot;PURGE_SESSION&quot;" ElementId="#BABCABAG">Identifies the archived redo log files that have been applied to the logical standby database and are no longer needed by SQL Apply</SubProgram>
        <SubProgram Name="&quot;REBUILD&quot;" ElementId="#BABCBCGF">Records relevant metadata (including the LogMiner dictionary) in the redo stream in case a database that has recently changed its role to a primary database following a failover operation fails to do so during the failover process</SubProgram>
        <SubProgram Name="&quot;SET_TABLESPACE&quot;" ElementId="#CHDIHFAF">Moves metadata tables required by SQL Apply to the user-specified tablespace. By default, the metadata tables are created in the SYSAUX tablespace.</SubProgram>
        <SubProgram Name="&quot;SKIP&quot;" ElementId="#i997288">Specifies rules that control database operations that should not be applied to the logical standby database</SubProgram>
        <SubProgram Name="&quot;SKIP_ERROR&quot;" ElementId="#i997648">Specifies rules regarding what action to take upon encountering errors.</SubProgram>
        <SubProgram Name="&quot;SKIP_TRANSACTION&quot;" ElementId="#i997765">Specifies transactions that should not be applied on the logical standby database. Be careful in using this procedure, because not applying specific transactions may cause data corruption at the logical standby database.</SubProgram>
        <SubProgram Name="&quot;UNSKIP&quot;" ElementId="#BGBFBFEH">Deletes rules specified by the SKIP procedure.</SubProgram>
        <SubProgram Name="&quot;UNSKIP_ERROR&quot;" ElementId="#i997837">Deletes rules specified by the SKIP_ERROR procedure.</SubProgram>
        <SubProgram Name="&quot;UNSKIP_TRANSACTION&quot;" ElementId="#i997855">Deletes rules specified by the SKIP_TRANSACTION procedure.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_LOGSTDBY_CONTEXT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_logstdby_context.htm">
      <Description>As of Oracle Database 12c release 1 (12.1), SQL Apply processes have access to a context namespace called LSBY_APPLY_CONTEXT. You can use the procedures provided in the DBMS_LOGSTDBY_CONTEXT package to set and retrieve various parameters associated with LSBY_APPLY_CONTEXT. This is useful when writing skip procedures that are registered with SQL Apply using the DBMS_LOGSTBDY.SKIP and DBMS_LOGSTDBY.SKIP_ERROR procedures.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLEAR_ALL_CONTEXT&quot;" ElementId="#BABHDBBE">Clears all parameters contained within namespace LSBY_APPLY_CONTEXT.</SubProgram>
        <SubProgram Name="&quot;CLEAR_CONTEXT&quot;" ElementId="#BABDJGHB">Clears the specific parameter.</SubProgram>
        <SubProgram Name="&quot;GET_CONTEXT&quot;" ElementId="#BABFEGDG">Retrieves the value for the specified parameter.</SubProgram>
        <SubProgram Name="&quot;SET_CONTEXT&quot;" ElementId="#BABEFICA">Sets the named parameter with the specified value.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_METADATA&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_metada.htm">
      <Description>The DBMS_METADATA package provides a way for you to retrieve metadata from the database dictionary as XML or creation DDL and to submit the XML to re-create the object.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_METADATA_DIFF&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_metadiff.htm">
      <Description>The DBMS_METADATA_DIFF package contains the interfaces for comparing two metadata documents in SXML format.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_MGD_ID_UTL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_mgd_id_utl.htm">
      <Description>The DBMS_MGD_ID_UTL package contains various functions and procedures that comprise the following utility subprograms:</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_MGWADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_mgwadm.htm">
      <Description>DBMS_MGWADM defines the Messaging Gateway administrative interface. The package and object types are owned by SYS.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_SUBSCRIBER&quot;" ElementId="#i1029908">Adds a subscriber used to consume messages from a source queue for propagation to a destination</SubProgram>
        <SubProgram Name="&quot;ALTER_AGENT&quot;" ElementId="#i997781">Alters Messaging Gateway agent parameters</SubProgram>
        <SubProgram Name="&quot;ALTER_JOB&quot;" ElementId="#CHDFFJGD">Alters the properties of a propagation job</SubProgram>
        <SubProgram Name="&quot;ALTER_MSGSYSTEM_LINK&quot;" ElementId="#i1029999">Alters the properties of a TIB/Rendezvous messaging system link</SubProgram>
        <SubProgram Name="&quot;ALTER_MSGSYSTEM_LINK&quot;" ElementId="#i1030090">Alters the properties of a WebSphere MQ messaging system link</SubProgram>
        <SubProgram Name="&quot;ALTER_PROPAGATION_SCHEDULE&quot;" ElementId="#i1030147">Alters a propagation schedule</SubProgram>
        <SubProgram Name="&quot;ALTER_SUBSCRIBER&quot;" ElementId="#i1030281">Alters the parameters of a subscriber used to consume messages from a source queue for propagation to a destination</SubProgram>
        <SubProgram Name="&quot;CLEANUP_GATEWAY&quot;" ElementId="#i1030285">Cleans up Messaging Gateway</SubProgram>
        <SubProgram Name="&quot;CREATE_AGENT&quot;" ElementId="#BABGJDJG">Creates a Messaging Gateway agent that will be used to process propagation jobs</SubProgram>
        <SubProgram Name="&quot;CREATE_JOB&quot;" ElementId="#CHDGGCEB">Creates a job used to propagate message from a source to a destination</SubProgram>
        <SubProgram Name="&quot;CREATE_MSGSYSTEM_LINK&quot;" ElementId="#i1030432">Creates a messaging system link to a TIB/Rendezvous messaging system</SubProgram>
        <SubProgram Name="&quot;CREATE_MSGSYSTEM_LINK&quot;" ElementId="#i1030567">Creates a messaging system link to a WebSphere MQ messaging system</SubProgram>
        <SubProgram Name="&quot;DB_CONNECT_INFO&quot;" ElementId="#i1030666">Configures connection information used by the Messaging Gateway agent for connections to Oracle Database</SubProgram>
        <SubProgram Name="&quot;DISABLE_JOB&quot;" ElementId="#CHDFAHAH">Disables a propagation job</SubProgram>
        <SubProgram Name="&quot;DISABLE_PROPAGATION_SCHEDULE&quot;" ElementId="#i1030712">Disables a propagation schedule</SubProgram>
        <SubProgram Name="&quot;ENABLE_JOB&quot;" ElementId="#CHDEJJBC">Enables a propagation job</SubProgram>
        <SubProgram Name="&quot;ENABLE_PROPAGATION_SCHEDULE&quot;" ElementId="#i1030743">Enables a propagation schedule</SubProgram>
        <SubProgram Name="&quot;REGISTER_FOREIGN_QUEUE&quot;" ElementId="#i1030839">Registers a non-Oracle queue entity in Messaging Gateway</SubProgram>
        <SubProgram Name="&quot;REMOVE_AGENT&quot;" ElementId="#BABCFIEC">Removes a Messaging Gateway agent</SubProgram>
        <SubProgram Name="&quot;REMOVE_JOB&quot;" ElementId="#CHDIIBIC">Removes a propagation job</SubProgram>
        <SubProgram Name="&quot;REMOVE_MSGSYSTEM_LINK&quot;" ElementId="#i1030879">Removes a messaging system link for a non-Oracle messaging system</SubProgram>
        <SubProgram Name="&quot;REMOVE_OPTION&quot;" ElementId="#CHDCGDBB">Removes a Messaging Gateway configuration option</SubProgram>
        <SubProgram Name="&quot;REMOVE_SUBSCRIBER&quot;" ElementId="#i1030885">Removes a subscriber used to consume messages from a source queue for propagation to a destination</SubProgram>
        <SubProgram Name="&quot;RESET_JOB&quot;" ElementId="#i1030972">Resets the propagation error state for a propagation job</SubProgram>
        <SubProgram Name="&quot;RESET_SUBSCRIBER&quot;" ElementId="#CHDEHCED">Resets the propagation error state for a subscriber</SubProgram>
        <SubProgram Name="&quot;SCHEDULE_PROPAGATION&quot;" ElementId="#i1031125">Schedules message propagation from a source to a destination</SubProgram>
        <SubProgram Name="&quot;SET_LOG_LEVEL&quot;" ElementId="#i1031022">Dynamically alters the Messaging Gateway agent logging level</SubProgram>
        <SubProgram Name="&quot;SET_OPTION&quot;" ElementId="#CHDBIGFC">Sets a Messaging Gateway configuration option</SubProgram>
        <SubProgram Name="&quot;SHUTDOWN&quot;" ElementId="#i1031129">Shuts down the Messaging Gateway agent</SubProgram>
        <SubProgram Name="&quot;STARTUP&quot;" ElementId="#i997860">Starts the Messaging Gateway agent</SubProgram>
        <SubProgram Name="&quot;UNREGISTER_FOREIGN_QUEUE&quot;" ElementId="#i998194">Removes a non-Oracle queue entity in Messaging Gateway</SubProgram>
        <SubProgram Name="&quot;UNSCHEDULE_PROPAGATION&quot;" ElementId="#i998486">Removes a propagation schedule</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_MGWMSG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_mgwmsg.htm">
      <Description>DBMS_MGWMSG provides:</Description>
      <SubPrograms>
        <SubProgram Name="&quot;LCR_TO_XML&quot;" ElementId="#i997376">Converts a SYS.ANYDATA object encapsulating a row LCR (LCR$_ROW_RECORD) or a DDL LCR (LCR$_DDL_RECORD) to a SYS.XMLTYPE object</SubProgram>
        <SubProgram Name="&quot;NVARRAY_ADD&quot;" ElementId="#CEGEICGC">Appends a name-value element to the end of a name-value array</SubProgram>
        <SubProgram Name="&quot;NVARRAY_FIND_NAME&quot;" ElementId="#i997780">Searches a name-value array for the element with the name you specify in p_name</SubProgram>
        <SubProgram Name="&quot;NVARRAY_FIND_NAME_TYPE&quot;" ElementId="#i997815">Searches a name-value array for an element with the name and value type you specify</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET&quot;" ElementId="#CEGEFIJB">Gets the name-value element of the name you specify in p_name from a name-value array</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_BOOLEAN&quot;" ElementId="#i997438">Gets the value of the name-value array element that you specify in p_name and with the BOOLEAN_VALUE value type</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_BYTE&quot;" ElementId="#CEGCIHGD">Gets the value of the name-value array element that you specify in p_name and with the BYTE_VALUE value type</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_DATE&quot;" ElementId="#i997746">Gets the value of the name-value array element that you specify in p_name and with the DATE_VALUE value type</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_DOUBLE&quot;" ElementId="#i997644">Gets the value of the name-value array element that you specify in p_name and with the DOUBLE_VALUE value type</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_FLOAT&quot;" ElementId="#i997610">Gets the value of the name-value array element that you specify in p_name and with the FLOAT_VALUE value type</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_INTEGER&quot;" ElementId="#CEGEFBAG">Gets the value of the name-value array element that you specify in p_name and with the INTEGER_VALUE value type</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_LONG&quot;" ElementId="#i997576">Gets the value of the name-value array element that you specify in p_name and with the LONG_VALUE value type</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_RAW&quot;" ElementId="#i997712">Gets the value of the name-value array element that you specify in p_name and with the RAW_VALUE value type</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_SHORT&quot;" ElementId="#i997507">Gets the value of the name-value array element that you specify in p_name and with the SHORT_VALUE value type</SubProgram>
        <SubProgram Name="&quot;NVARRAY_GET_TEXT&quot;" ElementId="#i997678">Gets the value of the name-value array element that you specify in p_name and with the TEXT_VALUE value type</SubProgram>
        <SubProgram Name="&quot;XML_TO_LCR&quot;" ElementId="#CEGBIJHH">Converts a SYS.XMLTYPE object to a SYS.ANYDATA object encapsulating a row LCR (LCR$_ROW_RECORD) or a DDL LCR (LCR$_DDL_RECORD)</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_MONITOR&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_monitor.htm">
      <Description>The DBMS_MONITOR package let you use PL/SQL for controlling additional tracing and statistics gathering.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_MVIEW&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_mview.htm">
      <Description>DBMS_MVIEW enables you to understand capabilities for materialized views and potential materialized views, including their rewrite availability. It also enables you to refresh materialized views that are not part of the same refresh group and purge logs.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BEGIN_TABLE_REORGANIZATION&quot;" ElementId="#CEGGFHDA">Performs a process to preserve materialized view data needed for refresh</SubProgram>
        <SubProgram Name="&quot;END_TABLE_REORGANIZATION&quot;" ElementId="#i996947">Ensures that the materialized view data for the master table is valid and that the master table is in the proper state</SubProgram>
        <SubProgram Name="&quot;ESTIMATE_MVIEW_SIZE&quot;" ElementId="#i1000942">Estimates the size of a materialized view that you might create, in bytes and rows</SubProgram>
        <SubProgram Name="&quot;EXPLAIN_MVIEW&quot;" ElementId="#CEGGEHHC">Explains what is possible with a materialized view or potential materialized view</SubProgram>
        <SubProgram Name="&quot;EXPLAIN_REWRITE&quot;" ElementId="#i997015">Explains why a query failed to rewrite or why the optimizer chose to rewrite a query with a particular materialized view or materialized views</SubProgram>
        <SubProgram Name="&quot;I_AM_A_REFRESH&quot;" ElementId="#CEGHBIBJ">Returns the value of the I_AM_REFRESH package state</SubProgram>
        <SubProgram Name="&quot;PMARKER&quot;" ElementId="#i997068">Returns a partition marker from a rowid, and is used for Partition Change Tracking (PCT)</SubProgram>
        <SubProgram Name="&quot;PURGE_DIRECT_LOAD_LOG&quot;" ElementId="#i997090">Purges rows from the direct loader log after they are no longer needed by any materialized views (used with data warehousing)</SubProgram>
        <SubProgram Name="&quot;PURGE_LOG&quot;" ElementId="#i997108">Purges rows from the materialized view log</SubProgram>
        <SubProgram Name="&quot;PURGE_MVIEW_FROM_LOG&quot;" ElementId="#CEGIEEEE">Purges rows from the materialized view log</SubProgram>
        <SubProgram Name="&quot;REFRESH&quot;" ElementId="#i997194">Refreshes one or more materialized views that are not members of the same refresh group</SubProgram>
        <SubProgram Name="&quot;REFRESH_ALL_MVIEWS&quot;" ElementId="#i997279">Refreshes all materialized views that do not reflect changes to their master table or master materialized view</SubProgram>
        <SubProgram Name="&quot;REFRESH_DEPENDENT&quot;" ElementId="#i997332">Refreshes all table-based materialized views that depend on a specified master table or master materialized view, or list of master tables or master materialized views</SubProgram>
        <SubProgram Name="&quot;REGISTER_MVIEW&quot;" ElementId="#CEGHDBIJ">Enables the administration of individual materialized views</SubProgram>
        <SubProgram Name="&quot;UNREGISTER_MVIEW&quot;" ElementId="#i997476">Enables the administration of individual materialized views once invoked at a master site or master materialized view site to unregister a materialized view</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_NETWORK_ACL_ADMIN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_networkacl_adm.htm">
      <Description>The DBMS_NETWORK_ACL_ADMIN package provides the interface to administer the network Access Control List (ACL).</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_PRIVILEGE&quot;" ElementId="#BABHJEHG">[DEPRECATED] Adds a privilege to grant or deny the network access to the user in an access control list (ACL)</SubProgram>
        <SubProgram Name="&quot;APPEND_HOST_ACE&quot;" ElementId="#CHDHBHGA">Appends an access control entry (ACE) to the access control list (ACL) of a network host.</SubProgram>
        <SubProgram Name="&quot;APPEND_HOST_ACL&quot;" ElementId="#CHDBFHDD">Appends access control entries (ACE) of an access control list (ACL) to the ACL of a network host</SubProgram>
        <SubProgram Name="&quot;APPEND_WALLET_ACE&quot;" ElementId="#CHDCGCBI">Appends an access control entry (ACE) to the access control list (ACL) of a wallet</SubProgram>
        <SubProgram Name="&quot;APPEND_WALLET_ACL&quot;" ElementId="#CHDEBGIE">Appends access control entries (ACE) of an access control list (ACL) to the ACL of a wallet</SubProgram>
        <SubProgram Name="&quot;ASSIGN_ACL&quot;" ElementId="#BABDIGJC">[DEPRECATED] Assigns an access control list (ACL) to a host computer, domain, or IP subnet, and if specified, the TCP port range.</SubProgram>
        <SubProgram Name="&quot;ASSIGN_WALLET_ACL&quot;" ElementId="#BHAHFACB">[DEPRECATED] Assigns an access control list (ACL) to a wallet</SubProgram>
        <SubProgram Name="&quot;CHECK_PRIVILEGE&quot;" ElementId="#CHDFJHHJ">[DEPRECATED] Checks if a privilege is granted or denied the user in an access control list (ACL)</SubProgram>
        <SubProgram Name="&quot;CHECK_PRIVILEGE_ACLID&quot;" ElementId="#CHDJICBH">[DEPRECATED] Checks if a privilege is granted to or denied from the user in an ACL by specifying the object ID of the access control list</SubProgram>
        <SubProgram Name="&quot;CREATE_ACL&quot;" ElementId="#BABIGEGG">[DEPRECATED] Creates an access control list (ACL) with an initial privilege setting</SubProgram>
        <SubProgram Name="&quot;DELETE_PRIVILEGE&quot;" ElementId="#BABJHGBE">[DEPRECATED] Deletes a privilege in an access control list (ACL)</SubProgram>
        <SubProgram Name="&quot;DROP_ACL&quot;" ElementId="#BABHICFB">[DEPRECATED] Drops an access control list (ACL)</SubProgram>
        <SubProgram Name="&quot;REMOVE_HOST_ACE&quot;" ElementId="#CHDEFGHF">Removes privileges from access control entries (ACE) in the access control list (ACL) of a network host matching the given ACE</SubProgram>
        <SubProgram Name="&quot;REMOVE_WALLET_ACE&quot;" ElementId="#CHDHJBCE">Removes privileges from access control entries (ACE) in the access control list (ACL) of a wallet matching the given ACE</SubProgram>
        <SubProgram Name="&quot;SET_HOST_ACL&quot;" ElementId="#CHDEABGI">Sets the access control list (ACL) of a network host which controls access to the host from the database</SubProgram>
        <SubProgram Name="&quot;SET_WALLET_ACL&quot;" ElementId="#CHDDGJEG">Sets the access control list (ACL) of a wallet which controls access to the wallet from the database</SubProgram>
        <SubProgram Name="&quot;UNASSIGN_ACL&quot;" ElementId="#BABBJCJD">[DEPRECATED] Unassigns the access control list (ACL) currently assigned to a network host</SubProgram>
        <SubProgram Name="&quot;UNASSIGN_WALLET_ACL&quot;" ElementId="#BHAIBDBD">[DEPRECATED] Unassigns the access control list (ACL) currently assigned to a wallet</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_NETWORK_ACL_UTILITY&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_networkacl_utl.htm">
      <Description>The DBMS_NETWORK_ACL_UTILITY package provides the utility functions to facilitate the evaluation of access control list (ACL) assignments governing TCP connections to network hosts.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CONTAINS_HOST&quot;" ElementId="#CHDCFCIH">Determines if the given host is equal to or contained in the given host, domain, or subnet</SubProgram>
        <SubProgram Name="&quot;DOMAIN_LEVEL&quot;" ElementId="#CHDJFAID">Returns the domain level of the given host name, domain, or subnet</SubProgram>
        <SubProgram Name="&quot;DOMAINS&quot;" ElementId="#CHDGABBE">For a given host, this function returns the domains whose ACL assigned is used to determine if a user has the privilege to access the given host or not.</SubProgram>
        <SubProgram Name="&quot;EQUALS_HOST&quot;" ElementId="#CHDCDIAG">Determines if the two given hosts, domains, or subnets are equal</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ODCI&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_odci.htm">
      <Description>DBMS_ODCI package contains a single user function related to the use of Data Cartridges.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ESTIMATE_CPU_UNITS&quot;" ElementId="#i996771">Returns the approximate number of CPU instructions (in thousands) corresponding to a specified time interval (in seconds)</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_OFFLINE_OG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_offog.htm">
      <Description>The DBMS_OFFLINE_OG package contains the public interface for offline instantiation of master groups.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_OUTLN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_outln.htm">
      <Description>The DBMS_OUTLN package, synonymous with OUTLN_PKG, contains the functional interface for subprograms associated with the management of stored outlines.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_OUTPUT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_output.htm">
      <Description>The DBMS_OUTPUT package enables you to send messages from stored procedures, packages, and triggers. The package is especially useful for displaying PL/SQL debugging information.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;DISABLE&quot;" ElementId="#i999434">Disables message output</SubProgram>
        <SubProgram Name="&quot;ENABLE&quot;" ElementId="#i999293">Enables message output</SubProgram>
        <SubProgram Name="&quot;GET_LINE&quot;" ElementId="#BABGBACJ">Retrieves one line from buffer</SubProgram>
        <SubProgram Name="&quot;GET_LINES&quot;" ElementId="#i1000253">Retrieves an array of lines from buffer</SubProgram>
        <SubProgram Name="&quot;NEW_LINE&quot;" ElementId="#i1000062">Terminates a line created with PUT</SubProgram>
        <SubProgram Name="&quot;PUT&quot;" ElementId="#BABGHBIA">Places a partial line in the buffer</SubProgram>
        <SubProgram Name="&quot;PUT_LINE&quot;" ElementId="#i1000105">Places line in buffer</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PARALLEL_EXECUTE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_parallel_ex.htm">
      <Description>The DBMS_PARALLEL_EXECUTE package enables incremental update of table data in parallel.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADM_DROP_CHUNKS&quot;" ElementId="#CHDJFGBI">Drops all chunks of the specified task owned by the specified owner</SubProgram>
        <SubProgram Name="&quot;ADM_DROP_TASK&quot;" ElementId="#CHDJFBCC">Drops the task of the given user and all related chunks</SubProgram>
        <SubProgram Name="&quot;ADM_TASK_STATUS&quot;" ElementId="#CHDEHIBJ">Returns the task status</SubProgram>
        <SubProgram Name="&quot;ADM_STOP_TASK&quot;" ElementId="#CHDDCJEF">Stops the task of the given owner and related job slaves</SubProgram>
        <SubProgram Name="&quot;CREATE_TASK&quot;" ElementId="#CHDDGEJG">Creates a task for the current user</SubProgram>
        <SubProgram Name="&quot;CREATE_CHUNKS_BY_NUMBER_COL&quot;" ElementId="#CHDHFCDJ">Chunks the table associated with the given task by the specified column.</SubProgram>
        <SubProgram Name="&quot;CREATE_CHUNKS_BY_ROWID&quot;" ElementId="#CHDGCHFA">Chunks the table associated with the given task by ROWID</SubProgram>
        <SubProgram Name="&quot;CREATE_CHUNKS_BY_SQL&quot;" ElementId="#CHDJEHJI">Chunks the table associated with the given task by means of a user-provided SELECT statement</SubProgram>
        <SubProgram Name="&quot;DROP_TASK&quot;" ElementId="#CHDEHCDE">Drops the task and all related chunks</SubProgram>
        <SubProgram Name="&quot;DROP_CHUNKS&quot;" ElementId="#CHDHCHGC">Drops the task's chunks</SubProgram>
        <SubProgram Name="&quot;GENERATE_TASK_NAME&quot;" ElementId="#CHDEJHGC">Returns a unique name for a task</SubProgram>
        <SubProgram Name="&quot;GET_NUMBER_COL_CHUNK&quot;" ElementId="#CHDFADCH">Picks an unassigned NUMBER chunk and changes it to ASSIGNED</SubProgram>
        <SubProgram Name="&quot;GET_ROWID_CHUNK&quot;" ElementId="#CHDHAAEB">Picks an unassigned ROWID chunk and changes it to ASSIGNED</SubProgram>
        <SubProgram Name="&quot;PURGE_PROCESSED_CHUNKS&quot;" ElementId="#CHDEAGGC">Deletes all the processed chunks whose status is PROCESSED or PROCESSED_WITH_ERROR</SubProgram>
        <SubProgram Name="&quot;RESUME_TASK&quot;" ElementId="#CHDBIBEC">Retries the given the task if the RUN_TASK Procedure finished with an error, or resumes the task if a crash occurred.</SubProgram>
        <SubProgram Name="&quot;RUN_TASK&quot;" ElementId="#CHDIBHHB">Executes the specified SQL statement on the chunks in parallel</SubProgram>
        <SubProgram Name="&quot;SET_CHUNK_STATUS&quot;" ElementId="#CHDIJDCH">Sets the status of the chunk</SubProgram>
        <SubProgram Name="&quot;STOP_TASK&quot;" ElementId="#CHDBECBG">Stops the task and related job slaves</SubProgram>
        <SubProgram Name="&quot;TASK_STATUS&quot;" ElementId="#CHDJHFAB">Returns the task status</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PART&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_part.htm">
      <Description>The DBMS_PART package provides an interface for maintenance and management operations on partitioned objects.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLEANUP_GIDX&quot;" ElementId="#BEHHJDGI">Gathers the list of global indexes where optimized asynchronous index maintenance has taken place to clean up entries pointing to data segments that no longer exist</SubProgram>
        <SubProgram Name="&quot;CLEANUP_ONLINE_OP&quot;" ElementId="#BEHFAAJF">Cleans up failed online move operations</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PCLXUTIL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_pclxut.htm">
      <Description>The DBMS_PCLXUTIL package provides intra-partition parallelism for creating partition-wise local indexes. DBMS_PCLXUTIL circumvents the limitation that, for local index creation, the degree of parallelism is restricted to the number of partitions as only one parallel execution server process for each partition is used.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PDB&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_pdb.htm">
      <Description>The DBMS_PDB package provides an interface to examine and manipulate data about pluggable databases.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CHECK_PLUG_COMPATIBILITY&quot;" ElementId="#BGBIAFID">Uses an XML file describing a pluggable database (PDB) to determine whether it may be plugged into a given multitenant container database (CDB)</SubProgram>
        <SubProgram Name="&quot;DESCRIBE&quot;" ElementId="#BGBFHCBA">Generates an XML file describing the specified pluggable database (PDB)</SubProgram>
        <SubProgram Name="&quot;RECOVER&quot;" ElementId="#BGBCJIFB">Generates an XML file describing a pluggable database by using data files belonging to the pluggable database (PDB)</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PERF&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_perf.htm">
      <Description>The DBMS_PERF package provides and interface to generate active reports for monitoring database performance</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PIPE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_pipe.htm">
      <Description>The DBMS_PIPE package lets two or more sessions in the same instance communicate. Oracle pipes are similar in concept to the pipes used in UNIX, but Oracle pipes are not implemented using the operating system pipe mechanisms.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PREDICTIVE_ANALYTICS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_predan.htm">
      <Description>Data mining can discover useful information buried in vast amounts of data. However, it is often the case that both the programming interfaces and the data mining expertise required to obtain these results are too complex for use by the wide audiences that can obtain benefits from using Oracle Data Mining.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;EXPLAIN&quot;" ElementId="#CACBACDF">Ranks attributes in order of influence in explaining a target column.</SubProgram>
        <SubProgram Name="&quot;PREDICT&quot;" ElementId="#CACGGDEC">Predicts the value of a target column based on values in the input data.</SubProgram>
        <SubProgram Name="&quot;PROFILE&quot;" ElementId="#CACHJICB">Generates rules that identify the records that have the same target value.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PREPROCESSOR&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_preproc.htm">
      <Description>The DBMS_PREPROCESSOR package provides an interface to print or retrieve the source text of a PL/SQL unit in its post-processed form.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GET_POST_PROCESSED_SOURCE&quot;" ElementId="#CHDDDIHB">Returns the post-processed source text</SubProgram>
        <SubProgram Name="&quot;PRINT_POST_PROCESSED_SOURCE&quot;" ElementId="#CHDCBEBF">Prints post-processed source text</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PRIVILEGE_CAPTURE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_priv_prof.htm">
      <Description>The DBMS_PRIVILEGE_CAPTURE package provides an interface to database privilege analysis.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CREATE_CAPTURE&quot;" ElementId="#BABJBFDF">Creates a policy that specifies the conditions for analyzing privilege use.</SubProgram>
        <SubProgram Name="&quot;DISABLE_CAPTURE&quot;" ElementId="#BABGBFDC">Stops the recording of privilege use for a specified privilege analysis policy</SubProgram>
        <SubProgram Name="&quot;DROP_CAPTURE&quot;" ElementId="#BABBBIEJ">Removes a privilege analysis policy together with the data recorded</SubProgram>
        <SubProgram Name="&quot;ENABLE_CAPTURE&quot;" ElementId="#BABDFCHD">Starts the recording of privilege analysis for a specified privilege analysis policy</SubProgram>
        <SubProgram Name="&quot;GENERATE_RESULT&quot;" ElementId="#BABFBIAG">Populates the privilege analysis data dictionary views with data</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PROFILER&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_profil.htm">
      <Description>The DBMS_PROFILER package provides an interface to profile existing PL/SQL applications and identify performance bottlenecks. You can then collect and persistently store the PL/SQL profiler data.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;FLUSH_DATA&quot;" ElementId="#i999978">Flushes profiler data collected in the user's session</SubProgram>
        <SubProgram Name="&quot;GET_VERSION&quot;" ElementId="#i999998">Gets the version of this API</SubProgram>
        <SubProgram Name="&quot;INTERNAL_VERSION_CHECK&quot;" ElementId="#i1000064">Verifies that this version of the DBMS_PROFILER package can work with the implementation in the database</SubProgram>
        <SubProgram Name="&quot;PAUSE_PROFILER&quot;" ElementId="#i1000101">Pauses profiler data collection</SubProgram>
        <SubProgram Name="&quot;RESUME_PROFILER&quot;" ElementId="#i1000092">Resumes profiler data collection</SubProgram>
        <SubProgram Name="&quot;START_PROFILER&quot;" ElementId="#i1000047">Starts profiler data collection in the user's session</SubProgram>
        <SubProgram Name="&quot;STOP_PROFILER&quot;" ElementId="#i997210">Stops profiler data collection in the user's session</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_PROPAGATION_ADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_prop_a.htm">
      <Description>The DBMS_PROPAGATION_ADM package, one of a set of Oracle Streams packages, provides administrative interfaces for configuring a propagation from a source queue to a destination queue.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ALTER_PROPAGATION&quot;" ElementId="#i996796">Adds, alters, or removes a rule set for a propagation</SubProgram>
        <SubProgram Name="&quot;CREATE_PROPAGATION&quot;" ElementId="#i996840">Creates a propagation and specifies the source queue, destination queue, and rule set for the propagation</SubProgram>
        <SubProgram Name="&quot;DROP_PROPAGATION&quot;" ElementId="#i996928">Drops a propagation</SubProgram>
        <SubProgram Name="&quot;START_PROPAGATION&quot;" ElementId="#CDEGDCHB">Starts a propagation</SubProgram>
        <SubProgram Name="&quot;STOP_PROPAGATION&quot;" ElementId="#CDECBIHB">Stops a propagation</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_QOPATCH&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_qopatch.htm">
      <Description>The DBMS_QOPATCH package provides an interface to view the installed database patches.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GET_OPATCH_BUGS&quot;" ElementId="#CEGGFIAA">Provides a bugs list for a patch in XML format if the patch number is given. If patch is not given then it lists all the bugs installed in all the patches in XML format.</SubProgram>
        <SubProgram Name="&quot;GET_OPATCH_COUNT&quot;" ElementId="#CEGCCBJC">Provides the total number of installed patches in XML format</SubProgram>
        <SubProgram Name="&quot;GET_OPATCH_DATA&quot;" ElementId="#CEGHCFBA">Provides top level patch information for the patch (such as Patch ID, patch creation time) in the XML element</SubProgram>
        <SubProgram Name="&quot;GET_OPATCH_FILES&quot;" ElementId="#CEGCBFGF">Provides the list of files modified in the given patch number in XML format</SubProgram>
        <SubProgram Name="&quot;GET_OPATCH_INSTALL_INFO&quot;" ElementId="#CEGGJJDB">Returns the XML element containing the ORACLE_HOME details such as patch and inventory location</SubProgram>
        <SubProgram Name="&quot;GET_OPATCH_LIST&quot;" ElementId="#CEGGCEGG">Provides list of patches installed as an XML element from the XML inventory</SubProgram>
        <SubProgram Name="&quot;GET_OPATCH_LSINVENTORY&quot;" ElementId="#CEGJFJGB">Returns whole opatch inventory as XML instance document.</SubProgram>
        <SubProgram Name="&quot;GET_OPATCH_OLAYS&quot;" ElementId="#CEGJEJDI">Provides overlay patches for a given patch as XML element</SubProgram>
        <SubProgram Name="&quot;GET_OPATCH_PREQS&quot;" ElementId="#CEGDDDIF">Provides prerequisite patches for a given patch as XML element</SubProgram>
        <SubProgram Name="&quot;GET_OPATCH_XSLT&quot;" ElementId="#CEGFEHCI">Returns the style-sheet for the opatch XML inventory presentation</SubProgram>
        <SubProgram Name="&quot;GET_PENDING_ACTIVITY&quot;" ElementId="#CEGEEEBJ">Returns the information related to SQL patches applied on a single instance by querying the binary inventory</SubProgram>
        <SubProgram Name="&quot;GET_SQLPATCH_STATUS&quot;" ElementId="#CEGDEHCC">Displays the SQL patch status by querying from SQL patch registry to produce complete patch level information</SubProgram>
        <SubProgram Name="&quot;IS_PATCH_INSTALLED&quot;" ElementId="#CEGEECEB">Provides information (such as patchID, application date, and SQL patch information) on the installed patch as XML node by querying the XML inventory</SubProgram>
        <SubProgram Name="&quot;PATCH_CONFLICT_DETECTION&quot;" ElementId="#CEGCAABG">Returns the conflicting patch for a given file, if it conflicts with an existing patch</SubProgram>
        <SubProgram Name="&quot;SET_CURRENT_OPINST&quot;" ElementId="#CEGFGAGF">Sets the node name and instance to get the inventory details specific to it in an Oracle Real Application Clusters (RAC) environment</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_RANDOM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_random.htm">
      <Description>The DBMS_RANDOM package provides a built-in random number generator. DBMS_RANDOM is not intended for cryptography.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;INITIALIZE&quot;" ElementId="#i998255">Initializes the package with a seed value</SubProgram>
        <SubProgram Name="&quot;NORMAL&quot;" ElementId="#i997841">Returns random numbers in a normal distribution</SubProgram>
        <SubProgram Name="&quot;RANDOM&quot;" ElementId="#i998740">Generates a random number</SubProgram>
        <SubProgram Name="&quot;SEED&quot;" ElementId="#i996798">Resets the seed</SubProgram>
        <SubProgram Name="&quot;STRING&quot;" ElementId="#i996825">Gets a random string</SubProgram>
        <SubProgram Name="&quot;TERMINATE&quot;" ElementId="#i998149">Terminates package</SubProgram>
        <SubProgram Name="&quot;VALUE&quot;" ElementId="#i998095">Gets a random number, greater than or equal to 0 and less than 1, with 38 digits to the right of the decimal (38-digit precision), while the overloaded function gets a random Oracle number x, where x is greater than or equal to low and less than high</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_RECTIFIER_DIFF&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_recdif.htm">
      <Description>The DBMS_RECTIFIER_DIFF package provides an interface used to detect and resolve data inconsistencies between two replicated sites.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_REDACT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_redact.htm">
      <Description>The DBMS_REDACT package provides an interface to Oracle Data Redaction, which enables you to mask (redact) data that is returned from queries issued by low-privileged users or an application.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_POLICY&quot;" ElementId="#CHDCBEAC">Defines a Data Redaction policy for a table or view</SubProgram>
        <SubProgram Name="&quot;ALTER_POLICY&quot;" ElementId="#CHDBBJHB">Alters a Data Redaction policy for a table or view</SubProgram>
        <SubProgram Name="&quot;DISABLE_POLICY&quot;" ElementId="#CHDDFHDG">Disables a Data Redaction policy</SubProgram>
        <SubProgram Name="&quot;DROP_POLICY&quot;" ElementId="#CHDHIEBD">Drops a Data Redaction policy</SubProgram>
        <SubProgram Name="&quot;ENABLE_POLICY&quot;" ElementId="#CHDCHDAE">Enables a Data Redaction policy</SubProgram>
        <SubProgram Name="&quot;UPDATE_FULL_REDACTION_VALUES&quot;" ElementId="#CHDCEEGC">Modifies the default displayed values for a Data Redaction policy for full redaction</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_REDEFINITION&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_redefi.htm">
      <Description>The DBMS_REDEFINITION package provides an interface to perform an online redefinition of tables.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ABORT_REDEF_TABLE&quot;" ElementId="#i998327">Cleans up errors that occur during the redefinition process and removes all temporary objects created by the reorganization process</SubProgram>
        <SubProgram Name="&quot;CAN_REDEF_TABLE&quot;" ElementId="#i998726">Determines if a given table can be redefined online</SubProgram>
        <SubProgram Name="&quot;COPY_TABLE_DEPENDENTS&quot;" ElementId="#i999656">Copies the dependent objects of the original table onto the interim table</SubProgram>
        <SubProgram Name="&quot;FINISH_REDEF_TABLE&quot;" ElementId="#i998731">Completes the redefinition process</SubProgram>
        <SubProgram Name="&quot;REDEF_TABLE&quot;" ElementId="#CHDDDDFG">Provides a single push-button interface that integrates several redefinition steps</SubProgram>
        <SubProgram Name="&quot;REGISTER_DEPENDENT_OBJECT&quot;" ElementId="#i998995">Registers a dependent object (index, trigger, constraint or materialized view log) on the table being redefined and the corresponding dependent object on the interim table</SubProgram>
        <SubProgram Name="&quot;START_REDEF_TABLE&quot;" ElementId="#CBBHFJAI">Initiates the redefinition process</SubProgram>
        <SubProgram Name="&quot;SYNC_INTERIM_TABLE&quot;" ElementId="#i998432">Keeps the interim table synchronized with the original table</SubProgram>
        <SubProgram Name="&quot;UNREGISTER_DEPENDENT_OBJECT&quot;" ElementId="#CBBHCDDC">Unregisters a dependent object (index, trigger, constraint or materialized view log) on the table being redefined and the corresponding dependent object on the interim table</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_REFRESH&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_refrsh.htm">
      <Description>The DBMS_REFRESH package enables you to create groups of materialized views that can be refreshed together to a transactionally consistent point in time.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_REPAIR&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_repair.htm">
      <Description>The DBMS_REPAIR package contains data corruption repair procedures that enable you to detect and repair corrupt blocks in tables and indexes. You can address corruptions where possible and continue to use objects while you attempt to rebuild or repair them.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADMIN_TABLES&quot;" ElementId="#i1000098">Provides administrative functions for the DBMS_REPAIR package repair and orphan key tables, including create, purge, and drop functions</SubProgram>
        <SubProgram Name="&quot;CHECK_OBJECT&quot;" ElementId="#i997050">Detects and reports corruptions in a table or index</SubProgram>
        <SubProgram Name="&quot;DUMP_ORPHAN_KEYS&quot;" ElementId="#i997129">Reports on index entries that point to rows in corrupt data blocks</SubProgram>
        <SubProgram Name="&quot;FIX_CORRUPT_BLOCKS&quot;" ElementId="#CHDGBBEG">Marks blocks software corrupt that have been previously detected as corrupt by CHECK_OBJECT</SubProgram>
        <SubProgram Name="&quot;ONLINE_INDEX_CLEAN&quot;" ElementId="#CHDEACBI">Performs a manual cleanup of failed or interrupted online index builds or rebuilds</SubProgram>
        <SubProgram Name="&quot;REBUILD_FREELISTS&quot;" ElementId="#i997264">Rebuilds an object's freelists</SubProgram>
        <SubProgram Name="&quot;SEGMENT_FIX_STATUS&quot;" ElementId="#i997375">Fixes the corrupted state of a bitmap entry</SubProgram>
        <SubProgram Name="&quot;SKIP_CORRUPT_BLOCKS&quot;" ElementId="#i1000167">Sets whether to ignore blocks marked corrupt during table and index scans or to report ORA-1578 when blocks marked corrupt are encountered</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_REPCAT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_repcat.htm">
      <Description>The DBMS_REPCAT package provides routines to administer and update the replication catalog and environment.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_REPCAT_ADMIN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_repadm.htm">
      <Description>The DBMS_REPCAT_ADMIN package enables you to create users with the privileges needed by the symmetric replication facility.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_REPCAT_INSTANTIATE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_repint.htm">
      <Description>The DBMS_REPCAT_INSTANTIATE package instantiates deployment templates.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_REPCAT_RGT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_reprgt.htm">
      <Description>The DBMS_REPCAT_RGT package controls the maintenance and definition of refresh group templates.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_REPUTIL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_reputl.htm">
      <Description>The DBMS_REPUTIL package contains subprograms to generate shadow tables, triggers, and packages for table replication, as well as subprograms to generate wrappers for replication of standalone procedure invocations and packaged procedure invocations. This package is referenced only by the generated code.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_RESCONFIG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_resconfig.htm">
      <Description>The DBMS_RESCONFIG package provides an interface to operate on the resource configuration list, and to retrieve listener information for a resource.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADDREPOSITORYRESCONFIG&quot;" ElementId="#BHCCAGGC">Inserts the resource configuration specified by absolute path at the given position of the repository's configuration list</SubProgram>
        <SubProgram Name="&quot;ADDRESCONFIG&quot;" ElementId="#BHCDDJFH">Inserts the resource configuration specified by the absolute path at the given position in the target resource's configuration list</SubProgram>
        <SubProgram Name="&quot;APPENDRESCONFIG&quot;" ElementId="#BHCIGFJJ">Appends the resource configuration specified by rcpath to the target resource's configuration list if it is not already included in the list</SubProgram>
        <SubProgram Name="&quot;DELETEREPOSITORYRESCONFIG&quot;" ElementId="#BHCBAFCB">Removes the configuration at the given position in the repository's configuration list.</SubProgram>
        <SubProgram Name="&quot;DELETERESCONFIG&quot;" ElementId="#BHCFFGAG">Removes the configuration at the given position in the target resource's configuration list. I</SubProgram>
        <SubProgram Name="&quot;GETLISTENERS&quot;" ElementId="#BHCFIFFJ">Returns the list of listeners applicable for a given resource</SubProgram>
        <SubProgram Name="&quot;GETREPOSITORYRESCONFIG&quot;" ElementId="#BHCJHEEB">Returns the resource configuration at the specified position of the repository's configuration list</SubProgram>
        <SubProgram Name="&quot;GETREPOSITORYRESCONFIGPATHS&quot;" ElementId="#BHCCICCJ">Returns a list of resource configuration paths defined for the repository</SubProgram>
        <SubProgram Name="&quot;GETRESCONFIG&quot;" ElementId="#BHCGJAGE">Returns the resource configuration at the specified position of the target resource's configuration list</SubProgram>
        <SubProgram Name="&quot;GETRESCONFIGPATHS&quot;" ElementId="#BHCGCHGE">Returns a list of resource configuration paths defined in the target resource's configuration list</SubProgram>
        <SubProgram Name="&quot;PATCHREPOSITORYRESCONFIGLIST&quot;" ElementId="#CBDEDCGF">Removes invalid references from the repository resource configuration list, and makes the repository available</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_RESOURCE_MANAGER&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_resmgr.htm">
      <Description>The DBMS_RESOURCE_MANAGER package maintains plans, consumer groups, and plan directives. It also provides semantics so that you may group together changes to the plan schema.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BEGIN_SQL_BLOCK&quot;" ElementId="#CFAEHEHJ">Indicates the start of a block of SQL statements to be treated as a group by resource manager</SubProgram>
        <SubProgram Name="&quot;CALIBRATE_IO&quot;" ElementId="#CJGHGFEA">Calibrates the I/O capabilities of storage</SubProgram>
        <SubProgram Name="&quot;CLEAR_PENDING_AREA&quot;" ElementId="#BGBDJDJJ">Clears the work area for the resource manager</SubProgram>
        <SubProgram Name="&quot;CREATE_CATEGORY&quot;" ElementId="#CHDDHADC">Creates a new resource consumer group category</SubProgram>
        <SubProgram Name="&quot;CREATE_CDB_PLAN&quot;" ElementId="#CHDCJDBE">Creates entries which define resource consumer groups</SubProgram>
        <SubProgram Name="&quot;CREATE_CDB_PLAN_DIRECTIVE&quot;" ElementId="#CHDGEDGF">Creates the plan directives of the consolidation resource plan</SubProgram>
        <SubProgram Name="&quot;CREATE_CONSUMER_GROUP&quot;" ElementId="#CJGDHJFJ">Creates entries which define resource consumer groups</SubProgram>
        <SubProgram Name="&quot;CREATE_PENDING_AREA&quot;" ElementId="#i1002969">Creates a work area for changes to resource manager objects</SubProgram>
        <SubProgram Name="&quot;CREATE_PLAN&quot;" ElementId="#i1003144">Creates entries which define resource plans</SubProgram>
        <SubProgram Name="&quot;CREATE_PLAN_DIRECTIVE&quot;" ElementId="#i1003006">Creates resource plan directives</SubProgram>
        <SubProgram Name="&quot;CREATE_SIMPLE_PLAN&quot;" ElementId="#i996990">Creates a single-level resource plan containing up to eight consumer groups in one step</SubProgram>
        <SubProgram Name="&quot;DELETE_CATEGORY&quot;" ElementId="#CHDDJJEI">Deletes an existing resource consumer group category</SubProgram>
        <SubProgram Name="&quot;DELETE_CDB_PLAN&quot;" ElementId="#CHDCJDEF">Deletes the consolidation resource plan</SubProgram>
        <SubProgram Name="&quot;DELETE_CDB_PLAN_DIRECTIVE&quot;" ElementId="#CHDBGGDF">Deletes the plan directives of the consolidation resource plan</SubProgram>
        <SubProgram Name="&quot;DELETE_CONSUMER_GROUP&quot;" ElementId="#i1003305">Deletes entries which define resource consumer groups</SubProgram>
        <SubProgram Name="&quot;DELETE_PLAN&quot;" ElementId="#CFADBJFC">Deletes the specified plan as well as all the plan directives it refers to</SubProgram>
        <SubProgram Name="&quot;DELETE_PLAN_CASCADE&quot;" ElementId="#i997082">Deletes the specified plan as well as all its descendants (plan directives, subplans, consumer groups)</SubProgram>
        <SubProgram Name="&quot;DELETE_PLAN_DIRECTIVE&quot;" ElementId="#i1003310">Deletes resource plan directives</SubProgram>
        <SubProgram Name="&quot;END_SQL_BLOCK&quot;" ElementId="#BGBDEGBD">Indicates the end of a block of SQL statements that should be treated as a group by resource manager</SubProgram>
        <SubProgram Name="&quot;SET_CONSUMER_GROUP_MAPPING&quot;" ElementId="#CHDEIBFI">Adds, deletes, or modifies entries for the login and run-time attribute mappings</SubProgram>
        <SubProgram Name="&quot;SET_CONSUMER_GROUP_MAPPING_PRI&quot;" ElementId="#i1004680">Creates the session attribute mapping priority list</SubProgram>
        <SubProgram Name="&quot;SET_INITIAL_CONSUMER_GROUP&quot;" ElementId="#i1003346">Assigns the initial resource consumer group for a user (Caution: Deprecated Subprogram)</SubProgram>
        <SubProgram Name="&quot;SUBMIT_PENDING_AREA&quot;" ElementId="#CFABBJDH">Submits pending changes for the resource manager</SubProgram>
        <SubProgram Name="&quot;SWITCH_CONSUMER_GROUP_FOR_SESS&quot;" ElementId="#i997621">Changes the resource consumer group of a specific session</SubProgram>
        <SubProgram Name="&quot;SWITCH_CONSUMER_GROUP_FOR_USER&quot;" ElementId="#i997652">Changes the resource consumer group for all sessions with a given user name</SubProgram>
        <SubProgram Name="&quot;SWITCH_PLAN&quot;" ElementId="#i1005840">Sets the current resource manager plan</SubProgram>
        <SubProgram Name="&quot;UPDATE_CATEGORY&quot;" ElementId="#CHDIJBGH">Updates an existing resource consumer group category</SubProgram>
        <SubProgram Name="&quot;UPDATE_CDB_AUTOTASK_DIRECTIVE&quot;" ElementId="#CHDEBJGG">Updates the plan directives with regard to automated maintenance tasks</SubProgram>
        <SubProgram Name="&quot;UPDATE_CDB_DEFAULT_DIRECTIVE&quot;" ElementId="#CHDFCCCA">Updates the default values for a consolidation plan</SubProgram>
        <SubProgram Name="&quot;UPDATE_CDB_PLAN&quot;" ElementId="#CHDEJGII">Updates the consolidation resource plan</SubProgram>
        <SubProgram Name="&quot;UPDATE_CDB_PLAN_DIRECTIVE&quot;" ElementId="#CHDCHFBH">Updates the consolidation resource plan</SubProgram>
        <SubProgram Name="&quot;UPDATE_CONSUMER_GROUP&quot;" ElementId="#i1006110">Updates entries which define resource consumer groups</SubProgram>
        <SubProgram Name="&quot;UPDATE_PLAN&quot;" ElementId="#i1003561">Updates entries which define resource plans</SubProgram>
        <SubProgram Name="&quot;UPDATE_PLAN_DIRECTIVE&quot;" ElementId="#i1003705">Updates resource plan directives</SubProgram>
        <SubProgram Name="&quot;VALIDATE_PENDING_AREA&quot;" ElementId="#i1003620">Validates pending changes for the resource manager</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_RESOURCE_MANAGER_PRIVS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_resmpr.htm">
      <Description>The DBMS_RESOURCE_MANAGER_PRIVS package maintains privileges associated with the Resource Manager.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GRANT_SWITCH_CONSUMER_GROUP&quot;" ElementId="#i999133">Grants the privilege to switch to resource consumer groups</SubProgram>
        <SubProgram Name="&quot;GRANT_SYSTEM_PRIVILEGE&quot;" ElementId="#i999263">Performs a grant of a system privilege</SubProgram>
        <SubProgram Name="&quot;REVOKE_SWITCH_CONSUMER_GROUP&quot;" ElementId="#CFAIDFCH">Revokes the privilege to switch to resource consumer groups.</SubProgram>
        <SubProgram Name="&quot;REVOKE_SYSTEM_PRIVILEGE&quot;" ElementId="#i999231">Performs a revoke of a system privilege</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_RESULT_CACHE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_result_cache.htm">
      <Description>The DBMS_RESULT_CACHE package provides an interface to allow the DBA to administer that part of the shared pool that is used by the SQL result cache and the PL/SQL function result cache. Both these caches use the same infrastructure. Therefore, for example, DBMS_RESULT_CACHE.BYPASS determines whether both caches are bypassed or both caches are used, and DBMS_RESULT_CACHE.FLUSH flushes both all the cached results for SQL queries and all the cached results for PL/SQL functions.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BYPASS&quot;" ElementId="#CDEDBJGF">Sets the bypass mode for the Result Cache</SubProgram>
        <SubProgram Name="&quot;FLUSH&quot;" ElementId="#CHDHCDIH">Attempts to remove all the objects from the Result Cache, and depending on the arguments retains or releases the memory and retains or clears the statistics</SubProgram>
        <SubProgram Name="&quot;INVALIDATE&quot;" ElementId="#CHDGEFCF">Invalidates all the result-set objects that dependent upon the specified dependency object</SubProgram>
        <SubProgram Name="&quot;INVALIDATE_OBJECT&quot;" ElementId="#CHDIIFFA">Invalidates the specified result-set object(s)</SubProgram>
        <SubProgram Name="&quot;MEMORY_REPORT&quot;" ElementId="#CDEGADEE">Produces the memory usage report for the Result Cache</SubProgram>
        <SubProgram Name="&quot;STATUS&quot;" ElementId="#CHDJCFJG">Checks the status of the Result Cache</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_RESUMABLE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_resuma.htm">
      <Description>With the DBMS_RESUMABLE package, you can suspend large operations that run out of space or reach space limits after executing for a long time, fix the problem, and make the statement resume execution. In this way you can write applications without worrying about running into space-related errors.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ABORT&quot;" ElementId="#i996815">Aborts a suspended resumable space allocation</SubProgram>
        <SubProgram Name="&quot;GET_SESSION_TIMEOUT&quot;" ElementId="#i996838">Returns the current timeout value of the resumable space allocations for a session with session_id</SubProgram>
        <SubProgram Name="&quot;GET_TIMEOUT&quot;" ElementId="#i998183">Returns the current timeout value of resumable space allocations for the current session</SubProgram>
        <SubProgram Name="&quot;SET_SESSION_TIMEOUT&quot;" ElementId="#i996860">Sets the timeout of resumable space allocations for a session with session_id</SubProgram>
        <SubProgram Name="&quot;SET_TIMEOUT&quot;" ElementId="#i996892">Sets the timeout of resumable space allocations for the current session</SubProgram>
        <SubProgram Name="&quot;SPACE_ERROR_INFO&quot;" ElementId="#CBBFDDJH">Looks for space-related errors in the error stack, otherwise returning FALSE</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_RLS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_rls.htm">
      <Description>The DBMS_RLS package contains the fine-grained access control administrative interface, which is used to implement Virtual Private Database (VPD). DBMS_RLS is available with the Enterprise Edition only.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_GROUPED_POLICY&quot;" ElementId="#i1002047">Adds a policy associated with a policy group</SubProgram>
        <SubProgram Name="&quot;ADD_POLICY&quot;" ElementId="#i998159">Adds a fine-grained access control policy to a table, view, or synonym</SubProgram>
        <SubProgram Name="&quot;ADD_POLICY_CONTEXT&quot;" ElementId="#i1002054">Adds the context for the active application</SubProgram>
        <SubProgram Name="&quot;ALTER_POLICY&quot;" ElementId="#CIHHADDH">Associates an application context attribute with VPD policies</SubProgram>
        <SubProgram Name="&quot;ALTER_GROUPED_POLICY&quot;" ElementId="#CIHCFBDA">Adds application context related changes</SubProgram>
        <SubProgram Name="&quot;CREATE_POLICY_GROUP&quot;" ElementId="#i1002040">Creates a policy group</SubProgram>
        <SubProgram Name="&quot;DELETE_POLICY_GROUP&quot;" ElementId="#i1002061">Deletes a policy group</SubProgram>
        <SubProgram Name="&quot;DISABLE_GROUPED_POLICY&quot;" ElementId="#i1003610">Disables a row-level group security policy</SubProgram>
        <SubProgram Name="&quot;DROP_GROUPED_POLICY&quot;" ElementId="#i1002068">Drops a policy associated with a policy group</SubProgram>
        <SubProgram Name="&quot;DROP_POLICY&quot;" ElementId="#CIHGHJGG">Drops a fine-grained access control policy from a table, view, or synonym</SubProgram>
        <SubProgram Name="&quot;DROP_POLICY_CONTEXT&quot;" ElementId="#i1002075">Drops a driving context from the object so that it will have one less driving context</SubProgram>
        <SubProgram Name="&quot;ENABLE_GROUPED_POLICY&quot;" ElementId="#i1002088">Enables or disables a row-level group security policy</SubProgram>
        <SubProgram Name="&quot;ENABLE_POLICY&quot;" ElementId="#i998317">Enables or disables a fine-grained access control policy</SubProgram>
        <SubProgram Name="&quot;REFRESH_GROUPED_POLICY&quot;" ElementId="#i1002095">Reparses the SQL statements associated with a refreshed policy</SubProgram>
        <SubProgram Name="&quot;REFRESH_POLICY&quot;" ElementId="#i998280">Causes all the cached statements associated with the policy to be reparsed</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ROLLING&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_rolling.htm">
      <Description>The DBMS_ROLLING PL/SQL package is used to implement the Rolling Upgrade Using Active Data Guard feature, which streamlines the process of upgrading Oracle Database software in a Data Guard configuration in a rolling fashion. The Rolling Upgrade Using Active Data Guard feature requires a license for the Oracle Active Data Guard option, and can be used for database version upgrades starting with the first patchset of Oracle Database 12c.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;INIT_PLAN&quot;" ElementId="#CACFBEDJ">Initializes a rolling operation plan with system-generated default values.</SubProgram>
        <SubProgram Name="&quot;DESTROY_PLAN&quot;" ElementId="#BCGJCCAI">Destroys any existing rolling operation plan, its parameters, and all resources associated with the rolling operation.</SubProgram>
        <SubProgram Name="&quot;BUILD_PLAN&quot;" ElementId="#BCGEHIFC">Validates plan parameters and creates or modifies a rolling operation plan.</SubProgram>
        <SubProgram Name="&quot;SET_PARAMETER&quot;" ElementId="#BCGEECJD">Modifies a rolling operation parameter.</SubProgram>
        <SubProgram Name="&quot;START_PLAN&quot;" ElementId="#BCGHFGHE">Starts the rolling operation.</SubProgram>
        <SubProgram Name="&quot;SWITCHOVER&quot;" ElementId="#BCGCBEAC">Performs a switchover between the current primary database and the transient logical standby database.</SubProgram>
        <SubProgram Name="&quot;FINISH_PLAN&quot;" ElementId="#BCGHEDJH">Finalizes the rolling operation.</SubProgram>
        <SubProgram Name="&quot;ROLLBACK_PLAN&quot;" ElementId="#BCGIGBHH">Completely rolls back the rolling operation.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_ROWID&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_rowid.htm">
      <Description>The DBMS_ROWID package lets you create ROWIDs and obtain information about ROWIDs from PL/SQL programs and SQL statements. You can find the data block number, the object number, and other ROWID components without writing code to interpret the base-64 character external ROWID. DBMS_ROWID is intended for upgrading from Oracle database version 7 to Oracle database version 8.X.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ROWID_BLOCK_NUMBER&quot;" ElementId="#CIHDGIGD">Returns the block number of a ROWID</SubProgram>
        <SubProgram Name="&quot;ROWID_CREATE&quot;" ElementId="#i1004385">Creates a ROWID, for testing only</SubProgram>
        <SubProgram Name="&quot;ROWID_INFO&quot;" ElementId="#CIHCAIFH">Returns the type and components of a ROWID</SubProgram>
        <SubProgram Name="&quot;ROWID_OBJECT&quot;" ElementId="#i997153">Returns the object number of the extended ROWID</SubProgram>
        <SubProgram Name="&quot;ROWID_RELATIVE_FNO&quot;" ElementId="#i997186">Returns the file number of a ROWID</SubProgram>
        <SubProgram Name="&quot;ROWID_ROW_NUMBER&quot;" ElementId="#i997251">Returns the row number</SubProgram>
        <SubProgram Name="&quot;ROWID_TO_ABSOLUTE_FNO&quot;" ElementId="#CIHHJEEF">Returns the absolute file number associated with the ROWID for a row in a specific table</SubProgram>
        <SubProgram Name="&quot;ROWID_TO_EXTENDED&quot;" ElementId="#i1004441">Converts a ROWID from restricted format to extended</SubProgram>
        <SubProgram Name="&quot;ROWID_TO_RESTRICTED&quot;" ElementId="#i997392">Converts an extended ROWID to restricted format</SubProgram>
        <SubProgram Name="&quot;ROWID_TYPE&quot;" ElementId="#i1004963">Returns the ROWID type: 0 is restricted, 1 is extended</SubProgram>
        <SubProgram Name="&quot;ROWID_VERIFY&quot;" ElementId="#i997423">Checks if a ROWID can be correctly extended by the ROWID_TO_EXTENDED function</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_RULE_ADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_rule_a.htm">
      <Description>The DBMS_RULE_ADM package provides the subprograms for creating and managing rules, rule sets, and rule evaluation contexts.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_RULE&quot;" ElementId="#CDEFCEHF">Adds the specified rule to the specified rule set</SubProgram>
        <SubProgram Name="&quot;ALTER_EVALUATION_CONTEXT&quot;" ElementId="#CDEEBGHC">Alters a rule evaluation context</SubProgram>
        <SubProgram Name="&quot;ALTER_RULE&quot;" ElementId="#i996965">Changes one or more aspects of the specified rule</SubProgram>
        <SubProgram Name="&quot;CREATE_EVALUATION_CONTEXT&quot;" ElementId="#i997052">Creates a rule evaluation context</SubProgram>
        <SubProgram Name="&quot;CREATE_RULE&quot;" ElementId="#i997137">Creates a rule with the specified name</SubProgram>
        <SubProgram Name="&quot;CREATE_RULE_SET&quot;" ElementId="#CDEIHAAB">Creates a rule set with the specified name</SubProgram>
        <SubProgram Name="&quot;DROP_EVALUATION_CONTEXT&quot;" ElementId="#i1005236">Drops the rule evaluation context with the specified name</SubProgram>
        <SubProgram Name="&quot;DROP_RULE&quot;" ElementId="#CDEDDDCH">Drops the rule with the specified name</SubProgram>
        <SubProgram Name="&quot;DROP_RULE_SET&quot;" ElementId="#i997321">Drops the rule set with the specified name</SubProgram>
        <SubProgram Name="&quot;GRANT_OBJECT_PRIVILEGE&quot;" ElementId="#i997359">Grants the specified object privilege on the specified object to the specified user or role</SubProgram>
        <SubProgram Name="&quot;GRANT_SYSTEM_PRIVILEGE&quot;" ElementId="#i997477">Grants the specified system privilege to the specified user or role</SubProgram>
        <SubProgram Name="&quot;REMOVE_RULE&quot;" ElementId="#i997608">Removes the specified rule from the specified rule set</SubProgram>
        <SubProgram Name="&quot;REVOKE_OBJECT_PRIVILEGE&quot;" ElementId="#i997660">Revokes the specified object privilege on the specified object from the specified user or role</SubProgram>
        <SubProgram Name="&quot;REVOKE_SYSTEM_PRIVILEGE&quot;" ElementId="#i997700">Revokes the specified system privilege from the specified user or role</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SCHEDULER&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_sched.htm">
      <Description>The DBMS_SCHEDULER package provides a collection of scheduling functions and procedures that can be called from any PL/SQL program.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_EVENT_QUEUE_SUBSCRIBER&quot;" ElementId="#AddEventQSubscr93">Adds a user as a subscriber to the Scheduler event queue SYS.SCHEDULER$_EVENT_QUEUE</SubProgram>
        <SubProgram Name="&quot;ADD_GROUP_MEMBER&quot;" ElementId="#BABFFDCH">Adds one or more members to an existing group</SubProgram>
        <SubProgram Name="&quot;ADD_JOB_EMAIL_NOTIFICATION&quot;" ElementId="#BABBFBGI">Adds e-mail notifications for a job for a list of recipients and a list of job state events</SubProgram>
        <SubProgram Name="&quot;ALTER_CHAIN&quot;" ElementId="#CHDIAICJ">Alters specified steps of a chain</SubProgram>
        <SubProgram Name="&quot;ALTER_RUNNING_CHAIN&quot;" ElementId="#CHDGAEDD">Alters specified steps of a running chain</SubProgram>
        <SubProgram Name="&quot;CLOSE_WINDOW&quot;" ElementId="#i1011066">Closes an open window prematurely</SubProgram>
        <SubProgram Name="&quot;COPY_JOB&quot;" ElementId="#i1009982">Copies an existing job</SubProgram>
        <SubProgram Name="&quot;CREATE_CHAIN&quot;" ElementId="#CHDCJFCI">Creates a chain, which is a named series of programs that are linked together for a combined objective</SubProgram>
        <SubProgram Name="&quot;CREATE_CREDENTIAL&quot;" ElementId="#BABCAEAC">Creates a credential</SubProgram>
        <SubProgram Name="&quot;CREATE_DATABASE_DESTINATION&quot;" ElementId="#BABEEIIF">Creates a database destination for use with remote database jobs</SubProgram>
        <SubProgram Name="&quot;CREATE_EVENT_SCHEDULE&quot;" ElementId="#CHDEBDFH">Creates an event schedule, which is a schedule that starts a job based on the detection of an event</SubProgram>
        <SubProgram Name="&quot;CREATE_FILE_WATCHER&quot;" ElementId="#BABFFJIJ">Creates a file watcher, which is a Scheduler object that defines the location, name, and other properties of a file whose arrival on a system causes the Scheduler to start a job</SubProgram>
        <SubProgram Name="&quot;CREATE_GROUP&quot;" ElementId="#BABFGABJ">Creates a group</SubProgram>
        <SubProgram Name="&quot;CREATE_JOB&quot;" ElementId="#i1000363">Creates a single job</SubProgram>
        <SubProgram Name="&quot;CREATE_JOB_CLASS&quot;" ElementId="#i1011092">Creates a job class, which provides a way to group jobs for resource allocation and prioritization</SubProgram>
        <SubProgram Name="&quot;CREATE_JOBS&quot;" ElementId="#BABCIJJA">Creates multiple jobs</SubProgram>
        <SubProgram Name="&quot;CREATE_PROGRAM&quot;" ElementId="#i1010013">Creates a program</SubProgram>
        <SubProgram Name="&quot;CREATE_SCHEDULE&quot;" ElementId="#i1010076">Creates a schedule</SubProgram>
        <SubProgram Name="&quot;CREATE_WINDOW&quot;" ElementId="#i1016629">Creates a window, which provides a way to automatically activate different resource plans at different times</SubProgram>
        <SubProgram Name="&quot;DEFINE_ANYDATA_ARGUMENT&quot;" ElementId="#i1013213">Defines a program argument whose value is of a complex type and must be passed encapsulated in an AnyData object</SubProgram>
        <SubProgram Name="&quot;DEFINE_CHAIN_EVENT_STEP&quot;" ElementId="#CHDCAFGJ">Adds or replaces a chain step and associates it with an event schedule or inline event. See also: DEFINE_CHAIN_STEP.</SubProgram>
        <SubProgram Name="&quot;DEFINE_CHAIN_RULE&quot;" ElementId="#CHDBAFJE">Adds a rule to an existing chain</SubProgram>
        <SubProgram Name="&quot;DEFINE_CHAIN_STEP&quot;" ElementId="#CHDEJDHJ">Defines a chain step, which can be a program or another (nested) chain. See also: DEFINE_CHAIN_EVENT_STEP.</SubProgram>
        <SubProgram Name="&quot;DEFINE_METADATA_ARGUMENT&quot;" ElementId="#i1011138">Defines a special metadata argument for the program. You can retrieve specific metadata through this argument.</SubProgram>
        <SubProgram Name="&quot;DEFINE_PROGRAM_ARGUMENT&quot;" ElementId="#i1011161">Defines a program argument whose value can be passed as a string literal to the program</SubProgram>
        <SubProgram Name="&quot;DISABLE&quot;" ElementId="#i1003538">Disables a program, job, chain, window, database destination, external destination, file watcher, group, or incompatibilty</SubProgram>
        <SubProgram Name="&quot;DROP_AGENT_DESTINATION&quot;" ElementId="#BABBFHBG">Drops one or more external destinations. Use only when the preferred method of dropping external destinations—unregistering the Scheduler agent with the database—fails.</SubProgram>
        <SubProgram Name="&quot;DROP_CHAIN&quot;" ElementId="#CHDIAFHG">Drops an existing chain</SubProgram>
        <SubProgram Name="&quot;DROP_CHAIN_RULE&quot;" ElementId="#CHDJEIJB">Removes a rule from an existing chain</SubProgram>
        <SubProgram Name="&quot;DROP_CHAIN_STEP&quot;" ElementId="#CHDBDCAI">Drops a chain step</SubProgram>
        <SubProgram Name="&quot;DROP_CREDENTIAL&quot;" ElementId="#BABIJAJG">Drops a credential</SubProgram>
        <SubProgram Name="&quot;DROP_DATABASE_DESTINATION&quot;" ElementId="#BABBDAIF">Drops one or more database destinations</SubProgram>
        <SubProgram Name="&quot;DROP_FILE_WATCHER&quot;" ElementId="#BABJEJHF">Drops one or more file watchers</SubProgram>
        <SubProgram Name="&quot;DROP_GROUP&quot;" ElementId="#BABDHDGH">Drops one or more groups</SubProgram>
        <SubProgram Name="&quot;DROP_JOB&quot;" ElementId="#i1000364">Drops a job or all jobs in a job class</SubProgram>
        <SubProgram Name="&quot;DROP_JOB_CLASS&quot;" ElementId="#i1009950">Drops a job class</SubProgram>
        <SubProgram Name="&quot;DROP_PROGRAM&quot;" ElementId="#i1011194">Drops a program</SubProgram>
        <SubProgram Name="&quot;DROP_PROGRAM_ARGUMENT&quot;" ElementId="#i1011195">Drops a program argument</SubProgram>
        <SubProgram Name="&quot;DROP_SCHEDULE&quot;" ElementId="#CIHBGDFG">Drops a schedule</SubProgram>
        <SubProgram Name="&quot;DROP_WINDOW&quot;" ElementId="#i1014414">Drops a window</SubProgram>
        <SubProgram Name="&quot;ENABLE&quot;" ElementId="#i1012587">Enables a program, job, chain, window, database destination, external destination, file watcher, or group</SubProgram>
        <SubProgram Name="&quot;END_DETACHED_JOB_RUN&quot;" ElementId="#BABCDIFA">Ends a running detached job</SubProgram>
        <SubProgram Name="&quot;EVALUATE_CALENDAR_STRING&quot;" ElementId="#i1009923">Evaluates the calendar string and tells you what the next execution date of a job or window will be</SubProgram>
        <SubProgram Name="&quot;EVALUATE_RUNNING_CHAIN&quot;" ElementId="#BABGCFFG">Forces reevaluation of the rules of a running chain to trigger any rules for conditions that have been satisfied</SubProgram>
        <SubProgram Name="&quot;GENERATE_JOB_NAME&quot;" ElementId="#i1011295">Generates a unique name for a job. This enables you to identify jobs by adding a prefix, so, for example, Sally's jobs would be named sally1, sally2, and so on</SubProgram>
        <SubProgram Name="&quot;GET_AGENT_INFO&quot;" ElementId="#CHDJDGJI">Returns job information specific to an agent, such as how many are running and so on, depending on the attribute selected</SubProgram>
        <SubProgram Name="&quot;GET_AGENT_VERSION&quot;" ElementId="#CHDGAEFF">Returns the version string of a Scheduler agent that is registered with the database and is currently running</SubProgram>
        <SubProgram Name="&quot;GET_ATTRIBUTE&quot;" ElementId="#i1011296">Retrieves the value of an attribute of an object</SubProgram>
        <SubProgram Name="&quot;GET_FILE&quot;" ElementId="#BABDDBFH">Retrieves a file from a host</SubProgram>
        <SubProgram Name="&quot;GET_SCHEDULER_ATTRIBUTE&quot;" ElementId="#i1011297">Retrieves the value of a Scheduler attribute</SubProgram>
        <SubProgram Name="&quot;OPEN_WINDOW&quot;" ElementId="#i1011298">Opens a window prematurely. The window is opened immediately for the duration</SubProgram>
        <SubProgram Name="&quot;PURGE_LOG&quot;" ElementId="#i1011299">Purges specific rows from the job and window logs</SubProgram>
        <SubProgram Name="&quot;PUT_FILE&quot;" ElementId="#BABHDFFF">Saves a file to one or more hosts</SubProgram>
        <SubProgram Name="&quot;REMOVE_EVENT_QUEUE_SUBSCRIBER&quot;" ElementId="#RemoveEventQSubsc95">Unsubscribes a user from the Scheduler event queue SYS.SCHEDULER$_EVENT_QUEUE</SubProgram>
        <SubProgram Name="&quot;REMOVE_GROUP_MEMBER&quot;" ElementId="#BABHECBB">Removes one or more members from a group</SubProgram>
        <SubProgram Name="&quot;REMOVE_JOB_EMAIL_NOTIFICATION&quot;" ElementId="#BABIIFIC">Removes e-mail notifications for a job</SubProgram>
        <SubProgram Name="&quot;RESET_JOB_ARGUMENT_VALUE&quot;" ElementId="#i1014573">Resets the current value assigned to an argument defined with the associated program</SubProgram>
        <SubProgram Name="&quot;RUN_CHAIN&quot;" ElementId="#CHDGHBGJ">Immediately runs a chain by creating a run-once job</SubProgram>
        <SubProgram Name="&quot;RUN_JOB&quot;" ElementId="#i1013568">Runs a job immediately</SubProgram>
        <SubProgram Name="&quot;SET_AGENT_REGISTRATION_PASS&quot;" ElementId="#BABEJADF">Sets the agent registration password for a database</SubProgram>
        <SubProgram Name="&quot;SET_ATTRIBUTE&quot;" ElementId="#CIHDAIIH">Changes an attribute of a job, schedule, or other Scheduler object</SubProgram>
        <SubProgram Name="&quot;SET_ATTRIBUTE_NULL&quot;" ElementId="#i1000809">Changes an attribute of an object to NULL</SubProgram>
        <SubProgram Name="&quot;SET_JOB_ANYDATA_VALUE&quot;" ElementId="#i1000820">Sets the value of a job argument encapsulated in an AnyData object</SubProgram>
        <SubProgram Name="&quot;SET_JOB_ARGUMENT_VALUE&quot;" ElementId="#i1011390">Sets the value of a job argument</SubProgram>
        <SubProgram Name="&quot;SET_JOB_ATTRIBUTES&quot;" ElementId="#BABCECGB">Sets the value of a job attribute</SubProgram>
        <SubProgram Name="&quot;SET_RESOURCE_CONSTRAINT&quot;" ElementId="#CHDHJCCB">Specifies the resources used by jobs</SubProgram>
        <SubProgram Name="&quot;SET_SCHEDULER_ATTRIBUTE&quot;" ElementId="#i1004630">Sets the value of a Scheduler attribute</SubProgram>
        <SubProgram Name="&quot;STOP_JOB&quot;" ElementId="#i1009818">Stops a currently running job or all jobs in a job class</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SERVER_ALERT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_server_alert.htm">
      <Description>The DBMS_SERVER_ALERT package enables you to configure the Oracle Database server to issue an alert when a threshold for a specified server metric has been violated. You can configure both warning and critical thresholds for a large number of predefined metrics.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SERVICE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_serv.htm">
      <Description>The DBMS_SERVICE package lets you create, delete, activate, and deactivate services for a single instance.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SESSION&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_sessio.htm">
      <Description>This package provides access to SQL ALTERSESSION and SETROLE statements, and other session information, from PL/SQL. You can use DBMS_SESSION to set preferences and security levels.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLEAR_ALL_CONTEXT&quot;" ElementId="#i1009975">Clears all context information</SubProgram>
        <SubProgram Name="&quot;CLEAR_CONTEXT&quot;" ElementId="#i1009938">Clears the context</SubProgram>
        <SubProgram Name="&quot;CLEAR_IDENTIFIER&quot;" ElementId="#i1010000">Clears the identifier</SubProgram>
        <SubProgram Name="&quot;CLOSE_DATABASE_LINK&quot;" ElementId="#i1011038">Closes database link</SubProgram>
        <SubProgram Name="&quot;FREE_UNUSED_USER_MEMORY&quot;" ElementId="#i1010058">Lets you reclaim unused memory after performing operations requiring large amounts of memory</SubProgram>
        <SubProgram Name="&quot;GET_PACKAGE_MEMORY_UTILIZATION&quot;" ElementId="#CHDEGEAJ">Describes static package memory usage</SubProgram>
        <SubProgram Name="&quot;IS_ROLE_ENABLED&quot;" ElementId="#i1010291">Determines if the named role is enabled for the session.</SubProgram>
        <SubProgram Name="&quot;IS_SESSION_ALIVE&quot;" ElementId="#i1010302">Determines if the specified session is active</SubProgram>
        <SubProgram Name="&quot;LIST_CONTEXT&quot;" ElementId="#i1010363">Returns a list of active namespace and context for the current session</SubProgram>
        <SubProgram Name="&quot;MODIFY_PACKAGE_STATE&quot;" ElementId="#CEGIICCC">Used to perform various actions (as specified by the action_flags parameter) on the session state of all PL/SQL program units active in the session</SubProgram>
        <SubProgram Name="&quot;SESSION_TRACE_DISABLE&quot;" ElementId="#CEGJHGDB">Resets the session-level SQL trace for the session from which it was called.</SubProgram>
        <SubProgram Name="&quot;SESSION&quot;" ElementId="#i1010518">Enables session-level SQL trace for the invoking session</SubProgram>
        <SubProgram Name="&quot;RESET_PACKAGE&quot;" ElementId="#i1010767">De-instantiates all packages in the session</SubProgram>
        <SubProgram Name="&quot;SET_CONTEXT&quot;" ElementId="#i1010942">Sets or resets the value of a context attribute</SubProgram>
        <SubProgram Name="&quot;SET_EDITION_DEFERRED&quot;" ElementId="#CHDGADDD">Requests a switch to the specified edition</SubProgram>
        <SubProgram Name="&quot;SET_IDENTIFIER&quot;" ElementId="#i996935">Sets the identifier</SubProgram>
        <SubProgram Name="&quot;SET_NLS&quot;" ElementId="#i1010906">Sets Globalization Support (NLS)</SubProgram>
        <SubProgram Name="&quot;SET_ROLE&quot;" ElementId="#i997099">Sets role</SubProgram>
        <SubProgram Name="&quot;SET_SQL_TRACE&quot;" ElementId="#i997123">Turns tracing on or off</SubProgram>
        <SubProgram Name="&quot;SWITCH_CURRENT_CONSUMER_GROUP&quot;" ElementId="#i997666">Facilitates changing the current resource consumer group of a user's current session</SubProgram>
        <SubProgram Name="&quot;UNIQUE_SESSION_ID&quot;" ElementId="#i1011002">Returns an identifier that is unique for all sessions currently connected to this database</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SHARED_POOL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_shared_pool.htm">
      <Description>The DBMS_SHARED_POOL package provides access to the shared pool, which is the shared memory area where cursors and PL/SQL objects are stored. DBMS_SHARED_POOL enables you to display the sizes of objects in the shared pool, and mark them for keeping or not-keeping in order to reduce memory fragmentation.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ABORTED_REQUEST_THRESHOLD&quot;" ElementId="#i999181">Sets the aborted request threshold for the shared pool</SubProgram>
        <SubProgram Name="&quot;KEEP&quot;" ElementId="#i999221">Keeps an object in the shared pool</SubProgram>
        <SubProgram Name="&quot;MARKHOT&quot;" ElementId="#CHDCBEBB">Marks a library cache object as a hot object</SubProgram>
        <SubProgram Name="&quot;PURGE&quot;" ElementId="#CIHIGHAI">Purges the named object or specified heap(s) of the object</SubProgram>
        <SubProgram Name="&quot;SIZES&quot;" ElementId="#BHBFDAEA">Shows objects in the shared pool that are larger than the specified size</SubProgram>
        <SubProgram Name="&quot;UNKEEP&quot;" ElementId="#i996877">Unkeeps the named object</SubProgram>
        <SubProgram Name="&quot;UNMARKHOT&quot;" ElementId="#CIHIJAHG">Unmarks a library cache object as a hot object</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SPACE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_space.htm">
      <Description>The DBMS_SPACE package enables you to analyze segment growth and space requirements.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SPACE_ADMIN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_spadmn.htm">
      <Description>The DBMS_SPACE_ADMIN package provides functionality for locally managed tablespaces.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ASSM_SEGMENT_VERIFY&quot;" ElementId="#CACFGICA">Verifies segments created in ASSM (Automatic Segment-Space Management) tablespaces</SubProgram>
        <SubProgram Name="&quot;ASSM_TABLESPACE_VERIFY&quot;" ElementId="#CACBDCIF">Verifies ASSM tablespaces</SubProgram>
        <SubProgram Name="&quot;DROP_EMPTY_SEGMENTS&quot;" ElementId="#CACGGIAF">Drops segments from empty tables or table fragments and dependent objects</SubProgram>
        <SubProgram Name="&quot;MATERIALIZE_DEFERRED_SEGMENTS&quot;" ElementId="#CACFEJDA">Materializes segments for tables and table fragments with deferred segment creation and their dependent objects</SubProgram>
        <SubProgram Name="&quot;SEGMENT_CORRUPT&quot;" ElementId="#i1003202">Marks the segment corrupt or valid so that appropriate error recovery can be done</SubProgram>
        <SubProgram Name="&quot;SEGMENT_DROP_CORRUPT&quot;" ElementId="#i997057">Drops a segment currently marked corrupt (without reclaiming space)</SubProgram>
        <SubProgram Name="&quot;SEGMENT_DUMP&quot;" ElementId="#i997098">Dumps the segment header and extent maps of a given segment</SubProgram>
        <SubProgram Name="&quot;SEGMENT_VERIFY&quot;" ElementId="#i1003253">Verifies the consistency of the extent map of the segment</SubProgram>
        <SubProgram Name="&quot;TABLESPACE_FIX_BITMAPS&quot;" ElementId="#i997164">Marks the appropriate block range (extent) as free or used in bitmap</SubProgram>
        <SubProgram Name="&quot;TABLESPACE_FIX_SEGMENT_STATES&quot;" ElementId="#i1003383">Fixes the state of the segments in a tablespace in which migration was aborted</SubProgram>
        <SubProgram Name="&quot;TABLESPACE_MIGRATE_FROM_LOCAL&quot;" ElementId="#i1003433">Migrates a locally managed tablespace to dictionary-managed tablespace</SubProgram>
        <SubProgram Name="&quot;TABLESPACE_MIGRATE_TO_LOCAL&quot;" ElementId="#i997300">Migrates a tablespace from dictionary-managed format to locally managed format</SubProgram>
        <SubProgram Name="&quot;TABLESPACE_REBUILD_BITMAPS&quot;" ElementId="#i1003443">Rebuilds the appropriate bitmaps</SubProgram>
        <SubProgram Name="&quot;TABLESPACE_REBUILD_QUOTAS&quot;" ElementId="#i1003484">Rebuilds quotas for given tablespace</SubProgram>
        <SubProgram Name="&quot;TABLESPACE_RELOCATE_BITMAPS&quot;" ElementId="#i997372">Relocates the bitmaps to the destination specified</SubProgram>
        <SubProgram Name="&quot;TABLESPACE_VERIFY&quot;" ElementId="#i1003313">Verifies that the bitmaps and extent maps for the segments in the tablespace are synchronized</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SPD&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_spd.htm">
      <Description>The DBMS_SPD package provides subprograms for managing SQL plan directives (SPD).</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ALTER_SQL_PLAN_DIRECTIVE&quot;" ElementId="#CIHEFGBI">Changes different attributes of a SQL plan directive</SubProgram>
        <SubProgram Name="&quot;CREATE_STGTAB_DIRECTIVE&quot;" ElementId="#CIHEFDGI">Creates a staging table into which to pack (export) SQL plan directives.</SubProgram>
        <SubProgram Name="&quot;DROP_SQL_PLAN_DIRECTIVE&quot;" ElementId="#CIHEIAFA">Drops a SQL plan directive</SubProgram>
        <SubProgram Name="&quot;FLUSH_SQL_PLAN_DIRECTIVE&quot;" ElementId="#CIHDIFFC">Allows for manual flushing of the SQL plan directives that are automatically recorded in SGA memory while executing SQL statements.</SubProgram>
        <SubProgram Name="&quot;GET_PREFS&quot;" ElementId="#CIHJGBJG">Gets the values for preferences for SQL plan directives</SubProgram>
        <SubProgram Name="&quot;PACK_STGTAB_DIRECTIVE&quot;" ElementId="#CIHBEHIF">Packs (exports) SQL plan directives into a staging table.</SubProgram>
        <SubProgram Name="&quot;SET_PREFS&quot;" ElementId="#CIHJJFHA">Allows the setting of different preferences for SQL plan directives</SubProgram>
        <SubProgram Name="&quot;UNPACK_STGTAB_DIRECTIVE&quot;" ElementId="#CIHEFIFG">Unpacks (imports) SQL plan directives from a staging table.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SPM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_spm.htm">
      <Description>The DBMS_SPM package supports the SQL plan management feature by providing an interface for the DBA or other user to perform controlled manipulation of plan history and SQL plan baselines maintained for various SQL statements.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ACCEPT_SQL_PLAN_BASELINE&quot;" ElementId="#CACDEIBC">Accepts a plan based on the recommendation of an evolve task</SubProgram>
        <SubProgram Name="&quot;ALTER_SQL_PLAN_BASELINE&quot;" ElementId="#CACJJFDB">Changes an attribute of a single plan or all plans associated with a SQL statement using the attribute name/value format</SubProgram>
        <SubProgram Name="&quot;CANCEL_EVOLVE_TASK&quot;" ElementId="#CACCCJDF">Cancels a currently executing evolve task</SubProgram>
        <SubProgram Name="&quot;CONFIGURE&quot;" ElementId="#CACHAGGA">Sets configuration options for SQL management base, in parameter/value format</SubProgram>
        <SubProgram Name="&quot;CREATE_EVOLVE_TASK&quot;" ElementId="#CACBHAHJ">Creates an advisor task and sets its parameters</SubProgram>
        <SubProgram Name="&quot;CREATE_STGTAB_BASELINE&quot;" ElementId="#CACBHIHE">Creates a staging table that used for transporting SQL plan baselines from one system to another</SubProgram>
        <SubProgram Name="&quot;DROP_EVOLVE_TASK&quot;" ElementId="#CACDAICC">Drops an evolved task</SubProgram>
        <SubProgram Name="&quot;DROP_SQL_PLAN_BASELINE&quot;" ElementId="#CACGAHJF">Drops a single plan, or all plans associated with a SQL statement</SubProgram>
        <SubProgram Name="&quot;EVOLVE_SQL_PLAN_BASELINE&quot;" ElementId="#CACEBBEI">Evolves SQL plan baselines associated with one or more SQL statements</SubProgram>
        <SubProgram Name="&quot;EXECUTE_EVOLVE_TASK&quot;" ElementId="#CACBAAHG">Executes a previously created evolve task</SubProgram>
        <SubProgram Name="&quot;IMPLEMENT_EVOLVE_TASK&quot;" ElementId="#CACGEEDF">Implements a plan based on the recommendation of an evolve task</SubProgram>
        <SubProgram Name="&quot;INTERRUPT_EVOLVE_TASK&quot;" ElementId="#CACDIEEJ">Interrupts a currently executing evolve task</SubProgram>
        <SubProgram Name="&quot;LOAD_PLANS_FROM_CURSOR_CACHE&quot;" ElementId="#CACBFHHJ">Loads one or more plans present in the cursor cache for a SQL statement</SubProgram>
        <SubProgram Name="&quot;LOAD_PLANS_FROM_SQLSET&quot;" ElementId="#CACBCAGD">Loads plans stored in a SQL tuning set (STS) into SQL plan baselines</SubProgram>
        <SubProgram Name="&quot;MIGRATE_STORED_OUTLINE&quot;" ElementId="#CACCGDBG">Migrates existing stored outlines to SQL plan baselines</SubProgram>
        <SubProgram Name="&quot;PACK_STGTAB_BASELINE&quot;" ElementId="#CACEGFAI">Packs (exports) SQL plan baselines from SQL management base into a staging table</SubProgram>
        <SubProgram Name="&quot;RESET_EVOLVE_TASK&quot;" ElementId="#CACBGCGF">Resets an evolve task to its initial state</SubProgram>
        <SubProgram Name="&quot;RESUME_EVOLVE_TASK&quot;" ElementId="#CACFICCF">Resumes a previously interrupted task</SubProgram>
        <SubProgram Name="&quot;REPORT_AUTO_EVOLVE_TASK&quot;" ElementId="#CACEEIDJ">Displays the results of an execution of an automatic evolve task.</SubProgram>
        <SubProgram Name="&quot;REPORT_EVOLVE_TASK&quot;" ElementId="#CACCIGBG">Displays the results of an evolved task</SubProgram>
        <SubProgram Name="&quot;SET_EVOLVE_TASK_PARAMETER&quot;" ElementId="#CACECGEG">Sets a parameter of an evolve task</SubProgram>
        <SubProgram Name="&quot;UNPACK_STGTAB_BASELINE&quot;" ElementId="#CACHBGBD">Unpacks (imports) SQL plan baselines from a staging table into SQL management base</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SQL&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_sql.htm">
      <Description>The DBMS_SQL package provides an interface to use dynamic SQL to parse any data manipulation language (DML) or data definition language (DDL) statement using PL/SQL. For example, you can enter a DROPTABLE statement from within a stored procedure by using the PARSE Procedures supplied with the DBMS_SQL package.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BIND_ARRAY&quot;" ElementId="#i1025085">Binds a given value to a given collection</SubProgram>
        <SubProgram Name="&quot;BIND_VARIABLE&quot;" ElementId="#i1030093">Binds a given value to a given variable</SubProgram>
        <SubProgram Name="&quot;CLOSE_CURSOR&quot;" ElementId="#i1026299">Closes given cursor and frees memory</SubProgram>
        <SubProgram Name="&quot;COLUMN_VALUE&quot;" ElementId="#i1025449">Returns value of the cursor element for a given position in a cursor</SubProgram>
        <SubProgram Name="&quot;COLUMN_VALUE_LONG&quot;" ElementId="#i1025399">Returns a selected part of a LONG column, that has been defined using DEFINE_COLUMN_LONG</SubProgram>
        <SubProgram Name="&quot;DEFINE_ARRAY&quot;" ElementId="#i1025685">Defines a collection to be selected from the given cursor, used only with SELECT statements</SubProgram>
        <SubProgram Name="&quot;DEFINE_COLUMN&quot;" ElementId="#i1025686">Defines a column to be selected from the given cursor, used only with SELECT statements</SubProgram>
        <SubProgram Name="&quot;DEFINE_COLUMN_CHAR&quot;" ElementId="#CIHGCGBF">Defines a column of type CHAR to be selected from the given cursor, used only with SELECT statements</SubProgram>
        <SubProgram Name="&quot;DEFINE_COLUMN_LONG&quot;" ElementId="#i1025656">Defines a LONG column to be selected from the given cursor, used only with SELECT statements</SubProgram>
        <SubProgram Name="&quot;DEFINE_COLUMN_RAW&quot;" ElementId="#CIHECACB">Defines a column of type RAW to be selected from the given cursor, used only with SELECT statements</SubProgram>
        <SubProgram Name="&quot;DEFINE_COLUMN_ROWID&quot;" ElementId="#CIHJJFJD">Defines a column of type ROWID to be selected from the given cursor, used only with SELECT statements</SubProgram>
        <SubProgram Name="&quot;DESCRIBE_COLUMNS&quot;" ElementId="#i1026120">Describes the columns for a cursor opened and parsed through DBMS_SQL</SubProgram>
        <SubProgram Name="&quot;DESCRIBE_COLUMNS2&quot;" ElementId="#i1029368">Describes describes the specified column, an alternative to DESCRIBE_COLUMNS Procedure</SubProgram>
        <SubProgram Name="&quot;DESCRIBE_COLUMNS3&quot;" ElementId="#CHDJBBFH">Describes describes the specified column, an alternative to DESCRIBE_COLUMNS Procedure</SubProgram>
        <SubProgram Name="&quot;EXECUTE&quot;" ElementId="#i1025983">Executes a given cursor</SubProgram>
        <SubProgram Name="&quot;EXECUTE_AND_FETCH&quot;" ElementId="#i1025711">Executes a given cursor and fetch rows</SubProgram>
        <SubProgram Name="&quot;FETCH_ROWS&quot;" ElementId="#i1026065">Fetches a row from a given cursor</SubProgram>
        <SubProgram Name="&quot;GET_NEXT_RESULT&quot;" ElementId="#CIHEBDFJ">Gets the statement of the next result returned to the caller of the recursive statement or, if this caller sets itself as the client for the recursive statement, the next result returned to this caller as client</SubProgram>
        <SubProgram Name="&quot;IS_OPEN&quot;" ElementId="#i1026423">Returns TRUE if given cursor is open</SubProgram>
        <SubProgram Name="&quot;LAST_ERROR_POSITION&quot;" ElementId="#i1026408">Returns byte offset in the SQL statement text where the error occurred</SubProgram>
        <SubProgram Name="&quot;LAST_ROW_COUNT&quot;" ElementId="#i1026354">Returns cumulative count of the number of rows fetched</SubProgram>
        <SubProgram Name="&quot;LAST_ROW_ID&quot;" ElementId="#i1026364">Returns ROWID of last row processed</SubProgram>
        <SubProgram Name="&quot;LAST_SQL_FUNCTION_CODE&quot;" ElementId="#i1026374">Returns SQL function code for statement</SubProgram>
        <SubProgram Name="&quot;OPEN_CURSOR&quot;" ElementId="#i997665">Returns cursor ID number of new cursor</SubProgram>
        <SubProgram Name="&quot;PARSE&quot;" ElementId="#i997676">Parses given statement</SubProgram>
        <SubProgram Name="&quot;RETURN_RESULT&quot;" ElementId="#CIHIICAG">Returns the result of an executed statement to the client application</SubProgram>
        <SubProgram Name="&quot;TO_CURSOR_NUMBER&quot;" ElementId="#CHDJDGDG">Takes an OPENed strongly or weakly-typed ref cursor and transforms it into a DBMS_SQL cursor number</SubProgram>
        <SubProgram Name="&quot;TO_REFCURSOR&quot;" ElementId="#CHDFDCDE">Takes an OPENed, PARSEd, and EXECUTEd cursor and transforms/migrates it into a PL/SQL manageable REFCURSOR (a weakly-typed cursor) that can be consumed by PL/SQL native dynamic SQL switched to use native dynamic SQL</SubProgram>
        <SubProgram Name="&quot;VARIABLE_VALUE&quot;" ElementId="#i998371">Returns value of named variable for given cursor</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SQL_MONITOR&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_sql_monitor.htm">
      <Description>The DBMS_SQL_MONITOR package provides information about Real-time SQL Monitoring and Real-time Database Operation Monitoring.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;BEGIN_OPERATION&quot;" ElementId="#CHDJADIH">Starts a composite database operation in the current session</SubProgram>
        <SubProgram Name="&quot;END_OPERATION&quot;" ElementId="#CHDDHCGJ">Ends the monitoring operation in the current session</SubProgram>
        <SubProgram Name="&quot;REPORT_SQL_MONITOR&quot;" ElementId="#CHDEJFGD">Builds a detailed report for a specific database operation that has been monitored by Oracle</SubProgram>
        <SubProgram Name="&quot;REPORT_SQL_MONITOR_LIST&quot;" ElementId="#CHDHEJGA">Builds a report for all or a subset of database operations that have been monitored by Oracle</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SQL_TRANSLATOR&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_sql_trans.htm">
      <Description>The DBMS_SQL_TRANSLATOR package provides an interface for creating, configuring, and using SQL translation profiles.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CREATE_PROFILE&quot;" ElementId="#BABHCDAF">Creates a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;DEREGISTER_SQL_TRANSLATION&quot;" ElementId="#BABJAICF">Deregisters the custom translation of a SQL statement in a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;DEREGISTER_ERROR_TRANSLATION&quot;" ElementId="#BABDGEAG">Deregisters the translation of an Oracle error code and SQLSTATE in a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;DROP_PROFILE&quot;" ElementId="#BABGJEEB">Drops a SQL translation profile and its contents</SubProgram>
        <SubProgram Name="&quot;ENABLE_ERROR_TRANSLATION&quot;" ElementId="#BABCDFFB">Enables or disables a custom translation of an Oracle error code in a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;ENABLE_SQL_TRANSLATION&quot;" ElementId="#BABJCAIB">Enables or disables a custom translation of a SQL statement in a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;EXPORT_PROFILE&quot;" ElementId="#BABCIBFH">Exports the content of a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;IMPORT_PROFILE&quot;" ElementId="#BABHGBJJ">Imports the content of a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;REGISTER_ERROR_TRANSLATION&quot;" ElementId="#BABEIHGE">Registers a custom translation of an Oracle error code and SQLSTATE in a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;REGISTER_SQL_TRANSLATION&quot;" ElementId="#BABJGBDB">Registers a custom translation of a SQL statement in a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;SET_ATTRIBUTE&quot;" ElementId="#BABIEHBA">Sets an attribute of a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;SQL_HASH&quot;" ElementId="#BABFFFHF">Computes the hash value of a SQL statement in a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;SQL_ID&quot;" ElementId="#BABDFCAE">Computes the SQL identifier of a SQL statement in a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;TRANSLATE_ERROR&quot;" ElementId="#BABIJCJG">Translates an Oracle error code and an ANSI SQLSTATE using a SQL translation profile</SubProgram>
        <SubProgram Name="&quot;TRANSLATE_SQL&quot;" ElementId="#BABBHGII">Translates a SQL statement using a SQL translation profile</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SQLDIAG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_sqldiag.htm">
      <Description>The DBMS_SQLDIAG package provides an interface to the SQL Diagnosability functionality.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ACCEPT_SQL_PATCH&quot;" ElementId="#CEGBDHEJ">Accepts a recommended SQL patch as recommended by the specified SQL diagnosis task</SubProgram>
        <SubProgram Name="&quot;ALTER_SQL_PATCH&quot;" ElementId="#CEGFAFII">Alters specific attributes of an existing SQL patch object</SubProgram>
        <SubProgram Name="&quot;CANCEL_DIAGNOSIS_TASK&quot;" ElementId="#CHDFJBAI">Cancels a diagnostic task</SubProgram>
        <SubProgram Name="&quot;CREATE_DIAGNOSIS_TASK&quot;" ElementId="#CHDHFBAA">Creates a diagnostic task in order to diagnose a single SQL statement</SubProgram>
        <SubProgram Name="&quot;CREATE_STGTAB_SQLPATCH&quot;" ElementId="#CEGBBDBF">Creates the staging table used for transporting SQL patches from one system to another</SubProgram>
        <SubProgram Name="&quot;DROP_DIAGNOSIS_TASK&quot;" ElementId="#CHDBIECH">Drops a diagnostic task</SubProgram>
        <SubProgram Name="&quot;DROP_SQL_PATCH&quot;" ElementId="#CEGDJEEI">Drops the named SQL patch from the database</SubProgram>
        <SubProgram Name="&quot;EXECUTE_DIAGNOSIS_TASK&quot;" ElementId="#CHDJEJDH">Executes a diagnostic task</SubProgram>
        <SubProgram Name="&quot;EXPLAIN_SQL_TESTCASE&quot;" ElementId="#CHDFBAFB">Explains a SQL test case</SubProgram>
        <SubProgram Name="&quot;EXPORT_SQL_TESTCASE&quot;" ElementId="#CHDJEHIC">Exports a SQL test case to a directory</SubProgram>
        <SubProgram Name="&quot;EXPORT_SQL_TESTCASE_DIR_BY_INC&quot;" ElementId="#CEGEEAAG">Generates a SQL Test Case corresponding to the incident ID passed as an argument.</SubProgram>
        <SubProgram Name="&quot;EXPORT_SQL_TESTCASE_DIR_BY_TXT&quot;" ElementId="#CEGDACIA">Generates a SQL Test Case corresponding to the SQL passed as an argument</SubProgram>
        <SubProgram Name="&quot;GET_FIX_CONTROL&quot;" ElementId="#CHDCHFHC">Returns the value of fix control for a given bug number</SubProgram>
        <SubProgram Name="&quot;GET_SQL&quot;" ElementId="#CEGBACCC">Imports a SQL test case</SubProgram>
        <SubProgram Name="&quot;IMPORT_SQL_TESTCASE&quot;" ElementId="#CEGEEHFF">Imports a SQL test case into a schema</SubProgram>
        <SubProgram Name="&quot;INCIDENTID_2_SQL&quot;" ElementId="#CHDIEJDC">Initializes a sql_setrow from an incident ID</SubProgram>
        <SubProgram Name="&quot;INTERRUPT_DIAGNOSIS_TASK&quot;" ElementId="#CHDBCIFC">Interrupts a diagnostic task</SubProgram>
        <SubProgram Name="&quot;LOAD_SQLSET_FROM_TCB&quot;" ElementId="#CEGHJHJE">Loads a SQLSET from Test Case Builder (TCB) file</SubProgram>
        <SubProgram Name="&quot;PACK_STGTAB_SQLPATCH&quot;" ElementId="#CEGBIFAH">SQL patches into the staging table created by the CREATE_STGTAB_SQLPATCH Procedure</SubProgram>
        <SubProgram Name="&quot;REPLAY_SQL_TESTCASE&quot;" ElementId="#CEGGFABG">Reports on a diagnostic task</SubProgram>
        <SubProgram Name="&quot;REPORT_DIAGNOSIS_TASK&quot;" ElementId="#CHDJDIGI">Reports on a diagnostic task</SubProgram>
        <SubProgram Name="&quot;RESET_DIAGNOSIS_TASK&quot;" ElementId="#CHDJCDHG">Resets a diagnostic task</SubProgram>
        <SubProgram Name="&quot;RESUME_DIAGNOSIS_TASK&quot;" ElementId="#CEGBGGDG">Resumes a diagnostic task</SubProgram>
        <SubProgram Name="&quot;SET_DIAGNOSIS_TASK_PARAMETER&quot;" ElementId="#CHDFGDDF">Sets a diagnosis task parameter</SubProgram>
        <SubProgram Name="&quot;UNPACK_STGTAB_SQLPATCH&quot;" ElementId="#CEGCJDBB">Unpacks from the staging table populated by a call to the PACK_STGTAB_SQLPATCH Procedure, using the patch data stored in the staging table to create patches on this system</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SQLPA&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_sqlpa.htm">
      <Description>The DBMS_SQLPA package provides the interface to implement the SQL Performance Analyzer.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SQLTUNE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_sqltun.htm">
      <Description>The DBMS_SQLTUNE package is the interface for tuning SQL on demand. The related package DBMS_AUTO_SQLTUNE package provides the interface for SQL Tuning Advisor run as an automated task.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STAT_FUNCS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_stat_f.htm">
      <Description>The DBMS_STAT_FUNCS package provides statistical functions.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STATS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_stats.htm">
      <Description>With the DBMS_STATS package you can view and modify optimizer statistics gathered for database objects.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ALTER_STATS_HISTORY_RETENTION&quot;" ElementId="#i1048060">Changes the statistics history retention value</SubProgram>
        <SubProgram Name="&quot;CONVERT_RAW_VALUE&quot;" ElementId="#i1035014">Converts the internal representation of a minimum value, maximum value, or histogram endpoint actual value into a datatype-specific value</SubProgram>
        <SubProgram Name="&quot;CONVERT_RAW_VALUE_NVARCHAR&quot;" ElementId="#i1038351">Converts the internal representation of a minimum value, maximum value, or histogram endpoint actual value into a datatype-specific value</SubProgram>
        <SubProgram Name="&quot;CONVERT_RAW_VALUE_ROWID&quot;" ElementId="#i1038352">Converts the internal representation of a minimum value, maximum value, or histogram endpoint actual value into a datatype-specific value</SubProgram>
        <SubProgram Name="&quot;COPY_TABLE_STATS&quot;" ElementId="#BABDDBGH">Copies the statistics of the source [sub] partition to the destination [sub] partition after scaling</SubProgram>
        <SubProgram Name="&quot;CREATE_EXTENDED_STATS&quot;" ElementId="#BABHFIBI">Creates a virtual column for a user specified column group or an expression in a table</SubProgram>
        <SubProgram Name="&quot;CREATE_STAT_TABLE&quot;" ElementId="#i1035018">Creates a table with name stattab in ownname's schema which is capable of holding statistics</SubProgram>
        <SubProgram Name="&quot;DELETE_COLUMN_STATS&quot;" ElementId="#i1035206">Deletes column-related statistics</SubProgram>
        <SubProgram Name="&quot;DELETE_DATABASE_PREFS&quot;" ElementId="#BEIHGEBD">Deletes the statistics preferences of all the tables</SubProgram>
        <SubProgram Name="&quot;DELETE_DATABASE_STATS&quot;" ElementId="#i1035352">Deletes statistics for the entire database</SubProgram>
        <SubProgram Name="&quot;DELETE_DICTIONARY_STATS&quot;" ElementId="#i1042571">Deletes statistics for all dictionary schemas ('SYS', 'SYSTEM' and RDBMS component schemas)</SubProgram>
        <SubProgram Name="&quot;DELETE_FIXED_OBJECTS_STATS&quot;" ElementId="#i1039357">Deletes statistics of all fixed tables</SubProgram>
        <SubProgram Name="&quot;DELETE_INDEX_STATS&quot;" ElementId="#i1035428">Deletes index-related statistics</SubProgram>
        <SubProgram Name="&quot;DELETE_PENDING_STATS&quot;" ElementId="#BEIJGHFD">Deletes the private statistics that have been collected but have not been published</SubProgram>
        <SubProgram Name="&quot;DELETE_PROCESSING_RATE&quot;" ElementId="#BABDCJDJ">Deletes the processing rate of a given statistics source. If the source is not specified, it deletes the statistics of all the sources</SubProgram>
        <SubProgram Name="&quot;DELETE_SCHEMA_PREFS&quot;" ElementId="#BEIFAGDH">Deletes the statistics preferences of all the tables owned by the specified owner name</SubProgram>
        <SubProgram Name="&quot;DELETE_SCHEMA_STATS&quot;" ElementId="#i1035494">Deletes schema-related statistics</SubProgram>
        <SubProgram Name="&quot;DELETE_SYSTEM_STATS&quot;" ElementId="#i1035583">Deletes system statistics</SubProgram>
        <SubProgram Name="&quot;DELETE_TABLE_PREFS&quot;" ElementId="#BEIEGCHI">Deletes statistics preferences of the specified table in the specified schema</SubProgram>
        <SubProgram Name="&quot;DELETE_TABLE_STATS&quot;" ElementId="#i1035962">Deletes table-related statistics</SubProgram>
        <SubProgram Name="&quot;DIFF_TABLE_STATS_IN_HISTORY&quot;" ElementId="#BEIDHICC">Compares statistics for a table from two timestamps in past and compare the statistics as of that timestamps</SubProgram>
        <SubProgram Name="&quot;DIFF_TABLE_STATS_IN_PENDING&quot;" ElementId="#BABCBGHG">Compares pending statistics and statistics as of a timestamp or statistics from dictionary</SubProgram>
        <SubProgram Name="&quot;DIFF_TABLE_STATS_IN_STATTAB&quot;" ElementId="#BEICGJDD">Compares statistics for a table from two different sources</SubProgram>
        <SubProgram Name="&quot;DROP_EXTENDED_STATS&quot;" ElementId="#BABEAECF">Drops the statistics entry that is created for the user specified extension</SubProgram>
        <SubProgram Name="&quot;DROP_STAT_TABLE&quot;" ElementId="#i1035659">Drops a user statistics table created by CREATE_STAT_TABLE</SubProgram>
        <SubProgram Name="&quot;EXPORT_COLUMN_STATS&quot;" ElementId="#i1035669">Retrieves statistics for a particular column and stores them in the user statistics table identified by stattab</SubProgram>
        <SubProgram Name="&quot;EXPORT_DATABASE_PREFS&quot;" ElementId="#BEIDACAE">Exports the statistics preferences of all the tables</SubProgram>
        <SubProgram Name="&quot;EXPORT_DATABASE_STATS&quot;" ElementId="#i1041371">Retrieves statistics for all objects in the database and stores them in the user statistics table identified by statown.stattab</SubProgram>
        <SubProgram Name="&quot;EXPORT_DICTIONARY_STATS&quot;" ElementId="#i1042811">Retrieves statistics for all dictionary schemas ('SYS', 'SYSTEM' and RDBMS component schemas) and stores them in the user statistics table identified by stattab</SubProgram>
        <SubProgram Name="&quot;EXPORT_FIXED_OBJECTS_STATS&quot;" ElementId="#i1041507">Retrieves statistics for fixed tables and stores them in the user statistics table identified by stattab</SubProgram>
        <SubProgram Name="&quot;EXPORT_INDEX_STATS&quot;" ElementId="#i1041496">Retrieves statistics for a particular index and stores them in the user statistics table identified by stattab</SubProgram>
        <SubProgram Name="&quot;EXPORT_PENDING_STATS&quot;" ElementId="#BEIEBEAE">Exports the statistics gathered and stored as pending</SubProgram>
        <SubProgram Name="&quot;EXPORT_SCHEMA_PREFS&quot;" ElementId="#BEIFJJDF">Exports the statistics preferences of all the tables owned by the specified owner name</SubProgram>
        <SubProgram Name="&quot;EXPORT_SCHEMA_STATS&quot;" ElementId="#i1036059">Retrieves statistics for all objects in the schema identified by ownname and stores them in the user statistics table identified by stattab</SubProgram>
        <SubProgram Name="&quot;EXPORT_SYSTEM_STATS&quot;" ElementId="#i1035776">Retrieves system statistics and stores them in the user statistics table</SubProgram>
        <SubProgram Name="&quot;EXPORT_TABLE_PREFS&quot;" ElementId="#BEIBGBHF">Exports statistics preferences of the specified table in the specified schema into the specified statistics table</SubProgram>
        <SubProgram Name="&quot;EXPORT_TABLE_STATS&quot;" ElementId="#i1035814">Retrieves statistics for a particular table and stores them in the user statistics table</SubProgram>
        <SubProgram Name="&quot;FLUSH_DATABASE_MONITORING_INFO&quot;" ElementId="#i1036624">Flushes in-memory monitoring information for all the tables to the dictionary</SubProgram>
        <SubProgram Name="&quot;GATHER_DATABASE_STATS&quot;" ElementId="#i1036194">Gathers statistics for all objects in the database</SubProgram>
        <SubProgram Name="&quot;GATHER_DICTIONARY_STATS&quot;" ElementId="#i1055451">Gathers statistics for dictionary schemas 'SYS', 'SYSTEM' and schemas of RDBMS components</SubProgram>
        <SubProgram Name="&quot;GATHER_FIXED_OBJECTS_STATS&quot;" ElementId="#i1039162">Gathers statistics of fixed objects</SubProgram>
        <SubProgram Name="&quot;GATHER_INDEX_STATS&quot;" ElementId="#i1036276">Gathers index statistics</SubProgram>
        <SubProgram Name="&quot;GATHER_PROCESSING_RATE&quot;" ElementId="#BABFEFDF">Starts the job of gathering the processing rates which end after interval defined in minutes</SubProgram>
        <SubProgram Name="&quot;GATHER_SCHEMA_STATS&quot;" ElementId="#i1036456">Gathers statistics for all objects in a schema</SubProgram>
        <SubProgram Name="&quot;GATHER_SYSTEM_STATS&quot;" ElementId="#i1036401">Gathers system statistics</SubProgram>
        <SubProgram Name="&quot;GATHER_TABLE_STATS&quot;" ElementId="#i1036461">Gathers table and column (and index) statistics</SubProgram>
        <SubProgram Name="&quot;GENERATE_STATS&quot;" ElementId="#i1036560">Generates object statistics from previously collected statistics of related objects</SubProgram>
        <SubProgram Name="&quot;GET_COLUMN_STATS&quot;" ElementId="#i1036689">Gets all column-related information</SubProgram>
        <SubProgram Name="&quot;GET_INDEX_STATS&quot;" ElementId="#i1036796">Gets all index-related information</SubProgram>
        <SubProgram Name="&quot;GET_PARAM&quot;" ElementId="#i1048775">Gets the default value of parameters of DBMS_STATS procedures [see Deprecated Subprograms ]</SubProgram>
        <SubProgram Name="&quot;GET_PREFS&quot;" ElementId="#BEICCEDB">Gets the default value of the specified preference</SubProgram>
        <SubProgram Name="&quot;GET_STATS_HISTORY_AVAILABILITY&quot;" ElementId="#i1050595">Gets the oldest timestamp where statistics history is available</SubProgram>
        <SubProgram Name="&quot;GET_STATS_HISTORY_RETENTION&quot;" ElementId="#i1048205">Returns the current statistics history retention value</SubProgram>
        <SubProgram Name="&quot;GET_SYSTEM_STATS&quot;" ElementId="#i1036927">Gets system statistics from stattab, or from the dictionary if stattab is NULL</SubProgram>
        <SubProgram Name="&quot;GET_TABLE_STATS&quot;" ElementId="#i1037003">Gets all table-related information</SubProgram>
        <SubProgram Name="&quot;IMPORT_COLUMN_STATS&quot;" ElementId="#i1037153">Retrieves statistics for a particular column from the user statistics table identified by stattab and stores them in the dictionary</SubProgram>
        <SubProgram Name="&quot;IMPORT_DATABASE_PREFS&quot;" ElementId="#BEIGFDAI">Imports the statistics preferences of all the tables</SubProgram>
        <SubProgram Name="&quot;IMPORT_DATABASE_STATS&quot;" ElementId="#i1037134">Retrieves statistics for all objects in the database from the user statistics table and stores them in the dictionary</SubProgram>
        <SubProgram Name="&quot;IMPORT_DICTIONARY_STATS&quot;" ElementId="#i1043013">Retrieves statistics for all dictionary schemas ('SYS', 'SYSTEM' and RDBMS component schemas) from the user statistics table and stores them in the dictionary</SubProgram>
        <SubProgram Name="&quot;IMPORT_FIXED_OBJECTS_STATS&quot;" ElementId="#i1041649">Retrieves statistics for fixed tables from the user statistics table identified by stattab and stores them in the dictionary</SubProgram>
        <SubProgram Name="&quot;IMPORT_INDEX_STATS&quot;" ElementId="#i1037276">Retrieves statistics for a particular index from the user statistics table identified by stattab and stores them in the dictionary</SubProgram>
        <SubProgram Name="&quot;IMPORT_SCHEMA_PREFS&quot;" ElementId="#BEIHBJBH">Imports the statistics preferences of all the tables owned by the specified owner name</SubProgram>
        <SubProgram Name="&quot;IMPORT_SCHEMA_STATS&quot;" ElementId="#i1037487">Retrieves statistics for all objects in the schema identified by ownname from the user statistics table and stores them in the dictionary</SubProgram>
        <SubProgram Name="&quot;IMPORT_SYSTEM_STATS&quot;" ElementId="#i1037380">Retrieves system statistics from the user statistics table and stores them in the dictionary</SubProgram>
        <SubProgram Name="&quot;IMPORT_TABLE_PREFS&quot;" ElementId="#BEIDGEFG">Sets the statistics preferences of the specified table in the specified schema</SubProgram>
        <SubProgram Name="&quot;IMPORT_TABLE_STATS&quot;" ElementId="#i1037419">Retrieves statistics for a particular table from the user statistics table identified by stattab and stores them in the dictionary</SubProgram>
        <SubProgram Name="&quot;LOCK_PARTITION_STATS&quot;" ElementId="#BABFJDFA">Locks statistics for a partition</SubProgram>
        <SubProgram Name="&quot;LOCK_SCHEMA_STATS&quot;" ElementId="#i1043184">Locks the statistics of all tables of a schema</SubProgram>
        <SubProgram Name="&quot;LOCK_TABLE_STATS&quot;" ElementId="#i1043993">Locks the statistics on the table</SubProgram>
        <SubProgram Name="&quot;MERGE_COL_USAGE&quot;" ElementId="#CHDEJICB">Merges column usage information from a source database, by means of a dblink, into the local database</SubProgram>
        <SubProgram Name="&quot;PREPARE_COLUMN_VALUES&quot;" ElementId="#i1035422">Converts user-specified minimum, maximum, and histogram endpoint datatype-specific values into Oracle's internal representation for future storage using the SEED_COL_USAGE Procedure</SubProgram>
        <SubProgram Name="&quot;PREPARE_COLUMN_VALUES_NVARCHAR&quot;" ElementId="#i1038038">Converts user-specified minimum, maximum, and histogram endpoint datatype-specific values into Oracle's internal representation for future storage using the SEED_COL_USAGE Procedure</SubProgram>
        <SubProgram Name="&quot;PREPARE_COLUMN_VALUES_ROWID&quot;" ElementId="#i1038039">Converts user-specified minimum, maximum, and histogram endpoint datatype-specific values into Oracle's internal representation for future storage using the SEED_COL_USAGE Procedure</SubProgram>
        <SubProgram Name="&quot;PUBLISH_PENDING_STATS&quot;" ElementId="#BEIDCHEJ">Publishes the statistics gathered and stored as pending</SubProgram>
        <SubProgram Name="&quot;PURGE_STATS&quot;" ElementId="#i1047896">Purges old versions of statistics saved in the dictionary</SubProgram>
        <SubProgram Name="&quot;REMAP_STAT_TABLE&quot;" ElementId="#BABDGICG">Remaps the names of objects in the user statistics table</SubProgram>
        <SubProgram Name="&quot;REPORT_COL_USAGE&quot;" ElementId="#BABCDEBI">Reports the recorded column (group) usage information</SubProgram>
        <SubProgram Name="&quot;REPORT_GATHER_AUTO_STATS&quot;" ElementId="#BABDABJG">Runs the auto statistics gathering job in reporting mode</SubProgram>
        <SubProgram Name="&quot;REPORT_GATHER_DATABASE_STATS&quot;" ElementId="#BABBEHEC">Runs the GATHER_DATABASE_STATS Procedures in reporting mode.</SubProgram>
        <SubProgram Name="&quot;REPORT_GATHER_DICTIONARY_STATS&quot;" ElementId="#BABEDECI">Runs the GATHER_DICTIONARY_STATS Procedure in reporting mode</SubProgram>
        <SubProgram Name="&quot;REPORT_GATHER_FIXED_OBJ_STATS&quot;" ElementId="#BABCAJGD">Runs the GATHER_FIXED_OBJECTS_STATS Procedure in reporting mode</SubProgram>
        <SubProgram Name="&quot;REPORT_GATHER_SCHEMA_STATS&quot;" ElementId="#BABFCCIG">Runs the GATHER_SCHEMA_STATS Procedures in reporting mode</SubProgram>
        <SubProgram Name="&quot;REPORT_GATHER_TABLE_STATS&quot;" ElementId="#BABFHCEC">Runs the GATHER_TABLE_STATS Procedure in reporting mode</SubProgram>
        <SubProgram Name="&quot;REPORT_SINGLE_STATS_OPERATION&quot;" ElementId="#BABJDEBB">Generates a report for the provided operation optionally in a particular pluggable database (PDB) in a multitenant environment</SubProgram>
        <SubProgram Name="&quot;REPORT_STATS_OPERATIONS&quot;" ElementId="#BABFABBC">Generates a report of all statistics operations that take place between two timestamps which may or may not have been provided</SubProgram>
        <SubProgram Name="&quot;RESET_GLOBAL_PREF_DEFAULTS&quot;" ElementId="#i1047505">Resets the default values of all parameters to Oracle recommended values</SubProgram>
        <SubProgram Name="&quot;RESET_PARAM_DEFAULTS&quot;" ElementId="#BABGHFFF">Resets global preferences to default values [see Deprecated Subprograms ]</SubProgram>
        <SubProgram Name="&quot;RESTORE_DICTIONARY_STATS&quot;" ElementId="#i1047724">Restores statistics of all dictionary tables (tables of 'SYS', 'SYSTEM' and RDBMS component schemas) as of a specified timestamp</SubProgram>
        <SubProgram Name="&quot;RESTORE_FIXED_OBJECTS_STATS&quot;" ElementId="#i1047603">Restores statistics of all fixed tables as of a specified timestamp</SubProgram>
        <SubProgram Name="&quot;RESTORE_SCHEMA_STATS&quot;" ElementId="#i1047376">Restores statistics of all tables of a schema as of a specified timestamp</SubProgram>
        <SubProgram Name="&quot;RESTORE_SYSTEM_STATS&quot;" ElementId="#i1049804">Restores statistics of all tables of a schema as of a specified timestamp</SubProgram>
        <SubProgram Name="&quot;RESTORE_TABLE_STATS&quot;" ElementId="#i1046561">Restores statistics of a table as of a specified timestamp (as_of_timestamp), as well as statistics of associated indexes and columns</SubProgram>
        <SubProgram Name="&quot;SEED_COL_USAGE&quot;" ElementId="#i997460">Iterates over the SQL statements in the specified SQL tuning set, compiles them and seeds column usage information for the columns that appear in these statements</SubProgram>
        <SubProgram Name="&quot;SET_COLUMN_STATS&quot;" ElementId="#CHDHGCED">Sets column-related information</SubProgram>
        <SubProgram Name="&quot;SET_DATABASE_PREFS&quot;" ElementId="#BEIICAFD">Sets the statistics preferences of all the tables</SubProgram>
        <SubProgram Name="&quot;SET_GLOBAL_PREFS&quot;" ElementId="#BEIEAFDF">Sets the global statistics preferences</SubProgram>
        <SubProgram Name="&quot;SET_INDEX_STATS&quot;" ElementId="#i997579">Sets index-related information</SubProgram>
        <SubProgram Name="&quot;SET_PARAM&quot;" ElementId="#i1048566">Sets default values for parameters of DBMS_STATS procedures [see Deprecated Subprograms ]</SubProgram>
        <SubProgram Name="&quot;SET_PROCESSING_RATE&quot;" ElementId="#BABHFFDA">Sets the value of rate of processing for a given operation</SubProgram>
        <SubProgram Name="&quot;SET_SCHEMA_PREFS&quot;" ElementId="#BEIDJHAH">Sets the statistics preferences of all the tables owned by the specified owner name</SubProgram>
        <SubProgram Name="&quot;SET_SYSTEM_STATS&quot;" ElementId="#i997707">Sets system statistics</SubProgram>
        <SubProgram Name="&quot;SET_TABLE_PREFS&quot;" ElementId="#BEIBJJHC">Sets the statistics preferences of the specified table in the specified schema</SubProgram>
        <SubProgram Name="&quot;SET_TABLE_STATS&quot;" ElementId="#i997763">Sets table-related information</SubProgram>
        <SubProgram Name="&quot;SHOW_EXTENDED_STATS_NAME&quot;" ElementId="#BABCIFCJ">Returns the name of the virtual column that is created for the user-specified extension</SubProgram>
        <SubProgram Name="&quot;TRANSFER_STATS&quot;" ElementId="#BABJIHBH">Transfers statistics for specified table(s) from a remote database specified by dblink to the local database</SubProgram>
        <SubProgram Name="&quot;UNLOCK_PARTITION_STATS&quot;" ElementId="#BABDDHJI">Unlocks the statistics for a partition</SubProgram>
        <SubProgram Name="&quot;UNLOCK_SCHEMA_STATS&quot;" ElementId="#i1043314">Unlocks the statistics on all the tables in schema</SubProgram>
        <SubProgram Name="&quot;UNLOCK_TABLE_STATS&quot;" ElementId="#i1040393">Unlocks the statistics on the table</SubProgram>
        <SubProgram Name="&quot;UPGRADE_STAT_TABLE&quot;" ElementId="#i1039960">Upgrades user statistics on an older table</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STORAGE_MAP&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_stmap.htm">
      <Description>With the DBMS_STORAGE_MAP package, you can communicate with the Oracle background process FMON to invoke mapping operations that populate mapping views. FMON communicates with operating and storage system vendor-supplied mapping libraries.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STREAMS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_streams.htm">
      <Description>The DBMS_STREAMS package, one of a set of Oracle Streams packages, provides subprograms to convert ANYDATA objects into logical change record (LCR) objects, to return information about Oracle Streams attributes and Oracle Streams clients, and to annotate redo entries generated by a session with a binary tag. This tag affects the behavior of a capture process, a propagation, or an apply process whose rules include specifications for these binary tags in redo entries or LCRs.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;COMPATIBLE_12_1&quot;" ElementId="#CJAJFEFE">Returns the DBMS_STREAMS.COMPATIBLE_12_1 constant</SubProgram>
        <SubProgram Name="&quot;COMPATIBLE_11_2&quot;" ElementId="#CIHBFJHC">Returns the DBMS_STREAMS.COMPATIBLE_11_2 constant</SubProgram>
        <SubProgram Name="&quot;COMPATIBLE_11_1&quot;" ElementId="#CHDJIHJG">Returns the DBMS_STREAMS.COMPATIBLE_11_1 constant</SubProgram>
        <SubProgram Name="&quot;COMPATIBLE_10_2&quot;" ElementId="#CHDIFGHI">Returns the DBMS_STREAMS.COMPATIBLE_10_2 constant</SubProgram>
        <SubProgram Name="&quot;COMPATIBLE_10_1&quot;" ElementId="#i1000589">Returns the DBMS_STREAMS.COMPATIBLE_10_1 constant</SubProgram>
        <SubProgram Name="&quot;COMPATIBLE_9_2&quot;" ElementId="#i1000323">Returns the DBMS_STREAMS.COMPATIBLE_9_2 constant</SubProgram>
        <SubProgram Name="&quot;CONVERT_ANYDATA_TO_LCR_DDL&quot;" ElementId="#CHDIGCHG">Converts a ANYDATA object to a SYS.LCR$_DDL_RECORD object</SubProgram>
        <SubProgram Name="&quot;CONVERT_ANYDATA_TO_LCR_ROW&quot;" ElementId="#i996872">Converts a ANYDATA object to a SYS.LCR$_ROW_RECORD object</SubProgram>
        <SubProgram Name="&quot;CONVERT_LCR_TO_XML&quot;" ElementId="#CHDJFCGE">Converts a logical change record (LCR) encapsulated in a ANYDATA object into an XML object that conforms to the XML schema for LCRs</SubProgram>
        <SubProgram Name="&quot;CONVERT_XML_TO_LCR&quot;" ElementId="#CHDGBJJA">Converts an XML object that conforms to the XML schema for LCRs into a logical change record (LCR) encapsulated in a ANYDATA object</SubProgram>
        <SubProgram Name="&quot;GET_INFORMATION&quot;" ElementId="#i996907">Returns information about various Oracle Streams attributes</SubProgram>
        <SubProgram Name="&quot;GET_STREAMS_NAME&quot;" ElementId="#CHDGBIJF">Returns the name of the invoker</SubProgram>
        <SubProgram Name="&quot;GET_STREAMS_TYPE&quot;" ElementId="#CHDDCAIC">Returns the type of the invoker</SubProgram>
        <SubProgram Name="&quot;GET_TAG&quot;" ElementId="#i996975">Gets the binary tag for all redo entries generated by the current session</SubProgram>
        <SubProgram Name="&quot;MAX_COMPATIBLE&quot;" ElementId="#CIHJHJHJ">Returns an integer that is greater than the highest possible compatibility constant for the current release of Oracle Database</SubProgram>
        <SubProgram Name="&quot;SET_TAG&quot;" ElementId="#i997007">Sets the binary tag for all redo entries subsequently generated by the current session</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STREAMS_ADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_streams_adm.htm">
      <Description>The DBMS_STREAMS_ADM package, one of a set of Oracle Streams packages, provides subprograms for configuring Oracle Streams environments. This package also includes subprograms for adding and removing simple rules for capture, propagation, apply, and dequeue at the table, schema, and database level. This package also includes subprograms for configuring and managing XStream outbound servers and inbound servers.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_COLUMN&quot;" ElementId="#CDEBGJIC">Either adds or removes a declarative rule-based transformation which adds a column to a row logical change record (row LCR) that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;ADD_GLOBAL_PROPAGATION_RULES&quot;" ElementId="#CDEDIEDE">Either adds global rules to the positive rule set for a propagation, or adds global rules to the negative rule set for a propagation, and creates the specified propagation if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_GLOBAL_RULES&quot;" ElementId="#i1028131">Adds global rules to either the positive or negative rule set of a capture process, apply process, or messaging client, and creates the specified capture process, apply process, or messaging client if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_MESSAGE_PROPAGATION_RULE&quot;" ElementId="#i1012741">Either adds a message rule to the positive rule set for a propagation, or adds a message rule to the negative rule set for a propagation, and creates the specified propagation if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_MESSAGE_RULE&quot;" ElementId="#i1012752">Adds a message rule to either the positive or negative rule set of an apply process or messaging client, and creates the specified apply process or messaging client if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_SCHEMA_PROPAGATION_RULES&quot;" ElementId="#i1010842">Either adds schema rules to the positive rule set for a propagation, or adds schema rules to the negative rule set for a propagation, and creates the specified propagation if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_SCHEMA_RULES&quot;" ElementId="#i997270">Adds schema rules to either the positive or negative rule set of a capture process, apply process, or messaging client, and creates the specified capture process, apply process, or messaging client if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_SUBSET_PROPAGATION_RULES&quot;" ElementId="#i1007301">Adds subset rules to the positive rule set for a propagation, and creates the specified propagation if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_SUBSET_RULES&quot;" ElementId="#i1027849">Adds subset rules to the positive rule set of a capture process, synchronous capture, apply process, or messaging client, and creates the specified capture process, synchronous capture, apply process, or messaging client if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_TABLE_PROPAGATION_RULES&quot;" ElementId="#i997544">Either adds table rules to the positive rule set for a propagation, or adds table rules to the negative rule set for a propagation, and creates the specified propagation if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_TABLE_RULES&quot;" ElementId="#i997673">Adds table rules to the rule set of a capture process, synchronous capture, apply process, or messaging client, and creates the specified capture process, synchronous capture, apply process, or messaging client if it does not exist</SubProgram>
        <SubProgram Name="&quot;CLEANUP_INSTANTIATION_SETUP&quot;" ElementId="#CDEIHIIC">Removes an Oracle Streams replication configuration that was set up by the PRE_INSTANTIATION_SETUP and POST_INSTANTIATION_SETUP procedures in this package</SubProgram>
        <SubProgram Name="&quot;DELETE_COLUMN&quot;" ElementId="#CDEDIEGB">Either adds or removes a declarative rule-based transformation which deletes a column from a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;GET_MESSAGE_TRACKING&quot;" ElementId="#CDEFEDGF">Returns the tracking label for the current session</SubProgram>
        <SubProgram Name="&quot;GET_SCN_MAPPING&quot;" ElementId="#i1018767">Gets information about the system change number (SCN) values to use for Oracle Streams capture and apply processes in an Oracle Streams replication environment</SubProgram>
        <SubProgram Name="&quot;GET_TAG&quot;" ElementId="#CACGBIJI">Gets the binary tag for all redo entries generated by the current session</SubProgram>
        <SubProgram Name="&quot;KEEP_COLUMNS&quot;" ElementId="#CACFIFCG">Either adds or removes a declarative rule-based transformation which keeps a list of columns in a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;MAINTAIN_CHANGE_TABLE&quot;" ElementId="#CACBEIJI">Configures an Oracle Streams environment that records in a change table the data manipulation language (DML) changes made to a source table. Optionally, this procedure can also configure one-way replication of the table from the source database to the destination database</SubProgram>
        <SubProgram Name="&quot;MAINTAIN_GLOBAL&quot;" ElementId="#CDEGDDEG">Configures an Oracle Streams environment that replicates changes at the database level between two databases</SubProgram>
        <SubProgram Name="&quot;MAINTAIN_SCHEMAS&quot;" ElementId="#CDEDAJEB">Configures an Oracle Streams environment that replicates changes to specified schemas between two databases</SubProgram>
        <SubProgram Name="&quot;MAINTAIN_SIMPLE_TABLESPACE&quot;" ElementId="#i1029845">Clones a simple tablespace from a source database at a destination database and uses Oracle Streams to maintain this tablespace at both databases. This procedure is deprecated.</SubProgram>
        <SubProgram Name="&quot;MAINTAIN_SIMPLE_TTS&quot;" ElementId="#CDEIFFHH">Clones a simple tablespace from a source database at a destination database and uses Oracle Streams to maintain this tablespace at both databases</SubProgram>
        <SubProgram Name="&quot;MAINTAIN_TABLES&quot;" ElementId="#CDEDADAI">Configures an Oracle Streams environment that replicates changes to specified tables between two databases</SubProgram>
        <SubProgram Name="&quot;MAINTAIN_TABLESPACES&quot;" ElementId="#i1016534">Clones a set of tablespaces from a source database at a destination database and uses Oracle Streams to maintain these tablespaces at both databases. This procedure is deprecated.</SubProgram>
        <SubProgram Name="&quot;MAINTAIN_TTS&quot;" ElementId="#CDEFBAEH">Clones a set of tablespaces from a source database at a destination database and uses Oracle Streams to maintain these tablespaces at both databases</SubProgram>
        <SubProgram Name="&quot;MERGE_STREAMS&quot;" ElementId="#CDECACGG">Merges a stream flowing from one capture process with a stream flowing from another capture process</SubProgram>
        <SubProgram Name="&quot;MERGE_STREAMS_JOB&quot;" ElementId="#BABBBGGH">Determines whether the original capture process and the cloned capture are within the specified merge threshold and, if they are, runs the MERGE_STREAMS procedure to merge the two streams</SubProgram>
        <SubProgram Name="&quot;POST_INSTANTIATION_SETUP&quot;" ElementId="#CDEBEJFE">Performs the actions required after instantiation to configure an Oracle Streams replication environment</SubProgram>
        <SubProgram Name="&quot;PRE_INSTANTIATION_SETUP&quot;" ElementId="#CDEGDHBC">Performs the actions required before instantiation to configure an Oracle Streams replication environment</SubProgram>
        <SubProgram Name="&quot;PURGE_SOURCE_CATALOG&quot;" ElementId="#i997810">Removes all Oracle Streams data dictionary information at the local database for the specified object</SubProgram>
        <SubProgram Name="&quot;RECOVER_OPERATION&quot;" ElementId="#CDEIFBGC">Provides options for an Oracle Streams replication configuration operation that stopped because it encountered an error. This procedure either rolls forward the operation, rolls back the operation, or purges all of the metadata about the operation.</SubProgram>
        <SubProgram Name="&quot;REMOVE_QUEUE&quot;" ElementId="#i1008918">Removes the specified ANYDATA queue</SubProgram>
        <SubProgram Name="&quot;REMOVE_RULE&quot;" ElementId="#CDEFCADF">Removes the specified rule or all rules from the rule set associated with the specified capture process, synchronous capture, propagation, apply process, or messaging client.</SubProgram>
        <SubProgram Name="&quot;REMOVE_STREAMS_CONFIGURATION&quot;" ElementId="#i1008310">Removes the Oracle Streams configuration at the local database</SubProgram>
        <SubProgram Name="&quot;RENAME_COLUMN&quot;" ElementId="#CDECJDCG">Either adds or removes a declarative rule-based transformation which renames a column in a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;RENAME_SCHEMA&quot;" ElementId="#CDEDCHCG">Either adds or removes a declarative rule-based transformation which renames a schema in a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;RENAME_TABLE&quot;" ElementId="#CDEFFCJI">Either adds or removes a declarative rule-based transformation which renames a table in a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;SET_MESSAGE_NOTIFICATION&quot;" ElementId="#i1012479">Sets a notification for messages that can be dequeued by a specified Oracle Streams messaging client from a specified queue</SubProgram>
        <SubProgram Name="&quot;SET_MESSAGE_TRACKING&quot;" ElementId="#CDEGEEFA">Sets the tracking label for logical change records (LCRs) produced by the current session</SubProgram>
        <SubProgram Name="&quot;SET_RULE_TRANSFORM_FUNCTION&quot;" ElementId="#CDEECBGG">Sets or removes the transformation function name for a rule-based transformation</SubProgram>
        <SubProgram Name="&quot;SET_TAG&quot;" ElementId="#CACIIBAE">Sets the binary tag for all redo entries subsequently generated by the current session</SubProgram>
        <SubProgram Name="&quot;SET_UP_QUEUE&quot;" ElementId="#i997937">Creates a queue table and a queue for use with the capture, propagate, and apply functionality of Oracle Streams</SubProgram>
        <SubProgram Name="&quot;SPLIT_STREAMS&quot;" ElementId="#CDEJBFIE">Splits one stream flowing from a capture process off from all of the other streams flowing from the capture process</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STREAMS_ADVISOR_ADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_streams_adv.htm">
      <Description>The DBMS_STREAMS_ADVISOR_ADM package, one of a set of Oracle Streams packages, provides an interface to gather information about an Oracle Streams environment and advise database administrators based on the information gathered. This package is part of the Oracle Streams Performance Advisor.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ANALYZE_CURRENT_PERFORMANCE&quot;" ElementId="#BABJFFAJ">Gathers information about the Oracle Streams components at one or more databases in your environment and analyzes Oracle Streams performance based on the information gathered</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STREAMS_AUTH&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_streams_aut.htm">
      <Description>The DBMS_STREAMS_AUTH package, one of a set of Oracle Streams packages, provides subprograms for granting privileges to Oracle Streams administrators and revoking privileges from Oracle Streams administrators.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GRANT_ADMIN_PRIVILEGE&quot;" ElementId="#i1000214">Either grants the privileges needed by a user to be an Oracle Streams administrator directly, or generates a script that you can use to grant these privileges</SubProgram>
        <SubProgram Name="&quot;GRANT_REMOTE_ADMIN_ACCESS&quot;" ElementId="#i1001358">Enables a remote Oracle Streams administrator to perform administrative actions at the local database by connecting to the grantee using a database link</SubProgram>
        <SubProgram Name="&quot;REVOKE_ADMIN_PRIVILEGE&quot;" ElementId="#i1000238">Either revokes Oracle Streams administrator privileges from a user directly, or generates a script that you can use to revoke these privileges</SubProgram>
        <SubProgram Name="&quot;REVOKE_REMOTE_ADMIN_ACCESS&quot;" ElementId="#i1001389">Disables a remote Oracle Streams administrator from performing administrative actions by connecting to the grantee using a database link</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STREAMS_HANDLER_ADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_streams_hand.htm">
      <Description>The DBMS_STREAMS_HANDLER_ADM package, one of a set of Oracle Streams packages, provides interfaces to manage statement DML handlers.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_STMT_TO_HANDLER&quot;" ElementId="#CIHFCBBH">Adds a statement to a statement DML handler</SubProgram>
        <SubProgram Name="&quot;CREATE_STMT_HANDLER&quot;" ElementId="#CIHEEBEF">Creates a statement DML handler</SubProgram>
        <SubProgram Name="&quot;DROP_STMT_HANDLER&quot;" ElementId="#CIHFEIJH">Drops a statement DML handler</SubProgram>
        <SubProgram Name="&quot;REMOVE_STMT_FROM_HANDLER&quot;" ElementId="#CIHFEHAE">Removes a statement from a statement DML handler</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STREAMS_MESSAGING&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_streams_msg.htm">
      <Description>The DBMS_STREAMS_MESSAGING package, one of a set of Oracle Streams packages, provides interfaces to enqueue messages into and dequeue messages from a ANYDATA queue.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;DEQUEUE&quot;" ElementId="#i1000272">Uses the specified Oracle Streams messaging client to dequeue a message from the specified queue</SubProgram>
        <SubProgram Name="&quot;ENQUEUE&quot;" ElementId="#i1000609">The current user enqueues a message into the specified queue</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_STREAMS_TABLESPACE_ADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_streams_tbl.htm">
      <Description>The DBMS_STREAMS_TABLESPACE_ADM package, one of a set of Oracle Streams packages, provides administrative interfaces for copying tablespaces between databases and moving tablespaces from one database to another. This package uses transportable tablespaces, Data Pump, the DBMS_FILE_TRANSFER package, and the DBMS_FILE_GROUP package.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ATTACH_SIMPLE_TABLESPACE&quot;" ElementId="#i1000780">Uses Data Pump to import a simple tablespace previously exported using the DBMS_STREAMS_TABLESPACE_ADM package or Data Pump export</SubProgram>
        <SubProgram Name="&quot;ATTACH_TABLESPACES&quot;" ElementId="#i1000995">Uses Data Pump to import a self-contained tablespace set previously exported using the DBMS_STREAMS_TABLESPACE_ADM package, Data Pump export, or the Recovery Manager (RMAN) TRANSPORTTABLESPACE command</SubProgram>
        <SubProgram Name="&quot;CLONE_SIMPLE_TABLESPACE&quot;" ElementId="#i1000996">Clones a simple tablespace. The tablespace can later be attached to a database.</SubProgram>
        <SubProgram Name="&quot;CLONE_TABLESPACES&quot;" ElementId="#i1000997">Clones a set of self-contained tablespaces. The tablespaces can later be attached to a database.</SubProgram>
        <SubProgram Name="&quot;DETACH_SIMPLE_TABLESPACE&quot;" ElementId="#i1000998">Detaches a simple tablespace. The tablespace can later be attached to a database.</SubProgram>
        <SubProgram Name="&quot;DETACH_TABLESPACES&quot;" ElementId="#i1007519">Detaches a set of self-contained tablespaces. The tablespaces can later be attached to a database.</SubProgram>
        <SubProgram Name="&quot;PULL_SIMPLE_TABLESPACE&quot;" ElementId="#i1001000">Copies a simple tablespace from a remote database and attaches it to the current database</SubProgram>
        <SubProgram Name="&quot;PULL_TABLESPACES&quot;" ElementId="#i1003360">Copies a set of self-contained tablespaces from a remote database and attaches the tablespaces to the current database</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_SYNC_REFRESH&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_sync_refresh.htm">
      <Description>The DBMS_SYNC_REFRESH package provides an interface to perform a synchronous refresh of materialized views.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ABORT_REFRESH&quot;" ElementId="#CEGGFBJJ">Aborts a refresh.</SubProgram>
        <SubProgram Name="&quot;ALTER_REFRESH_STATS_RETENTION&quot;" ElementId="#CEGHHFCD">Alters the refresh history retention value, specified in days.</SubProgram>
        <SubProgram Name="&quot;CAN_SYNCREF_TABLE&quot;" ElementId="#CEGIICHJ">Advises on whether a table and its dependent materialized views are eligible for synchronous refresh.</SubProgram>
        <SubProgram Name="&quot;EXECUTE_REFRESH&quot;" ElementId="#CEGIFEAI">Executes synchronous refresh on the synchronous refresh groups.</SubProgram>
        <SubProgram Name="&quot;GET_ALL_GROUP_IDS&quot;" ElementId="#CEGBFFJJ">Returns the group IDs of all the synchronous refresh groups in the database.</SubProgram>
        <SubProgram Name="&quot;GET_GROUP_ID&quot;" ElementId="#CEGCHJFH">Returns the group ID of a table or materialized view.</SubProgram>
        <SubProgram Name="&quot;GET_GROUP_ID_LIST&quot;" ElementId="#CEGJGDED">Returns the group IDs of the tables in a given list of objects (tables or materialized views).</SubProgram>
        <SubProgram Name="&quot;PREPARE_REFRESH&quot;" ElementId="#CEGIAICG">Prepares the sync refresh groups for refresh.</SubProgram>
        <SubProgram Name="&quot;PREPARE_STAGING_LOG&quot;" ElementId="#CEGDIFBF">Validates and collects statistics on the data in the staging log.</SubProgram>
        <SubProgram Name="&quot;PURGE_REFRESH_STATS&quot;" ElementId="#CEGCDFJD">Purges the refresh history of sync refreshes that took place within a time specified by a timestamp parameter.</SubProgram>
        <SubProgram Name="&quot;REGISTER_MVIEWS&quot;" ElementId="#CEGEBACE">Registers materialized views for synchronous refresh.</SubProgram>
        <SubProgram Name="&quot;REGISTER_PARTITION_OPERATION&quot;" ElementId="#CEGDCBAA">Registers a partition maintenance operation on a partition of a base table.</SubProgram>
        <SubProgram Name="&quot;UNREGISTER_MVIEWS&quot;" ElementId="#CEGBFFCD">Unregisters materialized views from synchronous refresh.</SubProgram>
        <SubProgram Name="&quot;UNREGISTER_PARTITION_OPERATION&quot;" ElementId="#CEGIGCFF">Unregisters a partition maintenance operation on a partition of a base table.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_TDB&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_tdb.htm">
      <Description>The DBMS_TDB package reports whether a database can be transported between platforms using the RMAN CONVERT DATABASE command. The package verifies that databases on the current host platform are of the same endian format as the destination platform, and that the state of the current database does not prevent transport of the database.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CHECK_DB&quot;" ElementId="#BDCJHJIC">Checks whether a database can be transported to a target platform</SubProgram>
        <SubProgram Name="&quot;CHECK_EXTERNAL&quot;" ElementId="#BDCCBGDD">Checks whether a database has external tables, directory or BFILEs</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_TRACE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_trace.htm">
      <Description>The DBMS_TRACE package contains the interface to trace PL/SQL functions, procedures, and exceptions.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLEAR_PLSQL_TRACE&quot;" ElementId="#i1002348">Stops trace data dumping in session</SubProgram>
        <SubProgram Name="&quot;GET_PLSQL_TRACE_LEVEL&quot;" ElementId="#CIAIFBJF">Gets the trace level</SubProgram>
        <SubProgram Name="&quot;PLSQL_TRACE_VERSION&quot;" ElementId="#i1002395">Gets the version number of the trace package</SubProgram>
        <SubProgram Name="&quot;SET_PLSQL_TRACE&quot;" ElementId="#i1000112">Starts tracing in the current session</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_TRANSACTION&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_transa.htm">
      <Description>The DBMS_TRANSACTION package provides access to SQL transaction statements from stored procedures.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADVISE_COMMIT&quot;" ElementId="#i1000260">Equivalent to the SQL statement:ALTER SESSION ADVISE COMMIT</SubProgram>
        <SubProgram Name="&quot;ADVISE_NOTHING&quot;" ElementId="#i1000264">Equivalent to the SQL statement:ALTER SESSION ADVISE NOTHING</SubProgram>
        <SubProgram Name="&quot;ADVISE_ROLLBACK&quot;" ElementId="#i1000298">Equivalent to the SQL statement:ALTER SESSION ADVISE ROLLBACK</SubProgram>
        <SubProgram Name="&quot;COMMIT&quot;" ElementId="#i1000373">Equivalent to the SQL statement:COMMIT</SubProgram>
        <SubProgram Name="&quot;COMMIT_COMMENT&quot;" ElementId="#i1000443">Equivalent to the SQL statement:COMMIT COMMENT &lt;text&gt;</SubProgram>
        <SubProgram Name="&quot;COMMIT_FORCE&quot;" ElementId="#i1000448">Equivalent to the SQL statement:COMMIT FORCE &lt;text&gt;, &lt;number&gt;"</SubProgram>
        <SubProgram Name="&quot;LOCAL_TRANSACTION_ID&quot;" ElementId="#i1000530">Returns the local (to instance) unique identifier for the current transaction</SubProgram>
        <SubProgram Name="&quot;PURGE_LOST_DB_ENTRY&quot;" ElementId="#i1000592">Enables removal of incomplete transactions from the local site when the remote database is destroyed or re-created before recovery completes</SubProgram>
        <SubProgram Name="&quot;PURGE_MIXED&quot;" ElementId="#i1000748">Deletes information about a given mixed outcome transaction</SubProgram>
        <SubProgram Name="&quot;READ_ONLY&quot;" ElementId="#i1000791">Equivalent to the SQL statement:SET TRANSACTION READ ONLY</SubProgram>
        <SubProgram Name="&quot;READ_WRITE&quot;" ElementId="#CIAEGFIB">equivalent to the SQL statement:SET TRANSACTION READ WRITE</SubProgram>
        <SubProgram Name="&quot;ROLLBACK&quot;" ElementId="#i1000835">Equivalent to the SQL statement:ROLLBACK</SubProgram>
        <SubProgram Name="&quot;ROLLBACK_FORCE&quot;" ElementId="#i1000863">Equivalent to the SQL statement:ROLLBACKFORCE&lt;text&gt;</SubProgram>
        <SubProgram Name="&quot;ROLLBACK_SAVEPOINT&quot;" ElementId="#i1000909">Equivalent to the SQL statement:ROLLBACKTOSAVEPOINT&lt;savepoint_name&gt;</SubProgram>
        <SubProgram Name="&quot;SAVEPOINT&quot;" ElementId="#i997017">Equivalent to the SQL statement:SAVEPOINT&lt;savepoint_name&gt;</SubProgram>
        <SubProgram Name="&quot;STEP_ID&quot;" ElementId="#i1000520">Returns local (to local transaction) unique positive integer that orders the DML operations of a transaction</SubProgram>
        <SubProgram Name="&quot;USE_ROLLBACK_SEGMENT&quot;" ElementId="#i1000982">Equivalent to the SQL statement:SETTRANSACTIONUSEROLLBACKSEGMENT&lt;rb_seg_name&gt;</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_TRANSFORM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_transf.htm">
      <Description>The DBMS_TRANSFORM package provides an interface to the message format transformation features of Oracle Advanced Queuing.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CREATE_TRANSFORMATION&quot;" ElementId="#i996793">Creates a transformation that maps an object of the source type to an object of the destination type</SubProgram>
        <SubProgram Name="&quot;DROP_TRANSFORMATION&quot;" ElementId="#i998188">Drops the given transformation</SubProgram>
        <SubProgram Name="&quot;MODIFY_TRANSFORMATION&quot;" ElementId="#i997956">Modifies an existing transformation</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_TSDP_MANAGE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_tsdp_manage.htm">
      <Description>The DBMS_TSDP_MANAGE package provides an interface to import and manage sensitive columns and sensitive column types in the database, and is used in conjunction with the DBMS_TSDP_PROTECT package with regard to transparent sensitive data protection (TSDP) policies. DBMS_TSDP_MANAGE is available with the Enterprise Edition only.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_SENSITIVE_COLUMN&quot;" ElementId="#CACHHGEJ">Adds a column to the sensitive column list</SubProgram>
        <SubProgram Name="&quot;ADD_SENSITIVE_TYPE&quot;" ElementId="#CACJIECA">Creates and adds a sensitive column type to the list of sensitive column types in the database</SubProgram>
        <SubProgram Name="&quot;ALTER_SENSITIVE_COLUMN&quot;" ElementId="#CACFECBC">Alters the sensitive type and/or the comment of a column in the sensitive column list.</SubProgram>
        <SubProgram Name="&quot;DROP_SENSITIVE_COLUMN&quot;" ElementId="#CACFGEJH">Removes columns from the sensitive column list</SubProgram>
        <SubProgram Name="&quot;DROP_SENSITIVE_TYPE&quot;" ElementId="#CACHCHCG">Drops a sensitive column type from the list sensitive column types in the database</SubProgram>
        <SubProgram Name="&quot;DROP_SENSITIVE_TYPE_SOURCE&quot;" ElementId="#CACFCACC">Drops sensitive column types corresponding to a source from the list sensitive column types in the database</SubProgram>
        <SubProgram Name="&quot;IMPORT_DISCOVERY_RESULT&quot;" ElementId="#CACDIAIA">Imports sensitive columns from an external source. This can be an Application Data Model (ADM) from an Oracle Enterprise Manager Cloud Control instance</SubProgram>
        <SubProgram Name="&quot;IMPORT_SENSITIVE_TYPES&quot;" ElementId="#CACDBFBA">Imports a list of sensitive column types from a source</SubProgram>
        <SubProgram Name="&quot;REMOVE_DISCOVERY_RESULT&quot;" ElementId="#CACBIGEC">Removes sensitive columns corresponding to an Application Data Model (ADM) from an Oracle Enterprise Manager Cloud Control instance.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_TSDP_PROTECT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_tsdp_protect.htm">
      <Description>The DBMS_TSDP_PROTECT package provides an interface to configure transparent sensitive data protection (TSDP) policies in conjunction with the DBMS_TSDP_MANAGE package. DBMS_TSDP_PROTECT is available with the Enterprise Edition only.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_POLICY&quot;" ElementId="#BHADBCBH">Creates a TSDP policy</SubProgram>
        <SubProgram Name="&quot;ALTER_POLICY&quot;" ElementId="#BHABIEGB">Alters a TDSP policy</SubProgram>
        <SubProgram Name="&quot;ASSOCIATE_POLICY&quot;" ElementId="#BHAJDJIC">Associates or disassociates a TSDP policy with a sensitive column type</SubProgram>
        <SubProgram Name="&quot;DISABLE_PROTECTION_COLUMN&quot;" ElementId="#BHACJCGA">Disables protection for columns</SubProgram>
        <SubProgram Name="&quot;DISABLE_PROTECTION_SOURCE&quot;" ElementId="#BHABFDJC">Disables protection based on the source of truth for the sensitive columns</SubProgram>
        <SubProgram Name="&quot;DISABLE_PROTECTION_TYPE&quot;" ElementId="#BHACEJJA">Disables protection for a sensitive column type</SubProgram>
        <SubProgram Name="&quot;DROP_POLICY&quot;" ElementId="#BHAJHGIH">Removes a TDSP policy</SubProgram>
        <SubProgram Name="&quot;ENABLE_PROTECTION_COLUMN&quot;" ElementId="#BHACDGII">Enables protection for columns</SubProgram>
        <SubProgram Name="&quot;ENABLE_PROTECTION_SOURCE&quot;" ElementId="#BHADGCBA">Enables protection based on the source of truth for the sensitive columns</SubProgram>
        <SubProgram Name="&quot;ENABLE_PROTECTION_TYPE&quot;" ElementId="#BHAIIGGA">Enables protection for a sensitive column type</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_TTS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_tts.htm">
      <Description>The DBMS_TTS package checks if the transportable set is self-contained. All violations are inserted into a temporary table that can be selected from the view TRANSPORT_SET_VIOLATIONS.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;DOWNGRADE&quot;" ElementId="#BEIHHEBB">Downgrades transportable tablespace-related data</SubProgram>
        <SubProgram Name="&quot;TRANSPORT_SET_CHECK&quot;" ElementId="#BEIBHJBJ">Checks if a set of tablespaces (to be transported) is self-contained</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_TYPES&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_types.htm">
      <Description>The DBMS_TYPES package consists of constants, which represent the built-in and user-defined types.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_UTILITY&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_util.htm">
      <Description>The DBMS_UTILITY package provides various utility subprograms.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ACTIVE_INSTANCES&quot;" ElementId="#CIHGBJBF">Returns the active instance</SubProgram>
        <SubProgram Name="&quot;ANALYZE_DATABASE&quot;" ElementId="#BABDDBFI">Analyzes all the tables, clusters and indexes in a database</SubProgram>
        <SubProgram Name="&quot;ANALYZE_PART_OBJECT&quot;" ElementId="#i1002400">Analyzes the given tables and indexes</SubProgram>
        <SubProgram Name="&quot;ANALYZE_SCHEMA&quot;" ElementId="#BABGDEAI">Analyzes all the tables, clusters and indexes in a schema</SubProgram>
        <SubProgram Name="&quot;CANONICALIZE&quot;" ElementId="#i1004667">Canonicalizes a given string</SubProgram>
        <SubProgram Name="&quot;COMMA_TO_TABLE&quot;" ElementId="#i1002468">Converts a comma-delimited list of names into a PL/SQL table of names</SubProgram>
        <SubProgram Name="&quot;COMPILE_SCHEMA&quot;" ElementId="#i1002332">Compiles all procedures, functions, packages, views and triggers in the specified schema</SubProgram>
        <SubProgram Name="&quot;CREATE_ALTER_TYPE_ERROR_TABLE&quot;" ElementId="#i1004185">Creates an error table to be used in the EXCEPTION clause of the ALTERTYPE statement</SubProgram>
        <SubProgram Name="&quot;CURRENT_INSTANCE&quot;" ElementId="#i1002512">Returns the current connected instance number</SubProgram>
        <SubProgram Name="&quot;DATA_BLOCK_ADDRESS_BLOCK&quot;" ElementId="#i1002531">Gets the block number part of a data block address</SubProgram>
        <SubProgram Name="&quot;DATA_BLOCK_ADDRESS_FILE&quot;" ElementId="#i1002627">Gets the file number part of a data block address</SubProgram>
        <SubProgram Name="&quot;DB_VERSION&quot;" ElementId="#i1002631">Returns version information for the database</SubProgram>
        <SubProgram Name="&quot;EXEC_DDL_STATEMENT&quot;" ElementId="#i1002666">Executes the DDL statement in parse_string</SubProgram>
        <SubProgram Name="&quot;EXPAND_SQL_TEXT&quot;" ElementId="#BJEIAEBB">Recursively replaces any view references in the input SQL query with the corresponding view subquery</SubProgram>
        <SubProgram Name="&quot;FORMAT_CALL_STACK&quot;" ElementId="#i997163">Formats the current call stack</SubProgram>
        <SubProgram Name="&quot;FORMAT_ERROR_BACKTRACE&quot;" ElementId="#i1003874">Formats the backtrace from the point of the current error to the exception handler where the error has been caught</SubProgram>
        <SubProgram Name="&quot;FORMAT_ERROR_STACK&quot;" ElementId="#i1002463">Formats the current error stack</SubProgram>
        <SubProgram Name="&quot;GET_CPU_TIME&quot;" ElementId="#i1003768">Returns the current CPU time in 100th's of a second</SubProgram>
        <SubProgram Name="&quot;GET_DEPENDENCY&quot;" ElementId="#i1004023">Shows the dependencies on the object passed in.</SubProgram>
        <SubProgram Name="&quot;GET_ENDIANNESS&quot;" ElementId="#BABHABJA">Gets the endianness of the database platform</SubProgram>
        <SubProgram Name="&quot;GET_HASH_VALUE&quot;" ElementId="#i1003646">Computes a hash value for the given string</SubProgram>
        <SubProgram Name="&quot;GET_PARAMETER_VALUE&quot;" ElementId="#i997189">Gets the value of specified init.ora parameter</SubProgram>
        <SubProgram Name="&quot;GET_SQL_HASH&quot;" ElementId="#BABDBIHF">Computes a hash value for the given string using MD5 algorithm</SubProgram>
        <SubProgram Name="&quot;GET_TIME&quot;" ElementId="#i1002765">Returns the current time in 100th's of a second</SubProgram>
        <SubProgram Name="&quot;GET_TZ_TRANSITIONS&quot;" ElementId="#BJEFCEEF">Returns timezeone transitions by regionid from the timezone.dat file</SubProgram>
        <SubProgram Name="&quot;INVALIDATE&quot;" ElementId="#BABFDACJ">Invalidates a database object and (optionally) modifies its PL/SQL compiler parameter settings</SubProgram>
        <SubProgram Name="&quot;IS_BIT_SET&quot;" ElementId="#BJEDEHEI">Checks the bit setting for the given bit in the given RAW value</SubProgram>
        <SubProgram Name="&quot;IS_CLUSTER_DATABASE&quot;" ElementId="#i1002749">Determines if the database is running in cluster database mode</SubProgram>
        <SubProgram Name="&quot;MAKE_DATA_BLOCK_ADDRESS&quot;" ElementId="#i1002839">Creates a data block address given a file number and a block number</SubProgram>
        <SubProgram Name="&quot;NAME_RESOLVE&quot;" ElementId="#i997271">Resolves the given name</SubProgram>
        <SubProgram Name="&quot;NAME_TOKENIZE&quot;" ElementId="#BJEFIFBJ">Calls the parser to parse the given name</SubProgram>
        <SubProgram Name="&quot;OLD_CURRENT_SCHEMA&quot;" ElementId="#BABICAFJ">Returns the session value from SYS_CONTEXT ('USERENV', 'CURRENT_SCHEMA')</SubProgram>
        <SubProgram Name="&quot;OLD_CURRENT_USER&quot;" ElementId="#BABFFEIB">Returns the session value from SYS_CONTEXT ('USERENV', 'CURRENT_USER')</SubProgram>
        <SubProgram Name="&quot;PORT_STRING&quot;" ElementId="#i997419">Returns a string that uniquely identifies the version of Oracle and the operating system</SubProgram>
        <SubProgram Name="&quot;SQLID_TO_SQLHASH&quot;" ElementId="#BABEBJAI">Converts a SQL ID into a hash value</SubProgram>
        <SubProgram Name="&quot;TABLE_TO_COMMA&quot;" ElementId="#i1002844">Converts a PL/SQL table of names into a comma-delimited list of names</SubProgram>
        <SubProgram Name="&quot;VALIDATE&quot;" ElementId="#i1005273">Makes invalid database objects valid</SubProgram>
        <SubProgram Name="&quot;WAIT_ON_PENDING_DML&quot;" ElementId="#BABCAEFB">Waits until all transactions (other than the caller's own) that have locks on the listed tables and began prior to the specified SCN have either committed or been rolled back</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_WARNING&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_warn.htm">
      <Description>The DBMS_WARNING package provides a way to manipulate the behavior of PL/SQL warning messages, in particular by reading and changing the setting of the PLSQL_WARNINGS initialization parameter to control what kinds of warnings are suppressed, displayed, or treated as errors. This package provides the interface to query, modify and delete current system or session settings.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_WARNING_SETTING_CAT&quot;" ElementId="#i1000066">Modifies the current session or system warning settings of the warning_category previously supplied</SubProgram>
        <SubProgram Name="&quot;ADD_WARNING_SETTING_NUM&quot;" ElementId="#i1001011">Modifies the current session or system warning settings of the or warning_number previously supplied</SubProgram>
        <SubProgram Name="&quot;GET_CATEGORY&quot;" ElementId="#i1001621">Returns the category name, given the message number</SubProgram>
        <SubProgram Name="&quot;GET_WARNING_SETTING_CAT&quot;" ElementId="#i1000570">Returns the specific warning category in the session</SubProgram>
        <SubProgram Name="&quot;GET_WARNING_SETTING_NUM&quot;" ElementId="#i1000778">Returns the specific warning number in the session</SubProgram>
        <SubProgram Name="&quot;GET_WARNING_SETTING_STRING&quot;" ElementId="#i1001622">Returns the entire warning string for the current session</SubProgram>
        <SubProgram Name="&quot;SET_WARNING_SETTING_STRING&quot;" ElementId="#i1001623">Replaces previous settings with the new value</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_WM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_wm.htm">
      <Description>The DBMS_WM package provides an interface to Oracle Database Workspace Manager (often referred to as Workspace Manager).</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_WORKLOAD_CAPTURE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_workload_capture.htm">
      <Description>The DBMS_WORKLOAD_CAPTURE package configures the Workload Capture system and produce the workload capture data. Replay of this capture is implemented by way of the DBMS_WORKLOAD_REPLAY package.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_FILTER&quot;" ElementId="#CFHFAAFB">Adds a specified filter</SubProgram>
        <SubProgram Name="&quot;DELETE_CAPTURE_INFO&quot;" ElementId="#CFHJFFJH">Deletes the rows in the DBA_WORKLOAD_CAPTURES and DBA_WORKLOAD_FILTERS views that corresponds to the given workload capture ID</SubProgram>
        <SubProgram Name="&quot;DELETE_FILTER&quot;" ElementId="#CHDEJDGC">Deletes a specified filter</SubProgram>
        <SubProgram Name="&quot;EXPORT_AWR&quot;" ElementId="#CFHBICJI">Exports the AWR snapshots associated with a given capture ID</SubProgram>
        <SubProgram Name="&quot;FINISH_CAPTURE&quot;" ElementId="#CHDBCGBA">Finalizes the workload capture by signaling all connected sessions to stop capture, and stops future requests to the database from being captured</SubProgram>
        <SubProgram Name="&quot;GET_CAPTURE_INFO&quot;" ElementId="#CFHEGGDF">Retrieves all the information regarding a workload capture present in the stipulated directory, imports the information into the DBA_WORKLOAD_CAPTURES and DBA_WORKLOAD_FILTERS views, and returns the appropriate DBA_WORKLOAD_CAPTURES.ID</SubProgram>
        <SubProgram Name="&quot;IMPORT_AWR&quot;" ElementId="#CFHGHFHG">Imports the AWR snapshots associated with a given capture ID</SubProgram>
        <SubProgram Name="&quot;REPORT&quot;" ElementId="#CHDIIDCC">Returns a report on the workload capture under consideration using one or more different sources</SubProgram>
        <SubProgram Name="&quot;START_CAPTURE&quot;" ElementId="#CHDJIJIE">Initiates workload capture on all instances</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_WORKLOAD_REPLAY&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_workload_replay.htm">
      <Description>The DBMS_WORKLOAD_REPLAY package provides an interface to replay a workload capture.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_CAPTURE&quot;" ElementId="#BGBCAACH">Adds the given capture to the current schedule</SubProgram>
        <SubProgram Name="&quot;ADD_FILTER&quot;" ElementId="#BGBHIBIE">Adds a filter to replay only a subset of the captured workload</SubProgram>
        <SubProgram Name="&quot;ADD_SCHEDULE_ORDERING&quot;" ElementId="#BGBEDGHC">Adds a schedule order between two captures</SubProgram>
        <SubProgram Name="&quot;BEGIN_REPLAY_SCHEDULE&quot;" ElementId="#BGBDHBJH">Initiates the creation of a reusable replay schedule</SubProgram>
        <SubProgram Name="&quot;CALIBRATE&quot;" ElementId="#CHDFBCDI">Operates on a processed workload capture directory to estimate the number of hosts and workload replay clients needed to faithfully replay the given workload</SubProgram>
        <SubProgram Name="&quot;CANCEL_REPLAY&quot;" ElementId="#CBADBCDC">Cancels the workload replay in progress</SubProgram>
        <SubProgram Name="&quot;COMPARE_PERIOD_REPORT&quot;" ElementId="#BGBGFDBG">Generates a report comparing a replay to its capture or to another replay of the same capture</SubProgram>
        <SubProgram Name="&quot;COMPARE_SQLSET_REPORT&quot;" ElementId="#CBAFDIIC">Generates a report comparing a sqlset captured during replay to one captured during workload capture or to one captured during another replay of the same capture</SubProgram>
        <SubProgram Name="&quot;CREATE_FILTER_SET&quot;" ElementId="#BGBFEFFF">Uses the replay filters added to create a set of filters to use against the replay in replay_dir</SubProgram>
        <SubProgram Name="&quot;DELETE_FILTER&quot;" ElementId="#BGBJACAG">Deletes the named filter</SubProgram>
        <SubProgram Name="&quot;DELETE_REPLAY_INFO&quot;" ElementId="#BGBEGEAE">Deletes the rows in DBA_WORKLOAD_REPLAYS that corresponds to the given workload replay ID</SubProgram>
        <SubProgram Name="&quot;END_REPLAY_SCHEDULE&quot;" ElementId="#BGBCFCAI">Wraps up the creation of the current schedule</SubProgram>
        <SubProgram Name="&quot;EXPORT_AWR&quot;" ElementId="#BGBHGCEA">Exports the Automatic Workload Repository (AWR) snapshots associated with a given replay ID</SubProgram>
        <SubProgram Name="&quot;GENERATE_CAPTURE_SUBSET&quot;" ElementId="#BGBJBDJH">Creates a new capture from an existing workload capture</SubProgram>
        <SubProgram Name="&quot;GET_DIVERGING_STATEMENT&quot;" ElementId="#BGBIHGFG">Exports the Automatic Workload Repository (AWR) snapshots associated with a given replay ID</SubProgram>
        <SubProgram Name="&quot;GET_REPLAY_DIRECTORY&quot;" ElementId="#BGBIFEGD">Returns the current replay directory set by the SET_REPLAY_DIRECTORY Procedure.</SubProgram>
        <SubProgram Name="&quot;GET_REPLAY_INFO&quot;" ElementId="#BGBJDDHC">Retrieves information about the workload capture and the history of all the workload replay attempts from the related directory</SubProgram>
        <SubProgram Name="&quot;GET_REPLAY_TIMEOUT&quot;" ElementId="#CBAHDDAA">Retrieves the replay timeout setting</SubProgram>
        <SubProgram Name="&quot;IMPORT_AWR&quot;" ElementId="#BGBFJABI">Imports the Automatic Workload Repository (AWR) snapshots associated with a given replay ID</SubProgram>
        <SubProgram Name="&quot;INITIALIZE_CONSOLIDATED_REPLAY&quot;" ElementId="#BGBIEAIJ">Puts the database state in INIT for a multiple-capture replay</SubProgram>
        <SubProgram Name="&quot;INITIALIZE_REPLAY&quot;" ElementId="#CHDDDJBH">Initializes replay, and loads specific data produced during processing into the database</SubProgram>
        <SubProgram Name="&quot;IS_REPLAY_PAUSED&quot;" ElementId="#BGBBJDIA">Reports whether the replay is currently paused</SubProgram>
        <SubProgram Name="&quot;PAUSE_REPLAY&quot;" ElementId="#CHDHCADH">Pauses the in-progress workload replay</SubProgram>
        <SubProgram Name="&quot;POPULATE_DIVERGENCE&quot;" ElementId="#BGBCIGFB">Precomputes the divergence information for the given call, stream, or the whole replay so that the GET_DIVERGING_STATEMENT Function returns as quickly as possible for the precomputed calls</SubProgram>
        <SubProgram Name="&quot;PREPARE_REPLAY&quot;" ElementId="#CBAFFDFE">Puts the database in a special "Prepare" mode</SubProgram>
        <SubProgram Name="&quot;PREPARE_CONSOLIDATED_REPLAY&quot;" ElementId="#BGBEGDAB">Puts the database in a special "Prepare" mode for a multiple-capture replay</SubProgram>
        <SubProgram Name="&quot;PROCESS_CAPTURE&quot;" ElementId="#CHDHJIIH">Processes the workload capture found in capture_dir in place</SubProgram>
        <SubProgram Name="&quot;REMAP_CONNECTION&quot;" ElementId="#BGBHJAED">Remaps the captured connection to a new one so that the user sessions can connect to the database in a desired way during workload replay</SubProgram>
        <SubProgram Name="&quot;REMOVE_CAPTURE&quot;" ElementId="#BGBDHBDI">Removes the given capture from the current schedule</SubProgram>
        <SubProgram Name="&quot;REMOVE_SCHEDULE_ORDERING&quot;" ElementId="#BGBHAHJI">Removes an existing schedule order from the current replay schedule</SubProgram>
        <SubProgram Name="&quot;REPORT&quot;" ElementId="#CHDHJFDB">Generates a report on the given workload replay</SubProgram>
        <SubProgram Name="&quot;RESUME_REPLAY&quot;" ElementId="#CBADIDCD">Resumes a paused workload replay</SubProgram>
        <SubProgram Name="&quot;REUSE_REPLAY_FILTER_SET&quot;" ElementId="#BGBEEBAE">Reuses filters in the specified filter set as if each were added using the ADD_SCHEDULE_ORDERING Function</SubProgram>
        <SubProgram Name="&quot;SET_ADVANCED_PARAMETER&quot;" ElementId="#BGBHIACF">Sets an advanced parameter for replay besides the ones used with the PREPARE_REPLAY Procedure</SubProgram>
        <SubProgram Name="&quot;SET_REPLAY_DIRECTORY&quot;" ElementId="#CBABDBAG">Sets a directory that contains multiple workload captures as the current replay directory</SubProgram>
        <SubProgram Name="&quot;SET_REPLAY_TIMEOUT&quot;" ElementId="#BGBGGIIC">Sets the replay timeout setting</SubProgram>
        <SubProgram Name="&quot;SET_USER_MAPPING&quot;" ElementId="#BGBGFDFI">Sets a new schema or user name to be used during replay instead of the captured user</SubProgram>
        <SubProgram Name="&quot;START_CONSOLIDATED_REPLAY&quot;" ElementId="#BGBFJGIH">Starts the replay of a multiple-capture capture</SubProgram>
        <SubProgram Name="&quot;START_REPLAY&quot;" ElementId="#CHDDEHHI">Starts the workload replay</SubProgram>
        <SubProgram Name="&quot;USE_FILTER_SET&quot;" ElementId="#BGBCECGI">Uses the given filter set that has been created by calling the CREATE_FILTER_SET Procedure to filter the current replay</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_WORKLOAD_REPOSITORY&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_workload_repos.htm">
      <Description>The DBMS_WORKLOAD_REPOSITORY package lets you manage the Workload Repository, performing operations such as managing snapshots and baselines.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XA&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xa.htm">
      <Description>The DBMS_XA package contains the XA/Open interface for applications to call XA interface in PL/SQL. Using this package, application developers can switch or share transactions across SQL*Plus sessions or processes using PL/SQL.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XDB&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xdb.htm">
      <Description>Note:
The DBMS_XDB package subprograms and constants are deprecated with Oracle Database 12c. While all features continue to be supported for backward compatibility, Oracle recommends that you use the alternative procedures provided in each case. For more information, see Deprecated Subprograms and Constants.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ACLCHECKPRIVILEGES&quot;" ElementId="#i1007419">Checks access privileges granted to the current user by specified ACL document on a resource whose owner is specified by the 'owner' parameter.</SubProgram>
        <SubProgram Name="&quot;ADDHTTPEXPIREMAPPING&quot;" ElementId="#BDCICHHJ">Adds to xdb$config a mapping of the URL pattern to an expiration date. This will control the Expire headers for URLs matching the pattern.</SubProgram>
        <SubProgram Name="&quot;ADDMIMEMAPPING&quot;" ElementId="#CHDFBAIF">Adds a mime mapping to the XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDSCHEMALOCMAPPING&quot;" ElementId="#CHDBEGDG">Adds a schema location mapping to the XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDSERVLET&quot;" ElementId="#CHDBICDG">Adds a servlet to XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDSERVLETMAPPING&quot;" ElementId="#CHDCGCHA">Adds a servlet mapping to XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDSERVLETSECROLE&quot;" ElementId="#CHDJJGBA">Adds a security role REF to a specified servlet in the XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDXMLEXTENSION&quot;" ElementId="#CHDEIEFA">Adds adds an XML extension to the XDB configuration</SubProgram>
        <SubProgram Name="&quot;APPENDRESOURCEMETADATA&quot;" ElementId="#BGBEICDF">Takes in user-defined metadata either as a REF to XMLTYPE or an XMLTYPE and adds it to the desired resource</SubProgram>
        <SubProgram Name="&quot;CFG_GET&quot;" ElementId="#i1011724">Retrieves the session's configuration information</SubProgram>
        <SubProgram Name="&quot;CFG_REFRESH&quot;" ElementId="#i1013251">Refreshes the session's configuration information to the latest configuration</SubProgram>
        <SubProgram Name="&quot;CFG_UPDATE&quot;" ElementId="#i1007513">Updates the configuration information</SubProgram>
        <SubProgram Name="&quot;CHANGEOWNER&quot;" ElementId="#CHDDJHJG">Changes the owner of the resource/s to the specified owner.</SubProgram>
        <SubProgram Name="&quot;CHANGEPRIVILEGES&quot;" ElementId="#i1009624">Adds a specified ACE to a specified resource's ACL</SubProgram>
        <SubProgram Name="&quot;CHECKPRIVILEGES&quot;" ElementId="#i1007635">Checks access privileges granted to the current user on the specified resource</SubProgram>
        <SubProgram Name="&quot;CREATEFOLDER&quot;" ElementId="#i1007707">Creates a new folder resource in the hierarchy</SubProgram>
        <SubProgram Name="&quot;CREATEOIDPATH&quot;" ElementId="#i1013935">Creates a virtual path to the resource based on object ID</SubProgram>
        <SubProgram Name="&quot;CREATERESOURCE&quot;" ElementId="#i1010030">Creates a new resource</SubProgram>
        <SubProgram Name="&quot;DELETEHTTPEXPIREMAPPING&quot;" ElementId="#CHDHHCEI">Deletes from xdb$config all mappings of the URL pattern to an expiration date</SubProgram>
        <SubProgram Name="&quot;DELETEMIMEMAPPING&quot;" ElementId="#BDCIHHGA">Deletes the mime mapping from the XDB configuration</SubProgram>
        <SubProgram Name="&quot;DELETERESOURCE&quot;" ElementId="#i1007804">Deletes a resource from the hierarchy</SubProgram>
        <SubProgram Name="&quot;DELETERESOURCEMETADATA&quot;" ElementId="#BDCFECCC">Deletes metadata from a resource (can be used for schema-based or nonschema-based metadata)</SubProgram>
        <SubProgram Name="&quot;DELETESCHEMALOCMAPPING&quot;" ElementId="#CHDDIHFH">Deletes the schema location mapping for the specified schema URL from the XDB configuration.</SubProgram>
        <SubProgram Name="&quot;DELETESERVLET&quot;" ElementId="#CHDCGHFE">Deletes a servlet from XDB configuration</SubProgram>
        <SubProgram Name="&quot;DELETESERVLETMAPPING&quot;" ElementId="#CHDGDBDI">Deletes the servlet mapping for the specified servlet name from the XDB configuration</SubProgram>
        <SubProgram Name="&quot;DELETESERVLETSECROLE&quot;" ElementId="#CHDEBDGB">Deletes the specified role from a servlet in the XDB configuration</SubProgram>
        <SubProgram Name="&quot;DELETEXMLEXTENSION&quot;" ElementId="#CHDCJDBG">Deletes the specified XML extension from the XDB configuration</SubProgram>
        <SubProgram Name="&quot;ENABLEDIGESTAUTHENTICATION&quot;" ElementId="#BGBGAIJE">Enables digest authentication</SubProgram>
        <SubProgram Name="&quot;EXISTSRESOURCE&quot;" ElementId="#i1009928">Determines if a resource is the hierarchy, based on its absolute path</SubProgram>
        <SubProgram Name="&quot;GETACLDOCUMENT&quot;" ElementId="#BABJIABG">Retrieves ACL document that protects resource given its path name</SubProgram>
        <SubProgram Name="&quot;GETCONTENTBLOB&quot;" ElementId="#CHDFGGHA">Retrieves the contents of a resource returned as a BLOB</SubProgram>
        <SubProgram Name="&quot;GETCONTENTCLOB&quot;" ElementId="#CHDBIJFJ">Retrieves the contents of a resource returned as a CLOB</SubProgram>
        <SubProgram Name="&quot;GETCONTENTVARCHAR2&quot;" ElementId="#CHDEDBAF">Retrieves the contents of a resource returned as a string</SubProgram>
        <SubProgram Name="&quot;GETCONTENTXMLREF&quot;" ElementId="#CHDGIEBE">Retrieves the contents of a resource returned as a a REF to an XMLTYPE</SubProgram>
        <SubProgram Name="&quot;GETCONTENTXMLTYPE&quot;" ElementId="#CHDCDDBA">Retrieves the contents of a resource returned as an XMLTYPE</SubProgram>
        <SubProgram Name="&quot;GETFTPPORT&quot;" ElementId="#BDCFFJHG">Gets the value of the current FTP port</SubProgram>
        <SubProgram Name="&quot;GETHTTPPORT&quot;" ElementId="#BDCJBJBA">Gets the value of the current HTTP port</SubProgram>
        <SubProgram Name="&quot;GETHTTPREQUESTHEADER&quot;" ElementId="#BGBIGGCD">Gets the values of the passed header</SubProgram>
        <SubProgram Name="&quot;GETLISTENERENDPOINT&quot;" ElementId="#BGBGCCGG">Retrieves the parameters of a listener end point corresponding to the XML DB HTTP server</SubProgram>
        <SubProgram Name="&quot;GETLOCKTOKEN&quot;" ElementId="#i1010361">Returns that resource's lock token for the current user given a path to a resource</SubProgram>
        <SubProgram Name="&quot;GETPRIVILEGES&quot;" ElementId="#BGBJCEGI">Gets all privileges granted to the current user on a specified resource</SubProgram>
        <SubProgram Name="&quot;GETRESOID&quot;" ElementId="#i1009913">Returns the object ID of the resource from its absolute path</SubProgram>
        <SubProgram Name="&quot;GETXDB_TABLESPACE&quot;" ElementId="#i1009852">Returns the current tablespace of the XDB (user)</SubProgram>
        <SubProgram Name="&quot;HASBLOBCONTENT&quot;" ElementId="#CHDHJIHI">Returns TRUE if the resource has BLOB content</SubProgram>
        <SubProgram Name="&quot;HASCHARCONTENT&quot;" ElementId="#CHDGBFCI">Returns TRUE if the resource has character content</SubProgram>
        <SubProgram Name="&quot;HASXMLCONTENT&quot;" ElementId="#CHDGCDIH">Returns TRUE if the resource has XML content</SubProgram>
        <SubProgram Name="&quot;HASXMLREFERENCE&quot;" ElementId="#CHDJEDJG">Returns TRUE if the resource has REF to XML content</SubProgram>
        <SubProgram Name="&quot;ISFOLDER&quot;" ElementId="#CHDDDEGD">Returns TRUE if the resource is a folder or container</SubProgram>
        <SubProgram Name="&quot;LINK&quot;" ElementId="#i1009588">Creates a link to an existing resource</SubProgram>
        <SubProgram Name="&quot;LOCKRESOURCE&quot;" ElementId="#i1004427">Gets a WebDAV-style lock on that resource given a path to that resource</SubProgram>
        <SubProgram Name="&quot;PROCESSLINKS&quot;" ElementId="#BDCGJGGF">Processes document links in the specified resource</SubProgram>
        <SubProgram Name="&quot;PURGERESOURCEMETADATA&quot;" ElementId="#BGBHDJFC">Deletes all user metadata from a resource</SubProgram>
        <SubProgram Name="&quot;RENAMERESOURCE&quot;" ElementId="#i1010294">Renames the XDB resource</SubProgram>
        <SubProgram Name="&quot;SETACL&quot;" ElementId="#i1010297">Sets the ACL on a specified resource</SubProgram>
        <SubProgram Name="&quot;SETFTPPORT&quot;" ElementId="#BDCFGCJE">Sets the FTP port to a new value</SubProgram>
        <SubProgram Name="&quot;SETHTTPPORT&quot;" ElementId="#CHDJBAEF">Sets the HTTP port to a new value</SubProgram>
        <SubProgram Name="&quot;SETLISTENERENDPOINT&quot;" ElementId="#BGBICAII">Sets the parameters of a listener end point corresponding to the XML DB HTTP server</SubProgram>
        <SubProgram Name="&quot;SETLISTENERLOCALACCESS&quot;" ElementId="#BGBIHIFI">Restricts all listener end points of the XML DB HTTP server to listen either only on the localhost interface or on both localhost and non-localhost interfaces</SubProgram>
        <SubProgram Name="&quot;SPLITPATH&quot;" ElementId="#BDCFDFBE">Splits the path into a parentpath and childpath</SubProgram>
        <SubProgram Name="&quot;TOUCHRESOURCE&quot;" ElementId="#CHDHHCIF">Changes the modification time of the resource to the current time</SubProgram>
        <SubProgram Name="&quot;UNLOCKRESOURCE&quot;" ElementId="#i1004491">Unlocks the resource given a lock token and resource path</SubProgram>
        <SubProgram Name="&quot;UPDATERESOURCEMETADATA&quot;" ElementId="#BDCEDDJH">Updates metadata for a resource</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XDB_ADMIN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xdb_admin.htm">
      <Description>The DBMS_XDB_ADMIN package provides an interface to manage the Oracle XML DB repository.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XDB_CONFIG&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xdb_config.htm">
      <Description>The DBMS_XDB_CONFIG package provides an interface for configuring Oracle XML DB and its repository.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADDHTTPEXPIREMAPPING&quot;" ElementId="#BABEJJAG">Adds to XDB$CONFIG a mapping of the URL pattern to an expiration date. This will control the Expire headers for URLs matching the pattern.</SubProgram>
        <SubProgram Name="&quot;ADDMIMEMAPPING&quot;" ElementId="#BABFJJID">Adds a mime mapping to XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDSCHEMALOCMAPPING&quot;" ElementId="#BABJEFJJ">Adds a schema location mapping to the XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDSERVLET&quot;" ElementId="#BABFDAED">Adds a servlet to XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDSERVLETMAPPING&quot;" ElementId="#BABJEEAE">Adds a servlet mapping to XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDSERVLETSECROLE&quot;" ElementId="#BABDJFJG">Adds a security role REF to a specified servlet in XDB configuration</SubProgram>
        <SubProgram Name="&quot;ADDXMLEXTENSION&quot;" ElementId="#BABBFIFA">Adds adds the following XML extension to the XDB configuration under &lt;xml-extensions&gt;: &lt;extension&gt;extension&lt;/extension&gt;</SubProgram>
        <SubProgram Name="&quot;CFG_GET&quot;" ElementId="#BABBJJIF">Retrieves the session's configuration information as an XMLType instance</SubProgram>
        <SubProgram Name="&quot;CFG_REFRESH&quot;" ElementId="#BABHJDED">Refreshes the session's configuration information to the latest configuration</SubProgram>
        <SubProgram Name="&quot;CFG_UPDATE&quot;" ElementId="#BABIGJFA">Updates the configuration information and commits the change.</SubProgram>
        <SubProgram Name="&quot;DELETEHTTPEXPIREMAPPING&quot;" ElementId="#BABFIDEB">Deletes from XDB$CONFIG all mappings of the URL pattern to an expiration date</SubProgram>
        <SubProgram Name="&quot;DELETEMIMEMAPPING&quot;" ElementId="#BABCBDJA">Deletes the mime mapping for a specified extension from the XDB configuration</SubProgram>
        <SubProgram Name="&quot;DELETESCHEMALOCMAPPING&quot;" ElementId="#BABEDJCD">Deletes the schema location mapping for a specified schema URL from the XDB configuration</SubProgram>
        <SubProgram Name="&quot;DELETESERVLET&quot;" ElementId="#BABDEADA">Deletes a servlet from the XDB configuration</SubProgram>
        <SubProgram Name="&quot;DELETESERVLETMAPPING&quot;" ElementId="#BABCDEGG">Deletes the servlet mapping for a specified servlet name from the XDB configuration</SubProgram>
        <SubProgram Name="&quot;DELETESERVLETSECROLE&quot;" ElementId="#BABEICHF">Deletes the specified role from a servlet in the XDB configuration</SubProgram>
        <SubProgram Name="&quot;DELETEXMLEXTENSION&quot;" ElementId="#BABHBIGF">Deletes the specified XML extension from the XDB configuration</SubProgram>
        <SubProgram Name="&quot;ENABLEDIGESTAUTHENTICATION&quot;" ElementId="#BABCIFDJ">Enables enables digest authentication</SubProgram>
        <SubProgram Name="&quot;GETFTPPORT&quot;" ElementId="#BABIBAFB">Gets the value of the current FTP port</SubProgram>
        <SubProgram Name="&quot;GETHTTPPORT&quot;" ElementId="#BABGEBCD">Gets the value of the current HTTP port</SubProgram>
        <SubProgram Name="&quot;GETHTTPCONFIGREALM&quot;" ElementId="#CEGBFHEI">Gets the realm name</SubProgram>
        <SubProgram Name="&quot;GETHTTPSPORT&quot;" ElementId="#BABEEDDA">Gets the value of the current HTTPS port</SubProgram>
        <SubProgram Name="&quot;GETLISTENERENDPOINT&quot;" ElementId="#BABEFCBH">Gets the parameters of a listener end point corresponding to the XML DB HTTP server</SubProgram>
        <SubProgram Name="&quot;SETFTPPORT&quot;" ElementId="#BABHJCFB">Sets the FTP port to a new value</SubProgram>
        <SubProgram Name="&quot;SETHTTPPORT&quot;" ElementId="#BABCBDGF">Sets the HTTP port to a new value</SubProgram>
        <SubProgram Name="&quot;SETHTTPCONFIGREALM&quot;" ElementId="#CEGIGFDC">Sets the realm to a new value</SubProgram>
        <SubProgram Name="&quot;SETHTTPSPORT&quot;" ElementId="#BABBAJAB">Sets the HTTPS port to a new value</SubProgram>
        <SubProgram Name="&quot;SETLISTENERENDPOINT&quot;" ElementId="#BABIIECG">Sets the parameters of a listener end point corresponding to the XML DB HTTP server</SubProgram>
        <SubProgram Name="&quot;SETLISTENERLOCALACCESS&quot;" ElementId="#BABECFGI">Restricts all listener end points of the XML DB HTTP server to listen either only on the localhost interface (when l_access is set to TRUE) or to listen on both localhost and non-localhost interfaces (when l_access is set to FALSE)</SubProgram>
        <SubProgram Name="&quot;USEDPORT&quot;" ElementId="#BABFDFGH">Obtains the port numbers used by other pluggable databases in the same consolidation database</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XDB_CONSTANTS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xdb_constants.htm">
      <Description>The DBMS_XDB_CONSTANTS package provides an interface to commonly used constants. Users should use constants instead of dynamic strings to avoid typographical errors.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ENCODING_DEFAULT&quot;" ElementId="#CACGIGDC">Returns 'AL32UTF8'</SubProgram>
        <SubProgram Name="&quot;ENCODING_ISOLATIN1&quot;" ElementId="#BABEDFIE">Returns 'WE8ISO8859P1'</SubProgram>
        <SubProgram Name="&quot;ENCODING_UTF8&quot;" ElementId="#CACGIDDF">Returns 'AL32UTF8'</SubProgram>
        <SubProgram Name="&quot;ENCODING_WIN1252&quot;" ElementId="#CACHBGDA">Returns 'WE8MSWIN1252'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_ACL&quot;" ElementId="#CACEGDBC">Returns 'http://xmlns.oracle.com/xdb/acl.xsd'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_METADATA&quot;" ElementId="#CACEIIJJ">Returns 'http://xmlns.oracle.com/xdbuserMetaData'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_ORACLE&quot;" ElementId="#CACDBDDG">Returns 'http://xmlns.oracle.com'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_ORACLE_XDB&quot;" ElementId="#CACIJCGF">Returns 'http://xmlns.oracle.com/xdb'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_RESOURCE&quot;" ElementId="#CACBAIJF">Returns 'http://xmlns.oracle.com/xdb/XDBResource.xsd'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_RESOURCE_EVENT&quot;" ElementId="#CACGHJEA">Returns 'http://xmlns.oracle.com/resourceEvent'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_RESOURCE_CONFIG&quot;" ElementId="#CACIIHBJ">Returns 'http://xmlns.oracle.com/XDBResConfig.xsd'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_XDBSCHEMA&quot;" ElementId="#CACDIHED">Returns 'http://xmlns.oracle.com/xdb/XDBSchema.xsd'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_XMLDIFF&quot;" ElementId="#CACEHFGH">Returns 'http://xmlns.oracle.com/xdb/xdiff.xsd'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_XMLINSTANCE&quot;" ElementId="#CACCIHAI">Returns 'http://www.w3.org/2001/XMLSchema-instance'</SubProgram>
        <SubProgram Name="&quot;NAMESPACE_XMLSCHEMA&quot;" ElementId="#CACFJIGB">Returns 'http://www.w3.org/2001/XMLSchema'</SubProgram>
        <SubProgram Name="&quot;NSPREFIX_ACL_ACL&quot;" ElementId="#CACHBHIJ">Returns 'xmlns:acl= 'http://xmlns.oracle.com/acs.xsd'</SubProgram>
        <SubProgram Name="&quot;NSPREFIX_RESCONFIG_RC&quot;" ElementId="#CACJFGBA">Returns 'xmlns:rc="http://xmlns.oracle.com/xdb/XDBResConfig.xsd"'</SubProgram>
        <SubProgram Name="&quot;NSPREFIX_RESOURCE_R&quot;" ElementId="#CACIIAAF">Returns 'xmlns:r="http://xmlns.oracle.com/XDBResource.xsd'</SubProgram>
        <SubProgram Name="&quot;NSPREFIX_XDB_XDB&quot;" ElementId="#CACFJDGF">Returns 'http://xmlns.oracle.com/xdb'</SubProgram>
        <SubProgram Name="&quot;NSPREFIX_XMLINSTANCE_XSI&quot;" ElementId="#CACHGBFH">Returns 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"'</SubProgram>
        <SubProgram Name="&quot;NSPREFIX_XMLDIFF_XD&quot;" ElementId="#CACFEJJH">Returns 'xmlns:xd="http://xmlns.oracle.com/xdb/xdiff.xsd"'</SubProgram>
        <SubProgram Name="&quot;NSPREFIX_XMLSCHEMA_XSD&quot;" ElementId="#CACGJIIA">Returns 'xmlns:xsd="http://www.w3.org/2001/XMLSchema"'</SubProgram>
        <SubProgram Name="&quot;SCHEMAURL_ACL&quot;" ElementId="#CACEJAEE">Returns 'http://xmlns.oracle.com/xdb/acl.xsd'</SubProgram>
        <SubProgram Name="&quot;SCHEMAELEM_RES_ACL&quot;" ElementId="#CACCAHAH">Returns 'http://xmlns.oracle.com/xdb/acl.xsd#acl'</SubProgram>
        <SubProgram Name="&quot;SCHEMAELEM_RESCONTENT_BINARY&quot;" ElementId="#CACBJGCI">Returns 'http://xmlns.oracle.com/xdb/XDBSchema.xsd#binary'</SubProgram>
        <SubProgram Name="&quot;SCHEMAELEM_RESCONTENT_TEXT&quot;" ElementId="#CACIGBJB">Returns 'http://xmlns.oracle.com/xdb/XDBSchema.xsd#text'</SubProgram>
        <SubProgram Name="&quot;SCHEMAURL_RESOURCE&quot;" ElementId="#CACCHHGJ">Returns 'http://xmlns.oracle.com/xdb/XDBResource.xsd'</SubProgram>
        <SubProgram Name="&quot;SCHEMAURL_XDBSCHEMA&quot;" ElementId="#CACBGDEI">Returns 'http://xmlns.oracle.com/xdb/XDBSchema.xsd'</SubProgram>
        <SubProgram Name="&quot;XDBSCHEMA_PREFIXES&quot;" ElementId="#CACJGEFF">Returns 'xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xdb="http://xmlns.oracle.com/xdb'</SubProgram>
        <SubProgram Name="&quot;XSD_ATTRIBUTE&quot;" ElementId="#CACFAGED">Returns 'attribute'</SubProgram>
        <SubProgram Name="&quot;XSD_COMPLEX_TYPE&quot;" ElementId="#CACBAHGC">Returns 'complexType'</SubProgram>
        <SubProgram Name="&quot;XSD_ELEMENT&quot;" ElementId="#CACIIEED">Returns 'element'</SubProgram>
        <SubProgram Name="&quot;XSD_GROUP&quot;" ElementId="#CACHBJBC">Returns 'group'</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XDB_REPOS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xdb_repos.htm">
      <Description>The DBMS_XDB_REPOS package provides an interface to operate on the Oracle XML database Repository.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ACLCHECKPRIVILEGES&quot;" ElementId="#BABIAFIH">Checks access privileges granted to the current user by specified ACL document on a resource whose owner is specified by the 'owner' parameter.</SubProgram>
        <SubProgram Name="&quot;APPENDRESOURCEMETADATA&quot;" ElementId="#BABGJCFJ">Takes in user-defined metadata either as a REF to XMLTYPE or an XMLTYPE and adds it to the desired resource</SubProgram>
        <SubProgram Name="&quot;CHANGEOWNER&quot;" ElementId="#BABJCICC">Changes the owner of the resource/s to the specified owner.</SubProgram>
        <SubProgram Name="&quot;CHANGEPRIVILEGES&quot;" ElementId="#BABDBBDJ">Adds a specified ACE to a specified resource's ACL</SubProgram>
        <SubProgram Name="&quot;CHECKPRIVILEGES&quot;" ElementId="#BABCBHGC">Checks access privileges granted to the current user on the specified resource</SubProgram>
        <SubProgram Name="&quot;CREATEFOLDER&quot;" ElementId="#BABCDCEB">Creates a new folder resource in the hierarchy</SubProgram>
        <SubProgram Name="&quot;CREATEOIDPATH&quot;" ElementId="#BABIAAJH">Creates a virtual path to the resource based on object ID</SubProgram>
        <SubProgram Name="&quot;CREATERESOURCE&quot;" ElementId="#BABJBFGH">Creates a new resource</SubProgram>
        <SubProgram Name="&quot;DELETERESOURCE&quot;" ElementId="#BABGBIJJ">Deletes a resource from the hierarchy</SubProgram>
        <SubProgram Name="&quot;DELETERESOURCEMETADATA&quot;" ElementId="#BABHAECG">Deletes metadata from a resource (can be used for schema-based or nonschema-based metadata)</SubProgram>
        <SubProgram Name="&quot;EXISTSRESOURCE&quot;" ElementId="#BABCDDGI">Determines if a resource is the hierarchy, based on its absolute path</SubProgram>
        <SubProgram Name="&quot;GETACLDOCUMENT&quot;" ElementId="#BABBFACB">Retrieves ACL document that protects resource given its path name</SubProgram>
        <SubProgram Name="&quot;GETCONTENTBLOB&quot;" ElementId="#BABFHBJC">Retrieves the contents of a resource returned as a BLOB</SubProgram>
        <SubProgram Name="&quot;GETCONTENTCLOB&quot;" ElementId="#BABEADGD">Retrieves the contents of a resource returned as a CLOB</SubProgram>
        <SubProgram Name="&quot;GETCONTENTVARCHAR2&quot;" ElementId="#BABEJHHD">Retrieves the contents of a resource returned as a string</SubProgram>
        <SubProgram Name="&quot;GETCONTENTXMLREF&quot;" ElementId="#BABDGEDG">Retrieves the contents of a resource returned as a a REF to an XMLTYPE</SubProgram>
        <SubProgram Name="&quot;GETCONTENTXMLTYPE&quot;" ElementId="#BABHHEHA">Retrieves the contents of a resource returned as an XMLTYPE</SubProgram>
        <SubProgram Name="&quot;GETLOCKTOKEN&quot;" ElementId="#BABIFBDI">Returns that resource's lock token for the current user given a path to a resource</SubProgram>
        <SubProgram Name="&quot;GETPRIVILEGES&quot;" ElementId="#BABBAGFI">Gets all privileges granted to the current user on a specified resource</SubProgram>
        <SubProgram Name="&quot;GETRESOID&quot;" ElementId="#BABEFJDC">Returns the object ID of the resource from its absolute path</SubProgram>
        <SubProgram Name="&quot;GETXDB_TABLESPACE&quot;" ElementId="#BABFCIIG">Returns the current tablespace of the XDB (user)</SubProgram>
        <SubProgram Name="&quot;HASBLOBCONTENT&quot;" ElementId="#BABFCAGJ">Returns TRUE if the resource has BLOB content</SubProgram>
        <SubProgram Name="&quot;HASCHARCONTENT&quot;" ElementId="#BABBFJAH">Returns TRUE if the resource has character content</SubProgram>
        <SubProgram Name="&quot;HASXMLCONTENT&quot;" ElementId="#BABJGDGE">Returns TRUE if the resource has XML content</SubProgram>
        <SubProgram Name="&quot;HASXMLREFERENCE&quot;" ElementId="#BABCDAIH">Returns TRUE if the resource has REF to XML content</SubProgram>
        <SubProgram Name="&quot;ISFOLDER&quot;" ElementId="#BABEEHEB">Returns TRUE if the resource is a folder or container</SubProgram>
        <SubProgram Name="&quot;LINK&quot;" ElementId="#BABIBFCC">Creates a link to an existing resource</SubProgram>
        <SubProgram Name="&quot;LOCKRESOURCE&quot;" ElementId="#BABFIEDI">Gets a WebDAV-style lock on that resource given a path to that resource</SubProgram>
        <SubProgram Name="&quot;PROCESSLINKS&quot;" ElementId="#BABCADAF">Processes document links in the specified resource</SubProgram>
        <SubProgram Name="&quot;PURGERESOURCEMETADATA&quot;" ElementId="#BABHBBGF">Deletes all user metadata from a resource</SubProgram>
        <SubProgram Name="&quot;RENAMERESOURCE&quot;" ElementId="#BABGCBFE">Renames the XDB resource</SubProgram>
        <SubProgram Name="&quot;SETACL&quot;" ElementId="#BABGJJBH">Sets the ACL on a specified resource</SubProgram>
        <SubProgram Name="&quot;SPLITPATH&quot;" ElementId="#BABGHJGB">Splits the path into a parentpath and childpath</SubProgram>
        <SubProgram Name="&quot;TOUCHRESOURCE&quot;" ElementId="#BABBHAAE">Changes the modification time of the resource to the current time</SubProgram>
        <SubProgram Name="&quot;UNLOCKRESOURCE&quot;" ElementId="#BABCAFIH">Unlocks the resource given a lock token and resource path</SubProgram>
        <SubProgram Name="&quot;UPDATERESOURCEMETADATA&quot;" ElementId="#BABIEFGI">Updates metadata for a resource</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XDB_VERSION&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xdb_ver.htm">
      <Description>Oracle XML DB versioning interfaces are found in the DBMS_XBD_VERSION package. Functions and procedures of DBMS_XDB_VERSION help to create a VCR and manage the versions in the version history.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XDBRESOURCE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xdbresource.htm">
      <Description>The DBMS_XDBRESOURCE package provides the interface to operate on the resource's metadata and contents.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XDBT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xdbt.htm">
      <Description>The DBMS_XDBT package provides a convenient mechanism for administrators to set up a CONTEXT index on the Oracle XML DB hierarchy. The package contains procedures to create default preferences, create the index and set up automatic synchronization of the CONTEXT index</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XDBZ&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xdbz.htm">
      <Description>The DBMS_XDBZ package controls the Oracle XML DB repository security, which is based on Access Control Lists (ACLs).</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XEVENT&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xevent.htm">
      <Description>The DBMS_XEVENTpackage provides event-related types and supporting subprograms.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLDOM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmldom.htm">
      <Description>The DBMS_XMLDOM package is used to access XMLType objects, and implements the Document Object Model (DOM), an application programming interface for HTML and XML documents.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLGEN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmlgen.htm">
      <Description>The DBMS_XMLGEN package converts the results of a SQL query to a canonical XML format. The package takes an arbitrary SQL query as input, converts it to XML format, and returns the result as a CLOB. This package is similar to the DBMS_XMLQUERY package, except that it is written in C and compiled into the kernel. This package can only be run on the database.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLINDEX&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmlindex.htm">
      <Description>The DBMS_XMLINDEX package provides an interface to implement asychronous indexing.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CREATEDATEINDEX&quot;" ElementId="#BABJJCGF">Creates a secondary index for date values in the VALUE column of a PATHTABLE which is the storage table of an XMLIndex</SubProgram>
        <SubProgram Name="&quot;CREATENUMBERINDEX&quot;" ElementId="#CEGCHFGD">Creates a secondary index for number values in the VALUE column of a PATHTABLE which is the storage table of an XMLIndex</SubProgram>
        <SubProgram Name="&quot;DROPPARAMETER&quot;" ElementId="#BABFJCIB">Drops the XMLIndex parameter string that is associated with a given parameter identifier.</SubProgram>
        <SubProgram Name="&quot;MODIFYPARAMETER&quot;" ElementId="#BABFEAJI">Modifies the XMLIndex parameter string that is associated with a given parameter name</SubProgram>
        <SubProgram Name="&quot;PROCESS_PENDING&quot;" ElementId="#BABGBCDD">Processes pending rows for a NONBLOCKINGALTERINDEXOPERATION on an XMLIndex</SubProgram>
        <SubProgram Name="&quot;REGISTERPARAMETER&quot;" ElementId="#BABDFBEI">Registers a parameter string and XMLIndex parameter string pair in XDB</SubProgram>
        <SubProgram Name="&quot;SYNCINDEX&quot;" ElementId="#CEGCHBDC">Synchronizes the index manually</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLPARSER&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmlpar.htm">
      <Description>Using DBMS_XMLPARSER, you can access the contents and structure of XML documents. XML describes a class of data XML document objects. It partially describes the behavior of computer programs which process them. By construction, XML documents are conforming SGML documents.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLQUERY&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmlque.htm">
      <Description>DBMS_XMLQUERY provides database-to-XMLType functionality. Whenever possible, use DBMS_XMLGEN, a built-in package in C, instead of DBMS_XMLQUERY.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLOSECONTEXT&quot;" ElementId="#i1032651">Closes or deallocates a particular query context.</SubProgram>
        <SubProgram Name="&quot;GETDTD&quot;" ElementId="#i1032867">Generates the DTD.</SubProgram>
        <SubProgram Name="&quot;GETEXCEPTIONCONTENT&quot;" ElementId="#i1032681">Returns the thrown exception's error code and error message.</SubProgram>
        <SubProgram Name="&quot;GETNUMROWSPROCESSED&quot;" ElementId="#i1032765">Returns the number of rows processed for the query.</SubProgram>
        <SubProgram Name="&quot;GETVERSION&quot;" ElementId="#i1032787">Prints the version of the XSU in use.</SubProgram>
        <SubProgram Name="&quot;GETXML&quot;" ElementId="#i1032793">Generates the XML document.</SubProgram>
        <SubProgram Name="&quot;NEWCONTEXT&quot;" ElementId="#i1033802">Creates a query context and it returns the context handle.</SubProgram>
        <SubProgram Name="&quot;PROPAGATEORIGINALEXCEPTION&quot;" ElementId="#i1032972">Tells the XSU that if an exception is raised, and is being thrown, the XSU should throw the very exception raised; rather then, wrapping it with an OracleXMLSQLException.</SubProgram>
        <SubProgram Name="&quot;REMOVEXSLTPARAM&quot;" ElementId="#i1032925">Removes a particular top-level stylesheet parameter.</SubProgram>
        <SubProgram Name="&quot;SETBINDVALUE&quot;" ElementId="#i1033007">Sets a value for a particular bind name.</SubProgram>
        <SubProgram Name="&quot;SETCOLLIDATTRNAME&quot;" ElementId="#i1033127">Sets the name of the id attribute of the collection element's separator tag.</SubProgram>
        <SubProgram Name="&quot;SETDATAHEADER&quot;" ElementId="#i1033166">Sets the XML data header.</SubProgram>
        <SubProgram Name="&quot;SETDATEFORMAT&quot;" ElementId="#i1033212">Sets the format of the generated dates in the XML document.</SubProgram>
        <SubProgram Name="&quot;SETENCODINGTAG&quot;" ElementId="#i1033250">Sets the encoding processing instruction in the XML document.</SubProgram>
        <SubProgram Name="&quot;SETERRORTAG&quot;" ElementId="#i1027884">Sets the tag to be used to enclose the XML error documents.</SubProgram>
        <SubProgram Name="&quot;SETMAXROWS&quot;" ElementId="#i1033359">Sets the maximum number of rows to be converted to XML.</SubProgram>
        <SubProgram Name="&quot;SETMETAHEADER&quot;" ElementId="#i1033409">Sets the XML meta header.</SubProgram>
        <SubProgram Name="&quot;SETRAISEEXCEPTION&quot;" ElementId="#i1033437">Tells the XSU to throw the raised exceptions.</SubProgram>
        <SubProgram Name="&quot;SETRAISENOROWSEXCEPTION&quot;" ElementId="#i1033466">Tells the XSU to throw or not to throw an OracleXMLNoRowsException in the case when for one reason or another, the XML document generated is empty.</SubProgram>
        <SubProgram Name="&quot;SETROWIDATTRNAME&quot;" ElementId="#i1033512">Sets the name of the id attribute of the row enclosing tag.</SubProgram>
        <SubProgram Name="&quot;SETROWIDATTRVALUE&quot;" ElementId="#i1033541">Specifies the scalar column whose value is to be assigned to the id attribute of the row enclosing tag.</SubProgram>
        <SubProgram Name="&quot;SETROWSETTAG&quot;" ElementId="#i1033570">Sets the tag to be used to enclose the XML dataset.</SubProgram>
        <SubProgram Name="&quot;SETROWTAG&quot;" ElementId="#i1033598">Sets the tag to be used to enclose the XML element.</SubProgram>
        <SubProgram Name="&quot;SETSKIPROWS&quot;" ElementId="#i1028143">Sets the number of rows to skip.</SubProgram>
        <SubProgram Name="&quot;SETSQLTOXMLNAMEESCAPING&quot;" ElementId="#i1033681">This turns on or off escaping of XML tags in the case that the SQL object name, which is mapped to a XML identifier, is not a valid XML identifier.</SubProgram>
        <SubProgram Name="&quot;SETSTYLESHEETHEADER&quot;" ElementId="#i1028172">Sets the stylesheet header.</SubProgram>
        <SubProgram Name="&quot;SETTAGCASE&quot;" ElementId="#i1033636">Specified the case of the generated XML tags.</SubProgram>
        <SubProgram Name="&quot;SETXSLT&quot;" ElementId="#i1028208">Registers a stylesheet to be applied to generated XML.</SubProgram>
        <SubProgram Name="&quot;SETXSLTPARAM&quot;" ElementId="#i1028264">Sets the value of a top-level stylesheet parameter.</SubProgram>
        <SubProgram Name="&quot;USENULLATTRIBUTEINDICATOR&quot;" ElementId="#i1033052">Specifies weather to use an XML attribute to indicate NULLness.</SubProgram>
        <SubProgram Name="&quot;USETYPEFORCOLLELEMTAG&quot;" ElementId="#i1033080">Tells the XSU to use the collection element's type name as the collection element tag name.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLSAVE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmlsav.htm">
      <Description>DBMS_XMLSAVE provides XML to database-type functionality.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLEARKEYCOLUMNLIST&quot;" ElementId="#i1048316">Clears the key column list.</SubProgram>
        <SubProgram Name="&quot;CLEARUPDATECOLUMNLIST&quot;" ElementId="#i1048348">Clears the update column list.</SubProgram>
        <SubProgram Name="&quot;CLOSECONTEXT&quot;" ElementId="#i1048375">It closes/deallocates a particular save context.</SubProgram>
        <SubProgram Name="&quot;DELETEXML&quot;" ElementId="#i1048457">Deletes records specified by data from the XML document, from the table specified at the context creation time.</SubProgram>
        <SubProgram Name="&quot;GETEXCEPTIONCONTENT&quot;" ElementId="#i1048506">Returns the thrown exception's error code and error message.</SubProgram>
        <SubProgram Name="&quot;INSERTXML&quot;" ElementId="#i1049047">Inserts the XML document into the table specified at the context creation time.</SubProgram>
        <SubProgram Name="&quot;NEWCONTEXT&quot;" ElementId="#i1048451">Creates a save context, and returns the context handle.</SubProgram>
        <SubProgram Name="&quot;PROPAGATEORIGINALEXCEPTION&quot;" ElementId="#i1048621">Tells the XSU that if an exception is raised, and is being thrown, the XSU should throw the very exception raised; rather then, wrapping it with an OracleXMLSQLException.</SubProgram>
        <SubProgram Name="&quot;REMOVEXSLTPARAM&quot;" ElementId="#i1048909">Removes the value of a top-level stylesheet parameter</SubProgram>
        <SubProgram Name="&quot;SETBATCHSIZE&quot;" ElementId="#i1048725">Changes the batch size used during DML operations.</SubProgram>
        <SubProgram Name="&quot;SETCOMMITBATCH&quot;" ElementId="#i1048754">Sets the commit batch size.</SubProgram>
        <SubProgram Name="&quot;SETDATEFORMAT&quot;" ElementId="#i1049668">Sets the format of the generated dates in the XML document.</SubProgram>
        <SubProgram Name="&quot;SETIGNORECASE&quot;" ElementId="#i1048656">The XSU does mapping of XML elements to database.</SubProgram>
        <SubProgram Name="&quot;SETKEYCOLUMN&quot;" ElementId="#i1048827">This methods adds a column to the key column list.</SubProgram>
        <SubProgram Name="&quot;SETPRESERVEWHITESPACE&quot;" ElementId="#i1048792">Tells the XSU whether to preserve whitespace or not.</SubProgram>
        <SubProgram Name="&quot;SETROWTAG&quot;" ElementId="#i1045022">Names the tag used in the XML document to enclose the XML elements corresponding to database.</SubProgram>
        <SubProgram Name="&quot;SETSQLTOXMLNAMEESCAPING&quot;" ElementId="#i1045165">This turns on or off escaping of XML tags in the case that the SQL object name, which is mapped to a XML identifier, is not a valid XML identifier.</SubProgram>
        <SubProgram Name="&quot;SETUPDATECOLUMN&quot;" ElementId="#i1045194">Adds a column to the update column list.</SubProgram>
        <SubProgram Name="&quot;SETXSLT&quot;" ElementId="#i1045323">Registers a XSL transform to be applied to the XML to be saved.</SubProgram>
        <SubProgram Name="&quot;SETXSLTPARAM&quot;" ElementId="#i1045379">Sets the value of a top-level stylesheet parameter.</SubProgram>
        <SubProgram Name="&quot;UPDATEXML&quot;" ElementId="#i1045488">Updates the table given the XML document.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLSCHEMA&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmlsch.htm">
      <Description>DBMS_XMLSCHEMA package provides procedures to manage XML schemas. It is created by script dbmsxsch.sql during Oracle database installation.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;COMPILESCHEMA&quot;" ElementId="#BABDFDJF">Used to re-compile an already registered XML schema. This is useful for bringing a schema in an invalid state to a valid state.</SubProgram>
        <SubProgram Name="&quot;COPYEVOLVE&quot;" ElementId="#i1008264">Evolves registered schemas so that existing XML instances remain valid</SubProgram>
        <SubProgram Name="&quot;DELETESCHEMA&quot;" ElementId="#i1007471">Removes the schema from the database</SubProgram>
        <SubProgram Name="&quot;GENERATESCHEMA&quot;" ElementId="#i1009760">Generates an XML schema from an oracle type name</SubProgram>
        <SubProgram Name="&quot;GENERATESCHEMAS&quot;" ElementId="#i1007548">Generates several XML schemas from an oracle type name</SubProgram>
        <SubProgram Name="&quot;INPLACEEVOLVE&quot;" ElementId="#BABEJBJE">Evolves registered schemas by propagating schema changes to object types and tables</SubProgram>
        <SubProgram Name="&quot;PURGESCHEMA&quot;" ElementId="#BABEGJDD">Removes the XML schema</SubProgram>
        <SubProgram Name="&quot;REGISTERSCHEMA&quot;" ElementId="#i1003177">Registers the specified schema for use by Oracle. This schema can then be used to store documents conforming to this.</SubProgram>
        <SubProgram Name="&quot;REGISTERURI&quot;" ElementId="#i1003294">Registers an XML schema specified by a URI name</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLSCHEMA_ANNOTATE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmlschema_annotate.htm">
      <Description>The DBMS_XMLSCHEMA_ANNOTATE package provides an interface to manage and configure the structured storage model, mainly through the use of pre-registration schema annotations.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADDXDBNAMESPACE&quot;" ElementId="#CIACDDCB">Adds the XDB namespace required for XDB annotation</SubProgram>
        <SubProgram Name="&quot;DISABLEDEFAULTTABLECREATION&quot;" ElementId="#CIAEBGAD">Prevents the creation of a table for the top-level element by adding a default table attribute with an empty value to the element</SubProgram>
        <SubProgram Name="&quot;DISABLEMAINTAINDOM&quot;" ElementId="#CIABJECB">Sets the DOM fidelity attribute to FALSE</SubProgram>
        <SubProgram Name="&quot;ENABLEDEFAULTTABLECREATION&quot;" ElementId="#CIAIADID">Enables the creation of ALL top level tables by removing the empty default table name annotation</SubProgram>
        <SubProgram Name="&quot;ENABLEMAINTAINDOM&quot;" ElementId="#CIAJFABE">Sets the DOM fidelity attribute to TRUE</SubProgram>
        <SubProgram Name="&quot;GETSCHEMAANNOTATIONS&quot;" ElementId="#CIABBEIJ">Creates a document containing the differences between the annotated XML schema and the original XML schema</SubProgram>
        <SubProgram Name="&quot;GETSIDXDEFFROMVIEW&quot;" ElementId="#CIAICIEF">Takes a XMLTABLE view definition on a xmltype column or table and it returns a CLOB which can be used as parameter to create a structured xmlindex that backs up the XMLTABLE view as relational table</SubProgram>
        <SubProgram Name="&quot;PRINTWARNINGS&quot;" ElementId="#CIAEGJFJ">Lets a user raise or suppress a warning if an annotation maps to zero nodes in the XML schema</SubProgram>
        <SubProgram Name="&quot;REMOVEANYSTORAGE&quot;" ElementId="#CIAJGEEF">Removes the setting of the SQL type from the ANY child of the complex type with the given name</SubProgram>
        <SubProgram Name="&quot;REMOVEDEFAULTTABLE&quot;" ElementId="#CIAGFGAC">Removes any default table attribute given for the element. After calling this procedure, the system generates table names</SubProgram>
        <SubProgram Name="&quot;REMOVEMAINTAINDOM&quot;" ElementId="#CIAHIGDB">Removes all annotations used to maintain DOM from the given schema</SubProgram>
        <SubProgram Name="&quot;REMOVEOUTOFLINE&quot;" ElementId="#CIACDGCB">Removes any existing SQLInline attributes to prevent out-of-line storage</SubProgram>
        <SubProgram Name="&quot;REMOVESQLCOLLTYPE&quot;" ElementId="#CIACDACE">Removes a SQL collection type.</SubProgram>
        <SubProgram Name="&quot;REMOVESQLNAME&quot;" ElementId="#CIADBBHJ">Removes a SQLNAME from a global element</SubProgram>
        <SubProgram Name="&quot;REMOVESQLTYPE&quot;" ElementId="#CIAJHIEJ">Removes a SQL type</SubProgram>
        <SubProgram Name="&quot;REMOVESQLTYPEMAPPING&quot;" ElementId="#CIAFFDGC">Removes the SQL type mapping for the given schema type.</SubProgram>
        <SubProgram Name="&quot;REMOVETABLEPROPS&quot;" ElementId="#CIACFDHC">Removes the table storage properties from the CREATETABLE statement</SubProgram>
        <SubProgram Name="&quot;REMOVETIMESTAMPWITHTIMEZONE&quot;" ElementId="#CIAICJCC">Removes he setting of the TimeStampWithTimeZone datatype from all dateTime typed elements in the XML schema</SubProgram>
        <SubProgram Name="&quot;SETANYSTORAGE&quot;" ElementId="#CIAGHDIF">Assigns a SQL datatype to the ANY child of the complex type with the given name</SubProgram>
        <SubProgram Name="&quot;SETDEFAULTTABLE&quot;" ElementId="#CIAHABDI">Sets the name of the table for the specified global element</SubProgram>
        <SubProgram Name="&quot;SETOUTOFLINE&quot;" ElementId="#CIAHBFAG">Sets the SQLInline attribute to FALSE</SubProgram>
        <SubProgram Name="&quot;SETSCHEMAANNOTATATIONS&quot;" ElementId="#CIADJADJ">Takes the annotated differences resulting from a call to DBMS_XMLSCHEMA_ANNOTATE.GETSCHEMAANNOTATIONS and patches them into the provided XML schema</SubProgram>
        <SubProgram Name="&quot;SETSQLCOLLTYPE&quot;" ElementId="#CIACAICA">Assigns a SQL type name for a collection</SubProgram>
        <SubProgram Name="&quot;SETSQLNAME&quot;" ElementId="#CIAHAAHA">Assigns a name to the SQL attribute that corresponds to an element defined in the XML schema</SubProgram>
        <SubProgram Name="&quot;SETSQLTYPE&quot;" ElementId="#CIAJDJGA">Assigns a SQL type to a global object</SubProgram>
        <SubProgram Name="&quot;SETSQLTYPEMAPPING&quot;" ElementId="#CIAHHFBE">Defines a mapping of schema type and SQL type</SubProgram>
        <SubProgram Name="&quot;SETTABLEPROPS&quot;" ElementId="#CIAIJDDD">Specifies properties in the TABLE storage clause that is appended to the default CREATETABLE statement</SubProgram>
        <SubProgram Name="&quot;SETTIMESTAMPWITHTIMEZONE&quot;" ElementId="#CIAJFBAC">Sets the TIMESTAMPWITHTIMEZONE datatype to all dateTime typed elements in the XML schema</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLSTORAGE_MANAGE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmlstorage_man.htm">
      <Description>The DBMS_XMLSTORAGE_MANAGE package provides an interface to manage and modify XML storage after schema registration has been completed.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;DISABLEINDEXESANDCONSTRAINTS&quot;" ElementId="#CHDIJDBB">Disables the indexes and constraints for XMLType tables and XMLType columns</SubProgram>
        <SubProgram Name="&quot;ENABLEINDEXESANDCONSTRAINTS&quot;" ElementId="#CHDBBDAD">Rebuilds all indexes and enables the constraints on an XMLType table including its child tables and out-of-line tables</SubProgram>
        <SubProgram Name="&quot;EXCHANGEPOSTPROC&quot;" ElementId="#CHDDHJFI">Enable constraints after exchange partition</SubProgram>
        <SubProgram Name="&quot;EXCHANGEPREPROC&quot;" ElementId="#CHDJDIGH">Disable constraints before exchange partition</SubProgram>
        <SubProgram Name="&quot;INDEXXMLREFERENCES&quot;" ElementId="#CHDBIDDE">Creates unique indexes on the REF columns of the given XML type table or the XML type column of a given table</SubProgram>
        <SubProgram Name="&quot;RENAMECOLLECTIONTABLE&quot;" ElementId="#CHDCFFJH">Renames a collection table to the given table name</SubProgram>
        <SubProgram Name="&quot;SCOPEXMLREFERENCES&quot;" ElementId="#CHDDCBAC">Scopes all XML references. Scoped REF types require less storage space and allow more efficient access than unscoped REF types</SubProgram>
        <SubProgram Name="&quot;XPATH2TABCOLMAPPING&quot;" ElementId="#CHDCECHD">Maps a path expression (in XPath notation or DOT notations) to the corresponding table name and column name</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLSTORE&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmlstore.htm">
      <Description>DBMS_XMLSTORE provides the ability to store XML data in relational tables.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;CLEARKEYCOLUMNLIST&quot;" ElementId="#i1048244">Clears the key column list.</SubProgram>
        <SubProgram Name="&quot;CLEARUPDATECOLUMNLIST&quot;" ElementId="#i1048271">Clears the update column list.</SubProgram>
        <SubProgram Name="&quot;CLOSECONTEXT&quot;" ElementId="#i1048297">It closes/deallocates a particular save context.</SubProgram>
        <SubProgram Name="&quot;DELETEXML&quot;" ElementId="#i1048324">Deletes records specified by data from the XML document, from the table specified at the context creation time.</SubProgram>
        <SubProgram Name="&quot;INSERTXML&quot;" ElementId="#i1048381">Inserts the XML document into the table specified at the context creation time.</SubProgram>
        <SubProgram Name="&quot;NEWCONTEXT&quot;" ElementId="#i1044980">Creates a save context, and returns the context handle.</SubProgram>
        <SubProgram Name="&quot;SETKEYCOLUMN&quot;" ElementId="#i1048810">This method adds a column to the key column list.</SubProgram>
        <SubProgram Name="&quot;SETROWTAG&quot;" ElementId="#CJGJAFFC">Names the tag used in the XML document., to enclose the XML elements corresponding to the database.</SubProgram>
        <SubProgram Name="&quot;SETUPDATECOLUMN&quot;" ElementId="#CJGDEFEE">Adds a column to the "update column list".</SubProgram>
        <SubProgram Name="&quot;UPDATEXML&quot;" ElementId="#CJGJHJEA">Updates the table given the XML document.</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XMLTRANSLATIONS&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xmltranslations.htm">
      <Description>Note:
The DBMS_XMLTRANSLATIONS package is deprecated with Oracle Database 12c.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XPLAN&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xplan.htm">
      <Description>The DBMS_XPLAN package provides an easy way to display the output of the EXPLAINPLAN command in several, predefined formats. You can also use the DBMS_XPLAN package to display the plan of a statement stored in the Automatic Workload Repository (AWR) or stored in a SQL tuning set. It further provides a way to display the SQL execution plan and SQL execution runtime statistics for cached SQL cursors based on the information stored in the V$SQL_PLAN and V$SQL_PLAN_STATISTICS_ALL fixed views. Finally, it displays plans from a SQL plan baseline.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XSLPROCESSOR&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xslpro.htm">
      <Description>The DBMS_XSLPROCESSOR package provides an interface to manage the contents and structure of XML documents.</Description>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XSTREAM_ADM&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xstrm_adm.htm">
      <Description>This DBMS_XSTREAM_ADM package provides interfaces for streaming database changes between an Oracle database and other systems. XStream enables applications to stream out or stream in database changes.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;ADD_COLUMN&quot;" ElementId="#CHDJFCFI">Either adds or removes a declarative rule-based transformation which adds a column to a row logical change record (row LCR) that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;ADD_GLOBAL_PROPAGATION_RULES&quot;" ElementId="#CHDFHEEI">Either adds global rules to the positive rule set for a propagation, or adds global rules to the negative rule set for a propagation, and creates the specified propagation if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_GLOBAL_RULES&quot;" ElementId="#CHDIEFAG">Adds global rules to either the positive or negative rule set of a capture process or apply process, and creates the specified capture process or apply process if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_OUTBOUND&quot;" ElementId="#CACCCAJJ">Creates an XStream outbound server that dequeues LCRs from the specified queue</SubProgram>
        <SubProgram Name="&quot;ADD_SCHEMA_PROPAGATION_RULES&quot;" ElementId="#CHDFJBBC">Either adds schema rules to the positive rule set for a propagation, or adds schema rules to the negative rule set for a propagation, and creates the specified propagation if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_SCHEMA_RULES&quot;" ElementId="#CHDEHIHG">Adds rules to a rule set of XStream clients.</SubProgram>
        <SubProgram Name="&quot;ADD_SUBSET_OUTBOUND_RULES&quot;" ElementId="#CACFEEIC">Adds subset rules to an outbound server configuration</SubProgram>
        <SubProgram Name="&quot;ADD_SUBSET_PROPAGATION_RULES&quot;" ElementId="#CHDICIJJ">Adds subset rules to the positive rule set for a propagation, and creates the specified propagation if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_SUBSET_RULES&quot;" ElementId="#CHDGEGBB">Adds subset rules to the positive rule set of a capture process or apply process, and creates the specified capture process or apply process if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_TABLE_PROPAGATION_RULES&quot;" ElementId="#CHDHAGHE">Either adds table rules to the positive rule set for a propagation, or adds table rules to the negative rule set for a propagation, and creates the specified propagation if it does not exist</SubProgram>
        <SubProgram Name="&quot;ADD_TABLE_RULES&quot;" ElementId="#CHDBDCDG">This procedure adds rules to a rule set of an XStream client.</SubProgram>
        <SubProgram Name="&quot;ALTER_INBOUND&quot;" ElementId="#CACHIFDH">Modifies an XStream inbound server</SubProgram>
        <SubProgram Name="&quot;ALTER_OUTBOUND&quot;" ElementId="#CACEFHHB">Modifies an XStream outbound server</SubProgram>
        <SubProgram Name="&quot;CREATE_INBOUND&quot;" ElementId="#CACEGCGG">Creates an XStream inbound server and its queue</SubProgram>
        <SubProgram Name="&quot;CREATE_OUTBOUND&quot;" ElementId="#CACBHJDD">Creates an XStream outbound server, queue, and capture process to enable XStream client applications to stream out Oracle database changes encapsulated in LCRs</SubProgram>
        <SubProgram Name="&quot;DELETE_COLUMN&quot;" ElementId="#CHDIJJEC">Either adds or removes a declarative rule-based transformation which deletes a column from a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;DROP_INBOUND&quot;" ElementId="#CACBGICJ">Removes an inbound server configuration</SubProgram>
        <SubProgram Name="&quot;DROP_OUTBOUND&quot;" ElementId="#CACICJHG">Removes an outbound server configuration</SubProgram>
        <SubProgram Name="&quot;ENABLE_GG_XSTREAM_FOR_STREAMS&quot;" ElementId="#CIAHCHJD">Enables XStream performance optimizations for Oracle Streams components</SubProgram>
        <SubProgram Name="&quot;GET_MESSAGE_TRACKING&quot;" ElementId="#CHDDIGJF">Returns the tracking label for the current session</SubProgram>
        <SubProgram Name="&quot;GET_TAG&quot;" ElementId="#CHDJEBGF">Gets the binary tag for all redo entries generated by the current session</SubProgram>
        <SubProgram Name="&quot;IS_GG_XSTREAM_FOR_STREAMS&quot;" ElementId="#CIABJEJF">Returns TRUE if XStream performance optimizations are enabled for Oracle Streams components, or returns FALSE if XStream performance optimizations are disabled for Oracle Streams components</SubProgram>
        <SubProgram Name="&quot;KEEP_COLUMNS&quot;" ElementId="#CHDHEBJB">Either adds or removes a declarative rule-based transformation which keeps a list of columns in a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;MERGE_STREAMS&quot;" ElementId="#CHDEDACG">Merges a stream flowing from one capture process with a stream flowing from another capture process</SubProgram>
        <SubProgram Name="&quot;MERGE_STREAMS_JOB&quot;" ElementId="#CHDFDGBC">Determines whether the original capture process and the cloned capture are within the specified merge threshold and, if they are, runs the MERGE_STREAMS procedure to merge the two streams</SubProgram>
        <SubProgram Name="&quot;PURGE_SOURCE_CATALOG&quot;" ElementId="#CHDDAGED">Removes all Oracle Streams data dictionary information at the local database for the specified object</SubProgram>
        <SubProgram Name="&quot;RECOVER_OPERATION&quot;" ElementId="#CHDDGCAC">Provides options for a split and merge operation that stopped because it encountered an error. This procedure either rolls forward the operation, rolls back the operation, or purges all of the metadata about the operation.</SubProgram>
        <SubProgram Name="&quot;REMOVE_QUEUE&quot;" ElementId="#CHDBHEAC">Removes the specified ANYDATA queue</SubProgram>
        <SubProgram Name="&quot;REMOVE_RULE&quot;" ElementId="#CHDJFHCE">Removes the specified rule or all rules from the rule set associated with the specified capture process, apply process, or propagation.</SubProgram>
        <SubProgram Name="&quot;REMOVE_SUBSET_OUTBOUND_RULES&quot;" ElementId="#CACHABED">Removes subset rules from an outbound server configuration</SubProgram>
        <SubProgram Name="&quot;REMOVE_XSTREAM_CONFIGURATION&quot;" ElementId="#CHDJBFGH">Removes the XStream configuration at the local database</SubProgram>
        <SubProgram Name="&quot;RENAME_COLUMN&quot;" ElementId="#CHDJIGAC">Either adds or removes a declarative rule-based transformation which renames a column in a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;RENAME_SCHEMA&quot;" ElementId="#CHDEHAJI">Either adds or removes a declarative rule-based transformation which renames a schema in a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;RENAME_TABLE&quot;" ElementId="#CHDDBCIB">Either adds or removes a declarative rule-based transformation which renames a table in a row LCR that satisfies the specified rule</SubProgram>
        <SubProgram Name="&quot;SET_MESSAGE_TRACKING&quot;" ElementId="#CHDFIHCA">Sets the tracking label for logical change records (LCRs) produced by the current session</SubProgram>
        <SubProgram Name="&quot;SET_PARAMETER&quot;" ElementId="#CHDJAHAF">Sets a parameter for an outbound server, an inbound server, or an outbound server's capture process</SubProgram>
        <SubProgram Name="&quot;SET_TAG&quot;" ElementId="#CHDIJDFJ">Sets the binary tag for all redo entries subsequently generated by the current session</SubProgram>
        <SubProgram Name="&quot;SET_UP_QUEUE&quot;" ElementId="#CHDFIFAA">Creates a queue table and a queue for use with the capture, propagate, and apply functionality of XStream</SubProgram>
        <SubProgram Name="&quot;SPLIT_STREAMS&quot;" ElementId="#CHDHGCJB">Splits one stream flowing from a capture process off from all of the other streams flowing from the capture process</SubProgram>
        <SubProgram Name="&quot;START_OUTBOUND&quot;" ElementId="#CHDFHIGF">Starts an XStream outbound server</SubProgram>
        <SubProgram Name="&quot;STOP_OUTBOUND&quot;" ElementId="#CHDIJEIF">Stops an XStream outbound server</SubProgram>
      </SubPrograms>
    </Package>
    <Package Owner="&quot;SYS&quot;" Name="&quot;DBMS_XSTREAM_AUTH&quot;" Url="http://docs.oracle.com/database/121/ARPLS/d_xstrm_auth.htm">
      <Description>The DBMS_XSTREAM_AUTH package provides subprograms for granting privileges to and revoking privileges from XStream administrators.</Description>
      <SubPrograms>
        <SubProgram Name="&quot;GRANT_ADMIN_PRIVILEGE&quot;" ElementId="#BABCADCJ">Either grants the privileges needed by a user to be an XStream administrator directly, or generates a script that grants these privileges</SubProgram>
        <SubProgram Name="&quot;GRANT_REMOTE_ADMIN_ACCESS&quot;" ElementId="#BABEBCJF">Enables a remote XStream administrator to perform administrative actions at the local database by connecting to the grantee using a database link</SubProgram>
        <SubProgram Name="&quot;REVOKE_ADMIN_PRIVILEGE&quot;" ElementId="#BABCHDEG">Either revokes XStream administrator privileges from a user directly, or generates a script that revokes these privileges</SubProgram>
        <SubProgram Name="&quot;REVOKE_REMOTE_ADMIN_ACCESS&quot;" ElementId="#BABEIGIE">Disables a remote XStream administrator from performing administrative actions by connecting to the grantee using a database link</SubProgram>
      </SubPrograms>
    </Package>
  </Packages>
</Documentation>